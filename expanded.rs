#![feature(prelude_import)]
#![allow(unused)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
mod backend {
    use std::{cmp::Ordering, collections::VecDeque, path::Path, sync::Arc};
    use anki_direct::AnkiClient;
    use fancy_regex::Regex;
    use indexmap::{IndexMap, IndexSet};
    use language_transformer::{
        ja::japanese::{
            distribute_furigana_inflected, is_code_point_japanese, FuriganaSegment,
        },
        language_d::FindTermsTextReplacement,
    };
    use native_db::transaction::RwTransaction;
    use serde::{Deserialize, Serialize};
    use crate::{
        database::{
            dictionary_database::{DictionaryDatabase, DictionaryDatabaseError},
            dictionary_importer::DictionarySummary,
        },
        dictionary::{
            TermDictionaryEntry, TermSource, TermSourceMatchSource, TermSourceMatchType,
        },
        environment::{EnvironmentInfo, CACHED_ENVIRONMENT_INFO},
        settings::{
            DictionaryOptions, GeneralOptions, Options, ProfileOptions, ScanningOptions,
            SearchResolution, TranslationOptions, TranslationTextReplacementGroup,
            TranslationTextReplacementOptions,
        },
        text_scanner::{TermSearchResults, TextScanner},
        translation::{
            FindTermDictionary, FindTermsMatchType, FindTermsOptions,
            TermEnabledDictionaryMap,
        },
        translator::{
            EnabledDictionaryMapType, FindTermsMode, FindTermsResult, Translator,
        },
        Yomichan,
    };
    pub struct Backend<'a> {
        pub environment: EnvironmentInfo,
        pub anki: AnkiClient,
        pub text_scanner: TextScanner<'a>,
        pub db: Arc<DictionaryDatabase<'a>>,
        pub options: Options,
    }
    impl<'a> Backend<'a> {
        pub fn new(
            db: Arc<DictionaryDatabase<'a>>,
        ) -> Result<Self, Box<native_db::db_type::Error>> {
            let rtx = db.r_transaction()?;
            let opts: Option<Options> = rtx.get().primary("global_user_options")?;
            let options = match opts {
                Some(opts) => opts,
                None => Options::new(),
            };
            let backend = Self {
                environment: EnvironmentInfo::default(),
                anki: AnkiClient::default(),
                text_scanner: TextScanner::new(db.clone()),
                db,
                options,
            };
            Ok(backend)
        }
    }
    impl<'a> Backend<'a> {
        /// The internal impl to write global options to the database.
        /// This takes a [Option<RwTransaction>] so rwtx's can be reused if necessary.
        fn _update_options_internal(
            &self,
            rwtx: Option<RwTransaction>,
        ) -> Result<(), Box<native_db::db_type::Error>> {
            let rwtx = match rwtx {
                Some(rwtx) => Ok(rwtx),
                None => self.db.rw_transaction(),
            }?;
            rwtx.insert(self.options.clone())?;
            Ok(())
        }
    }
    impl Yomichan<'_> {
        /// Sets the current profile's main language.
        ///
        /// Only updates the language in Yomichan's memory (ie. does not persist);
        /// To save the set language to the db, call [Self::update_options] after.
        pub fn set_language(&mut self, language_iso: &str) {
            self.backend.options.get_current_profile_mut().options.general.language = language_iso
                .to_string();
        }
        /// Saves global options for all profiles to the database;
        /// Meant to be called after you mutate a profile (ie. via [Self::get_current_profile_mut])
        pub fn update_options(&self) -> Result<(), Box<native_db::db_type::Error>> {
            self.backend._update_options_internal(None);
            Ok(())
        }
        /// Deletes dictionaries from the database and options by name.
        /// This function automatically saves, so no need to call `update_options`.
        pub fn delete_dictionaries(
            &mut self,
            names: &[impl AsRef<str>],
        ) -> Result<(), Box<native_db::db_type::Error>> {
            let current_profile = self.backend.options.get_current_profile_mut();
            let dictionaries = &mut current_profile.options.dictionaries;
            for name in names {
                let name = name.as_ref();
                dictionaries.swap_remove(name);
            }
            self.update_options()?;
            Ok(())
        }
        /// Gets all dictionary summaries from the database.
        /// [DictionarySummary] is different from [DictionaryOptions]
        /// If you need [DictionaryOptions], use `dictionary_summaries`
        pub fn dictionary_summaries(
            &self,
        ) -> Result<Vec<DictionarySummary>, Box<DictionaryDatabaseError>> {
            self.db.get_dictionary_summaries()
        }
    }
    pub struct FindTermsDetails {
        pub match_type: Option<FindTermsMatchType>,
        pub deinflect: Option<bool>,
        pub primary_reading: Option<String>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for FindTermsDetails {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "FindTermsDetails",
                "match_type",
                &self.match_type,
                "deinflect",
                &self.deinflect,
                "primary_reading",
                &&self.primary_reading,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for FindTermsDetails {
        #[inline]
        fn clone(&self) -> FindTermsDetails {
            FindTermsDetails {
                match_type: ::core::clone::Clone::clone(&self.match_type),
                deinflect: ::core::clone::Clone::clone(&self.deinflect),
                primary_reading: ::core::clone::Clone::clone(&self.primary_reading),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for FindTermsDetails {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for FindTermsDetails {
        #[inline]
        fn eq(&self, other: &FindTermsDetails) -> bool {
            self.match_type == other.match_type && self.deinflect == other.deinflect
                && self.primary_reading == other.primary_reading
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for FindTermsDetails {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Option<FindTermsMatchType>>;
            let _: ::core::cmp::AssertParamIsEq<Option<bool>>;
            let _: ::core::cmp::AssertParamIsEq<Option<String>>;
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for FindTermsDetails {
        #[inline]
        fn partial_cmp(
            &self,
            other: &FindTermsDetails,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.match_type,
                &other.match_type,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.deinflect,
                        &other.deinflect,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            ::core::cmp::PartialOrd::partial_cmp(
                                &self.primary_reading,
                                &other.primary_reading,
                            )
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for FindTermsDetails {
        #[inline]
        fn cmp(&self, other: &FindTermsDetails) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.match_type, &other.match_type) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.deinflect, &other.deinflect) {
                        ::core::cmp::Ordering::Equal => {
                            ::core::cmp::Ord::cmp(
                                &self.primary_reading,
                                &other.primary_reading,
                            )
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    impl Default for FindTermsDetails {
        fn default() -> Self {
            Self {
                match_type: Some(FindTermsMatchType::Exact),
                deinflect: Some(true),
                primary_reading: None,
            }
        }
    }
    pub struct ParseTextSegment {
        text: String,
        reading: String,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ParseTextSegment {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "ParseTextSegment",
                "text",
                &self.text,
                "reading",
                &&self.reading,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ParseTextSegment {
        #[inline]
        fn clone(&self) -> ParseTextSegment {
            ParseTextSegment {
                text: ::core::clone::Clone::clone(&self.text),
                reading: ::core::clone::Clone::clone(&self.reading),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ParseTextSegment {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ParseTextSegment {
        #[inline]
        fn eq(&self, other: &ParseTextSegment) -> bool {
            self.text == other.text && self.reading == other.reading
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for ParseTextSegment {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<String>;
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for ParseTextSegment {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ParseTextSegment,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(&self.text, &other.text) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    ::core::cmp::PartialOrd::partial_cmp(&self.reading, &other.reading)
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for ParseTextSegment {
        #[inline]
        fn cmp(&self, other: &ParseTextSegment) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.text, &other.text) {
                ::core::cmp::Ordering::Equal => {
                    ::core::cmp::Ord::cmp(&self.reading, &other.reading)
                }
                cmp => cmp,
            }
        }
    }
    impl From<FuriganaSegment> for ParseTextSegment {
        fn from(value: FuriganaSegment) -> Self {
            Self {
                text: value.text,
                reading: value.reading.unwrap_or_default(),
            }
        }
    }
    type ParseTextLine = Vec<ParseTextSegment>;
    mod ycd_tests {
        use std::cell::RefCell;
        use crate::{
            database::dictionary_database::DatabaseMetaFrequency,
            dictionary_data::{
                GenericFreqData, TermMetaFreqDataMatchType, TermMetaModeType,
            },
            test_utils::TEST_PATHS, Yomichan,
        };
        use super::{Backend, FindTermsDetails};
    }
}
mod database {
    pub mod dictionary_database {
        use crate::dictionary::{
            DictionaryTag, TermSourceMatchSource, TermSourceMatchType,
        };
        use crate::dictionary_data::{
            DictionaryDataTag, MetaDataMatchType, TermGlossary, TermGlossaryContent,
            TermMeta, TermMetaFreqDataMatchType, TermMetaFrequency, TermMetaModeType,
            TermMetaPitch, TermMetaPitchData,
        };
        use crate::test_utils::TEST_PATHS;
        use crate::translator::TagTargetItem;
        use serde_with::{serde_as, NoneAsEmptyString};
        use crate::database::dictionary_importer::{DictionarySummary, TermMetaBank};
        use crate::errors::{DBError, DictionaryFileError, ImportError};
        use crate::settings::{DictionaryOptions, Options, Profile};
        use db_type::{KeyOptions, ToKeyDefinition};
        use indexmap::{IndexMap, IndexSet};
        use native_db::{transaction::query::PrimaryScan, Builder as DBBuilder, *};
        use native_model::{native_model, Model as NativeModelTrait};
        use serde::{Deserialize, Serialize};
        use serde_json::Deserializer as JsonDeserializer;
        use uuid::Uuid;
        use std::ffi::OsString;
        use std::io::BufReader;
        use std::path::{Path, PathBuf};
        use std::sync::LazyLock;
        use std::{fs, marker};
        impl DictionarySet for IndexSet<String> {
            fn has(&self, value: &str) -> bool {
                self.contains(value)
            }
        }
        impl DictionarySet for &IndexSet<String> {
            fn has(&self, value: &str) -> bool {
                self.contains(value)
            }
        }
        impl<V: Send + Sync> DictionarySet for IndexMap<String, V> {
            fn has(&self, value: &str) -> bool {
                self.contains_key(value)
            }
        }
        impl<V: Send + Sync> DictionarySet for &IndexMap<String, V> {
            fn has(&self, value: &str) -> bool {
                self.contains_key(value)
            }
        }
        pub static DB_MODELS: LazyLock<Models> = LazyLock::new(|| {
            let mut models = Models::new();
            models.define::<Options>().unwrap();
            models.define::<DictionarySummary>().unwrap();
            models.define::<DatabaseTermEntry>().unwrap();
            /// in js, freq, pitch, and phonetic are grouped under an enum
            /// native_model doesn't support this you can only have a single primary key
            /// so we add all 3 types
            models.define::<DatabaseMetaFrequency>().unwrap();
            models.define::<DatabaseMetaPitch>().unwrap();
            models.define::<DatabaseMetaPhonetic>().unwrap();
            models.define::<DatabaseKanjiEntry>().unwrap();
            models.define::<DatabaseKanjiMeta>().unwrap();
            models.define::<DatabaseTag>().unwrap();
            /// serialization is not implemented for this yet
            /// native_db doesn't like generics for the model struct
            /// until then don't serialize
            models
        });
        pub type MediaDataArrayBufferContent = MediaDataBase<Vec<u8>>;
        pub type MediaDataStringContent = MediaDataBase<String>;
        pub struct MediaDataBase<TContentType: Serialize> {
            dictionary: String,
            path: String,
            media_type: String,
            width: u16,
            height: u16,
            content: TContentType,
        }
        #[automatically_derived]
        impl<TContentType: ::core::clone::Clone + Serialize> ::core::clone::Clone
        for MediaDataBase<TContentType> {
            #[inline]
            fn clone(&self) -> MediaDataBase<TContentType> {
                MediaDataBase {
                    dictionary: ::core::clone::Clone::clone(&self.dictionary),
                    path: ::core::clone::Clone::clone(&self.path),
                    media_type: ::core::clone::Clone::clone(&self.media_type),
                    width: ::core::clone::Clone::clone(&self.width),
                    height: ::core::clone::Clone::clone(&self.height),
                    content: ::core::clone::Clone::clone(&self.content),
                }
            }
        }
        #[automatically_derived]
        impl<TContentType: ::core::fmt::Debug + Serialize> ::core::fmt::Debug
        for MediaDataBase<TContentType> {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "dictionary",
                    "path",
                    "media_type",
                    "width",
                    "height",
                    "content",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.dictionary,
                    &self.path,
                    &self.media_type,
                    &self.width,
                    &self.height,
                    &&self.content,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "MediaDataBase",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl<TContentType: Serialize> ::core::marker::StructuralPartialEq
        for MediaDataBase<TContentType> {}
        #[automatically_derived]
        impl<TContentType: ::core::cmp::PartialEq + Serialize> ::core::cmp::PartialEq
        for MediaDataBase<TContentType> {
            #[inline]
            fn eq(&self, other: &MediaDataBase<TContentType>) -> bool {
                self.dictionary == other.dictionary && self.path == other.path
                    && self.media_type == other.media_type && self.width == other.width
                    && self.height == other.height && self.content == other.content
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<TContentType: Serialize> _serde::Serialize
            for MediaDataBase<TContentType>
            where
                TContentType: _serde::Serialize,
            {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "MediaDataBase",
                        false as usize + 1 + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "dictionary",
                        &self.dictionary,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "path",
                        &self.path,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "media_type",
                        &self.media_type,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "width",
                        &self.width,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "height",
                        &self.height,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "content",
                        &self.content,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de, TContentType: Serialize> _serde::Deserialize<'de>
            for MediaDataBase<TContentType>
            where
                TContentType: _serde::Deserialize<'de>,
            {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "dictionary" => _serde::__private::Ok(__Field::__field0),
                                "path" => _serde::__private::Ok(__Field::__field1),
                                "media_type" => _serde::__private::Ok(__Field::__field2),
                                "width" => _serde::__private::Ok(__Field::__field3),
                                "height" => _serde::__private::Ok(__Field::__field4),
                                "content" => _serde::__private::Ok(__Field::__field5),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"dictionary" => _serde::__private::Ok(__Field::__field0),
                                b"path" => _serde::__private::Ok(__Field::__field1),
                                b"media_type" => _serde::__private::Ok(__Field::__field2),
                                b"width" => _serde::__private::Ok(__Field::__field3),
                                b"height" => _serde::__private::Ok(__Field::__field4),
                                b"content" => _serde::__private::Ok(__Field::__field5),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de, TContentType: Serialize>
                    where
                        TContentType: _serde::Deserialize<'de>,
                    {
                        marker: _serde::__private::PhantomData<
                            MediaDataBase<TContentType>,
                        >,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de, TContentType: Serialize> _serde::de::Visitor<'de>
                    for __Visitor<'de, TContentType>
                    where
                        TContentType: _serde::Deserialize<'de>,
                    {
                        type Value = MediaDataBase<TContentType>;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct MediaDataBase",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct MediaDataBase with 6 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct MediaDataBase with 6 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct MediaDataBase with 6 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match _serde::de::SeqAccess::next_element::<
                                u16,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct MediaDataBase with 6 elements",
                                        ),
                                    );
                                }
                            };
                            let __field4 = match _serde::de::SeqAccess::next_element::<
                                u16,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            4usize,
                                            &"struct MediaDataBase with 6 elements",
                                        ),
                                    );
                                }
                            };
                            let __field5 = match _serde::de::SeqAccess::next_element::<
                                TContentType,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            5usize,
                                            &"struct MediaDataBase with 6 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(MediaDataBase {
                                dictionary: __field0,
                                path: __field1,
                                media_type: __field2,
                                width: __field3,
                                height: __field4,
                                content: __field5,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<u16> = _serde::__private::None;
                            let mut __field4: _serde::__private::Option<u16> = _serde::__private::None;
                            let mut __field5: _serde::__private::Option<TContentType> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "dictionary",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("path"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "media_type",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("width"),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<u16>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field4 => {
                                        if _serde::__private::Option::is_some(&__field4) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("height"),
                                            );
                                        }
                                        __field4 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<u16>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field5 => {
                                        if _serde::__private::Option::is_some(&__field5) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "content",
                                                ),
                                            );
                                        }
                                        __field5 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                TContentType,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("dictionary")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("path")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("media_type")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("width")?
                                }
                            };
                            let __field4 = match __field4 {
                                _serde::__private::Some(__field4) => __field4,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("height")?
                                }
                            };
                            let __field5 = match __field5 {
                                _serde::__private::Some(__field5) => __field5,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("content")?
                                }
                            };
                            _serde::__private::Ok(MediaDataBase {
                                dictionary: __field0,
                                path: __field1,
                                media_type: __field2,
                                width: __field3,
                                height: __field4,
                                content: __field5,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "dictionary",
                        "path",
                        "media_type",
                        "width",
                        "height",
                        "content",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "MediaDataBase",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                MediaDataBase<TContentType>,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        pub enum MediaType {
            ArrayBuffer(Vec<u8>),
            String(String),
        }
        #[automatically_derived]
        impl ::core::clone::Clone for MediaType {
            #[inline]
            fn clone(&self) -> MediaType {
                match self {
                    MediaType::ArrayBuffer(__self_0) => {
                        MediaType::ArrayBuffer(::core::clone::Clone::clone(__self_0))
                    }
                    MediaType::String(__self_0) => {
                        MediaType::String(::core::clone::Clone::clone(__self_0))
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for MediaType {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    MediaType::ArrayBuffer(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "ArrayBuffer",
                            &__self_0,
                        )
                    }
                    MediaType::String(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "String",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for MediaType {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for MediaType {
            #[inline]
            fn eq(&self, other: &MediaType) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
                    && match (self, other) {
                        (
                            MediaType::ArrayBuffer(__self_0),
                            MediaType::ArrayBuffer(__arg1_0),
                        ) => __self_0 == __arg1_0,
                        (MediaType::String(__self_0), MediaType::String(__arg1_0)) => {
                            __self_0 == __arg1_0
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for MediaType {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        MediaType::ArrayBuffer(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "MediaType",
                                0u32,
                                "ArrayBuffer",
                                __field0,
                            )
                        }
                        MediaType::String(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "MediaType",
                                1u32,
                                "String",
                                __field0,
                            )
                        }
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for MediaType {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 2",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "ArrayBuffer" => _serde::__private::Ok(__Field::__field0),
                                "String" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"ArrayBuffer" => _serde::__private::Ok(__Field::__field0),
                                b"String" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<MediaType>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = MediaType;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum MediaType",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            Vec<u8>,
                                        >(__variant),
                                        MediaType::ArrayBuffer,
                                    )
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            String,
                                        >(__variant),
                                        MediaType::String,
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &["ArrayBuffer", "String"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "MediaType",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<MediaType>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        pub struct Media<T = MediaType> {
            index: usize,
            data: T,
        }
        #[automatically_derived]
        impl<T: ::core::clone::Clone> ::core::clone::Clone for Media<T> {
            #[inline]
            fn clone(&self) -> Media<T> {
                Media {
                    index: ::core::clone::Clone::clone(&self.index),
                    data: ::core::clone::Clone::clone(&self.data),
                }
            }
        }
        #[automatically_derived]
        impl<T: ::core::fmt::Debug> ::core::fmt::Debug for Media<T> {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "Media",
                    "index",
                    &self.index,
                    "data",
                    &&self.data,
                )
            }
        }
        #[automatically_derived]
        impl<T> ::core::marker::StructuralPartialEq for Media<T> {}
        #[automatically_derived]
        impl<T: ::core::cmp::PartialEq> ::core::cmp::PartialEq for Media<T> {
            #[inline]
            fn eq(&self, other: &Media<T>) -> bool {
                self.index == other.index && self.data == other.data
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<T> _serde::Serialize for Media<T>
            where
                T: _serde::Serialize,
            {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "Media",
                        false as usize + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "index",
                        &self.index,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "data",
                        &self.data,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de, T> _serde::Deserialize<'de> for Media<T>
            where
                T: _serde::Deserialize<'de>,
            {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "index" => _serde::__private::Ok(__Field::__field0),
                                "data" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"index" => _serde::__private::Ok(__Field::__field0),
                                b"data" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de, T>
                    where
                        T: _serde::Deserialize<'de>,
                    {
                        marker: _serde::__private::PhantomData<Media<T>>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de, T> _serde::de::Visitor<'de> for __Visitor<'de, T>
                    where
                        T: _serde::Deserialize<'de>,
                    {
                        type Value = Media<T>;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct Media",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                usize,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Media with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                T,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct Media with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(Media {
                                index: __field0,
                                data: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<usize> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<T> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("index"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<usize>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("data"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<T>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("index")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("data")?
                                }
                            };
                            _serde::__private::Ok(Media {
                                index: __field0,
                                data: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["index", "data"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Media",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Media<T>>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        /// Represents a single term metadata entry found by find_term_meta_bulk.
        /// This structure matches the output of the JavaScript _createTermMeta function.
        pub struct DatabaseTermMeta {
            /// Index of the original query term in the input term_list_input.
            pub index: usize,
            /// The term expression. (Corresponds to JS row.expression, named 'term' in JS output)
            pub term: String,
            /// The type of metadata (e.g., Freq, Pitch, Ipa). (Corresponds to JS row.mode)
            pub mode: TermMetaModeType,
            /// The actual metadata content. (Corresponds to JS row.data)
            pub data: MetaDataMatchType,
            /// The name of the dictionary this metadata belongs to.
            pub dictionary: String,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for DatabaseTermMeta {
            #[inline]
            fn clone(&self) -> DatabaseTermMeta {
                DatabaseTermMeta {
                    index: ::core::clone::Clone::clone(&self.index),
                    term: ::core::clone::Clone::clone(&self.term),
                    mode: ::core::clone::Clone::clone(&self.mode),
                    data: ::core::clone::Clone::clone(&self.data),
                    dictionary: ::core::clone::Clone::clone(&self.dictionary),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for DatabaseTermMeta {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field5_finish(
                    f,
                    "DatabaseTermMeta",
                    "index",
                    &self.index,
                    "term",
                    &self.term,
                    "mode",
                    &self.mode,
                    "data",
                    &self.data,
                    "dictionary",
                    &&self.dictionary,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for DatabaseTermMeta {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for DatabaseTermMeta {
            #[inline]
            fn eq(&self, other: &DatabaseTermMeta) -> bool {
                self.index == other.index && self.term == other.term
                    && self.mode == other.mode && self.data == other.data
                    && self.dictionary == other.dictionary
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for DatabaseTermMeta {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "DatabaseTermMeta",
                        false as usize + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "index",
                        &self.index,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "term",
                        &self.term,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "mode",
                        &self.mode,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "data",
                        &self.data,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "dictionary",
                        &self.dictionary,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DatabaseTermMeta {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "index" => _serde::__private::Ok(__Field::__field0),
                                "term" => _serde::__private::Ok(__Field::__field1),
                                "mode" => _serde::__private::Ok(__Field::__field2),
                                "data" => _serde::__private::Ok(__Field::__field3),
                                "dictionary" => _serde::__private::Ok(__Field::__field4),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"index" => _serde::__private::Ok(__Field::__field0),
                                b"term" => _serde::__private::Ok(__Field::__field1),
                                b"mode" => _serde::__private::Ok(__Field::__field2),
                                b"data" => _serde::__private::Ok(__Field::__field3),
                                b"dictionary" => _serde::__private::Ok(__Field::__field4),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DatabaseTermMeta>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DatabaseTermMeta;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DatabaseTermMeta",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                usize,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DatabaseTermMeta with 5 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct DatabaseTermMeta with 5 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                TermMetaModeType,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct DatabaseTermMeta with 5 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match _serde::de::SeqAccess::next_element::<
                                MetaDataMatchType,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct DatabaseTermMeta with 5 elements",
                                        ),
                                    );
                                }
                            };
                            let __field4 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            4usize,
                                            &"struct DatabaseTermMeta with 5 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DatabaseTermMeta {
                                index: __field0,
                                term: __field1,
                                mode: __field2,
                                data: __field3,
                                dictionary: __field4,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<usize> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<
                                TermMetaModeType,
                            > = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<
                                MetaDataMatchType,
                            > = _serde::__private::None;
                            let mut __field4: _serde::__private::Option<String> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("index"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<usize>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("term"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("mode"),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                TermMetaModeType,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("data"),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                MetaDataMatchType,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field4 => {
                                        if _serde::__private::Option::is_some(&__field4) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "dictionary",
                                                ),
                                            );
                                        }
                                        __field4 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("index")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("term")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("mode")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("data")?
                                }
                            };
                            let __field4 = match __field4 {
                                _serde::__private::Some(__field4) => __field4,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("dictionary")?
                                }
                            };
                            _serde::__private::Ok(DatabaseTermMeta {
                                index: __field0,
                                term: __field1,
                                mode: __field2,
                                data: __field3,
                                dictionary: __field4,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "index",
                        "term",
                        "mode",
                        "data",
                        "dictionary",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DatabaseTermMeta",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DatabaseTermMeta>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        pub struct DatabaseTermEntry {
            #[primary_key]
            pub id: String,
            #[secondary_key]
            pub expression: String,
            #[secondary_key]
            pub reading: String,
            #[secondary_key]
            pub expression_reverse: String,
            #[secondary_key]
            pub reading_reverse: String,
            pub definition_tags: Option<String>,
            /// Legacy alias for the `definitionTags` field.
            pub tags: Option<String>,
            pub rules: String,
            pub score: i128,
            pub glossary: Vec<TermGlossary>,
            #[secondary_key]
            pub sequence: Option<i128>,
            pub term_tags: Option<String>,
            pub dictionary: String,
            pub file_path: OsString,
        }
        impl native_db::db_type::ToInput for DatabaseTermEntry {
            fn native_db_bincode_encode_to_vec(
                &self,
            ) -> native_db::db_type::Result<Vec<u8>> {
                native_db::bincode_encode_to_vec(self)
            }
            fn native_db_bincode_decode_from_slice(
                slice: &[u8],
            ) -> native_db::db_type::Result<Self> {
                Ok(native_db::bincode_decode_from_slice(slice)?.0)
            }
            fn native_db_model() -> native_db::Model {
                let mut secondary_tables_name = std::collections::HashSet::new();
                secondary_tables_name
                    .insert(
                        native_db::db_type::KeyDefinition::new(
                            DatabaseTermEntry::native_model_id(),
                            DatabaseTermEntry::native_model_version(),
                            "reading_reverse",
                            <String>::key_names(),
                            native_db::db_type::KeyOptions {
                                unique: false,
                                optional: false,
                            },
                        ),
                    );
                secondary_tables_name
                    .insert(
                        native_db::db_type::KeyDefinition::new(
                            DatabaseTermEntry::native_model_id(),
                            DatabaseTermEntry::native_model_version(),
                            "expression_reverse",
                            <String>::key_names(),
                            native_db::db_type::KeyOptions {
                                unique: false,
                                optional: false,
                            },
                        ),
                    );
                secondary_tables_name
                    .insert(
                        native_db::db_type::KeyDefinition::new(
                            DatabaseTermEntry::native_model_id(),
                            DatabaseTermEntry::native_model_version(),
                            "sequence",
                            <Option<i128>>::key_names(),
                            native_db::db_type::KeyOptions {
                                unique: false,
                                optional: false,
                            },
                        ),
                    );
                secondary_tables_name
                    .insert(
                        native_db::db_type::KeyDefinition::new(
                            DatabaseTermEntry::native_model_id(),
                            DatabaseTermEntry::native_model_version(),
                            "reading",
                            <String>::key_names(),
                            native_db::db_type::KeyOptions {
                                unique: false,
                                optional: false,
                            },
                        ),
                    );
                secondary_tables_name
                    .insert(
                        native_db::db_type::KeyDefinition::new(
                            DatabaseTermEntry::native_model_id(),
                            DatabaseTermEntry::native_model_version(),
                            "expression",
                            <String>::key_names(),
                            native_db::db_type::KeyOptions {
                                unique: false,
                                optional: false,
                            },
                        ),
                    );
                native_db::Model {
                    primary_key: native_db::db_type::KeyDefinition::new(
                        DatabaseTermEntry::native_model_id(),
                        DatabaseTermEntry::native_model_version(),
                        "id",
                        <String>::key_names(),
                        (),
                    ),
                    secondary_keys: secondary_tables_name,
                }
            }
            fn native_db_primary_key(&self) -> native_db::db_type::Key {
                (&self.id).to_key()
            }
            fn native_db_secondary_keys(
                &self,
            ) -> std::collections::HashMap<
                native_db::db_type::KeyDefinition<native_db::db_type::KeyOptions>,
                native_db::db_type::KeyEntry,
            > {
                let mut secondary_tables_name = std::collections::HashMap::new();
                let value: native_db::db_type::Key = (&self.reading_reverse).to_key();
                let value = native_db::db_type::KeyEntry::Default(value);
                secondary_tables_name
                    .insert(
                        native_db::db_type::KeyDefinition::new(
                            DatabaseTermEntry::native_model_id(),
                            DatabaseTermEntry::native_model_version(),
                            "reading_reverse",
                            <String>::key_names(),
                            native_db::db_type::KeyOptions {
                                unique: false,
                                optional: false,
                            },
                        ),
                        value,
                    );
                let value: native_db::db_type::Key = (&self.expression_reverse).to_key();
                let value = native_db::db_type::KeyEntry::Default(value);
                secondary_tables_name
                    .insert(
                        native_db::db_type::KeyDefinition::new(
                            DatabaseTermEntry::native_model_id(),
                            DatabaseTermEntry::native_model_version(),
                            "expression_reverse",
                            <String>::key_names(),
                            native_db::db_type::KeyOptions {
                                unique: false,
                                optional: false,
                            },
                        ),
                        value,
                    );
                let value: native_db::db_type::Key = (&self.sequence).to_key();
                let value = native_db::db_type::KeyEntry::Default(value);
                secondary_tables_name
                    .insert(
                        native_db::db_type::KeyDefinition::new(
                            DatabaseTermEntry::native_model_id(),
                            DatabaseTermEntry::native_model_version(),
                            "sequence",
                            <Option<i128>>::key_names(),
                            native_db::db_type::KeyOptions {
                                unique: false,
                                optional: false,
                            },
                        ),
                        value,
                    );
                let value: native_db::db_type::Key = (&self.reading).to_key();
                let value = native_db::db_type::KeyEntry::Default(value);
                secondary_tables_name
                    .insert(
                        native_db::db_type::KeyDefinition::new(
                            DatabaseTermEntry::native_model_id(),
                            DatabaseTermEntry::native_model_version(),
                            "reading",
                            <String>::key_names(),
                            native_db::db_type::KeyOptions {
                                unique: false,
                                optional: false,
                            },
                        ),
                        value,
                    );
                let value: native_db::db_type::Key = (&self.expression).to_key();
                let value = native_db::db_type::KeyEntry::Default(value);
                secondary_tables_name
                    .insert(
                        native_db::db_type::KeyDefinition::new(
                            DatabaseTermEntry::native_model_id(),
                            DatabaseTermEntry::native_model_version(),
                            "expression",
                            <String>::key_names(),
                            native_db::db_type::KeyOptions {
                                unique: false,
                                optional: false,
                            },
                        ),
                        value,
                    );
                secondary_tables_name
            }
        }
        #[allow(non_camel_case_types)]
        pub(crate) enum DatabaseTermEntryKey {
            #[allow(non_camel_case_types, dead_code)]
            reading_reverse,
            #[allow(non_camel_case_types, dead_code)]
            expression_reverse,
            #[allow(non_camel_case_types, dead_code)]
            sequence,
            #[allow(non_camel_case_types, dead_code)]
            reading,
            #[allow(non_camel_case_types, dead_code)]
            expression,
        }
        impl native_db::db_type::ToKeyDefinition<native_db::db_type::KeyOptions>
        for DatabaseTermEntryKey {
            fn key_definition(
                &self,
            ) -> native_db::db_type::KeyDefinition<native_db::db_type::KeyOptions> {
                match self {
                    DatabaseTermEntryKey::reading_reverse => {
                        native_db::db_type::KeyDefinition::new(
                            DatabaseTermEntry::native_model_id(),
                            DatabaseTermEntry::native_model_version(),
                            "reading_reverse",
                            <String>::key_names(),
                            native_db::db_type::KeyOptions {
                                unique: false,
                                optional: false,
                            },
                        )
                    }
                    DatabaseTermEntryKey::expression_reverse => {
                        native_db::db_type::KeyDefinition::new(
                            DatabaseTermEntry::native_model_id(),
                            DatabaseTermEntry::native_model_version(),
                            "expression_reverse",
                            <String>::key_names(),
                            native_db::db_type::KeyOptions {
                                unique: false,
                                optional: false,
                            },
                        )
                    }
                    DatabaseTermEntryKey::sequence => {
                        native_db::db_type::KeyDefinition::new(
                            DatabaseTermEntry::native_model_id(),
                            DatabaseTermEntry::native_model_version(),
                            "sequence",
                            <Option<i128>>::key_names(),
                            native_db::db_type::KeyOptions {
                                unique: false,
                                optional: false,
                            },
                        )
                    }
                    DatabaseTermEntryKey::reading => {
                        native_db::db_type::KeyDefinition::new(
                            DatabaseTermEntry::native_model_id(),
                            DatabaseTermEntry::native_model_version(),
                            "reading",
                            <String>::key_names(),
                            native_db::db_type::KeyOptions {
                                unique: false,
                                optional: false,
                            },
                        )
                    }
                    DatabaseTermEntryKey::expression => {
                        native_db::db_type::KeyDefinition::new(
                            DatabaseTermEntry::native_model_id(),
                            DatabaseTermEntry::native_model_version(),
                            "expression",
                            <String>::key_names(),
                            native_db::db_type::KeyOptions {
                                unique: false,
                                optional: false,
                            },
                        )
                    }
                    _ => {
                        ::std::rt::begin_panic("Unknown key");
                    }
                }
            }
        }
        impl native_model::Model for DatabaseTermEntry {
            fn native_model_id() -> u32 {
                2
            }
            fn native_model_id_str() -> &'static str {
                "2"
            }
            fn native_model_version() -> u32 {
                1
            }
            fn native_model_version_str() -> &'static str {
                "1"
            }
            fn native_model_encode_body(
                &self,
            ) -> std::result::Result<Vec<u8>, native_model::EncodeBodyError> {
                use native_model::Encode;
                native_model::bincode_1_3::Bincode::encode(self)
                    .map_err(|e| native_model::EncodeBodyError {
                        msg: ::alloc::__export::must_use({
                            let res = ::alloc::fmt::format(format_args!("{0}", e));
                            res
                        }),
                        source: e.into(),
                    })
            }
            fn native_model_encode_downgrade_body(
                self,
                version: u32,
            ) -> native_model::Result<Vec<u8>> {
                if version == Self::native_model_version() {
                    let result = self.native_model_encode_body()?;
                    Ok(result)
                } else if version < Self::native_model_version() {
                    Err(native_model::Error::DowngradeNotSupported {
                        from: version,
                        to: Self::native_model_version(),
                    })
                } else {
                    Err(native_model::Error::DowngradeNotSupported {
                        from: version,
                        to: Self::native_model_version(),
                    })
                }
            }
            fn native_model_decode_body(
                data: Vec<u8>,
                id: u32,
            ) -> std::result::Result<Self, native_model::DecodeBodyError> {
                if id != 2 {
                    return Err(native_model::DecodeBodyError::MismatchedModelId);
                }
                use native_model::Decode;
                native_model::bincode_1_3::Bincode::decode(data)
                    .map_err(|e| native_model::DecodeBodyError::DecodeError {
                        msg: ::alloc::__export::must_use({
                            let res = ::alloc::fmt::format(format_args!("{0}", e));
                            res
                        }),
                        source: e.into(),
                    })
            }
            fn native_model_decode_upgrade_body(
                data: Vec<u8>,
                id: u32,
                version: u32,
            ) -> native_model::Result<Self> {
                if version == Self::native_model_version() {
                    let result = Self::native_model_decode_body(data, id)?;
                    Ok(result)
                } else if version < Self::native_model_version() {
                    Err(native_model::Error::UpgradeNotSupported {
                        from: version,
                        to: Self::native_model_version(),
                    })
                } else {
                    Err(native_model::Error::UpgradeNotSupported {
                        from: version,
                        to: Self::native_model_version(),
                    })
                }
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for DatabaseTermEntry {
            #[inline]
            fn clone(&self) -> DatabaseTermEntry {
                DatabaseTermEntry {
                    id: ::core::clone::Clone::clone(&self.id),
                    expression: ::core::clone::Clone::clone(&self.expression),
                    reading: ::core::clone::Clone::clone(&self.reading),
                    expression_reverse: ::core::clone::Clone::clone(
                        &self.expression_reverse,
                    ),
                    reading_reverse: ::core::clone::Clone::clone(&self.reading_reverse),
                    definition_tags: ::core::clone::Clone::clone(&self.definition_tags),
                    tags: ::core::clone::Clone::clone(&self.tags),
                    rules: ::core::clone::Clone::clone(&self.rules),
                    score: ::core::clone::Clone::clone(&self.score),
                    glossary: ::core::clone::Clone::clone(&self.glossary),
                    sequence: ::core::clone::Clone::clone(&self.sequence),
                    term_tags: ::core::clone::Clone::clone(&self.term_tags),
                    dictionary: ::core::clone::Clone::clone(&self.dictionary),
                    file_path: ::core::clone::Clone::clone(&self.file_path),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for DatabaseTermEntry {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "expression",
                    "reading",
                    "expression_reverse",
                    "reading_reverse",
                    "definition_tags",
                    "tags",
                    "rules",
                    "score",
                    "glossary",
                    "sequence",
                    "term_tags",
                    "dictionary",
                    "file_path",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.expression,
                    &self.reading,
                    &self.expression_reverse,
                    &self.reading_reverse,
                    &self.definition_tags,
                    &self.tags,
                    &self.rules,
                    &self.score,
                    &self.glossary,
                    &self.sequence,
                    &self.term_tags,
                    &self.dictionary,
                    &&self.file_path,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "DatabaseTermEntry",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for DatabaseTermEntry {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for DatabaseTermEntry {
            #[inline]
            fn eq(&self, other: &DatabaseTermEntry) -> bool {
                self.id == other.id && self.expression == other.expression
                    && self.reading == other.reading
                    && self.expression_reverse == other.expression_reverse
                    && self.reading_reverse == other.reading_reverse
                    && self.definition_tags == other.definition_tags
                    && self.tags == other.tags && self.rules == other.rules
                    && self.score == other.score && self.glossary == other.glossary
                    && self.sequence == other.sequence
                    && self.term_tags == other.term_tags
                    && self.dictionary == other.dictionary
                    && self.file_path == other.file_path
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for DatabaseTermEntry {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "DatabaseTermEntry",
                        false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1
                            + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "id",
                        &self.id,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "expression",
                        &self.expression,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "reading",
                        &self.reading,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "expression_reverse",
                        &self.expression_reverse,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "reading_reverse",
                        &self.reading_reverse,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "definition_tags",
                        &self.definition_tags,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "tags",
                        &self.tags,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "rules",
                        &self.rules,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "score",
                        &self.score,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "glossary",
                        &self.glossary,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "sequence",
                        &self.sequence,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "term_tags",
                        &self.term_tags,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "dictionary",
                        &self.dictionary,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "file_path",
                        &self.file_path,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DatabaseTermEntry {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __field6,
                        __field7,
                        __field8,
                        __field9,
                        __field10,
                        __field11,
                        __field12,
                        __field13,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                6u64 => _serde::__private::Ok(__Field::__field6),
                                7u64 => _serde::__private::Ok(__Field::__field7),
                                8u64 => _serde::__private::Ok(__Field::__field8),
                                9u64 => _serde::__private::Ok(__Field::__field9),
                                10u64 => _serde::__private::Ok(__Field::__field10),
                                11u64 => _serde::__private::Ok(__Field::__field11),
                                12u64 => _serde::__private::Ok(__Field::__field12),
                                13u64 => _serde::__private::Ok(__Field::__field13),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "id" => _serde::__private::Ok(__Field::__field0),
                                "expression" => _serde::__private::Ok(__Field::__field1),
                                "reading" => _serde::__private::Ok(__Field::__field2),
                                "expression_reverse" => {
                                    _serde::__private::Ok(__Field::__field3)
                                }
                                "reading_reverse" => {
                                    _serde::__private::Ok(__Field::__field4)
                                }
                                "definition_tags" => {
                                    _serde::__private::Ok(__Field::__field5)
                                }
                                "tags" => _serde::__private::Ok(__Field::__field6),
                                "rules" => _serde::__private::Ok(__Field::__field7),
                                "score" => _serde::__private::Ok(__Field::__field8),
                                "glossary" => _serde::__private::Ok(__Field::__field9),
                                "sequence" => _serde::__private::Ok(__Field::__field10),
                                "term_tags" => _serde::__private::Ok(__Field::__field11),
                                "dictionary" => _serde::__private::Ok(__Field::__field12),
                                "file_path" => _serde::__private::Ok(__Field::__field13),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"id" => _serde::__private::Ok(__Field::__field0),
                                b"expression" => _serde::__private::Ok(__Field::__field1),
                                b"reading" => _serde::__private::Ok(__Field::__field2),
                                b"expression_reverse" => {
                                    _serde::__private::Ok(__Field::__field3)
                                }
                                b"reading_reverse" => {
                                    _serde::__private::Ok(__Field::__field4)
                                }
                                b"definition_tags" => {
                                    _serde::__private::Ok(__Field::__field5)
                                }
                                b"tags" => _serde::__private::Ok(__Field::__field6),
                                b"rules" => _serde::__private::Ok(__Field::__field7),
                                b"score" => _serde::__private::Ok(__Field::__field8),
                                b"glossary" => _serde::__private::Ok(__Field::__field9),
                                b"sequence" => _serde::__private::Ok(__Field::__field10),
                                b"term_tags" => _serde::__private::Ok(__Field::__field11),
                                b"dictionary" => _serde::__private::Ok(__Field::__field12),
                                b"file_path" => _serde::__private::Ok(__Field::__field13),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DatabaseTermEntry>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DatabaseTermEntry;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DatabaseTermEntry",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DatabaseTermEntry with 14 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct DatabaseTermEntry with 14 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct DatabaseTermEntry with 14 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct DatabaseTermEntry with 14 elements",
                                        ),
                                    );
                                }
                            };
                            let __field4 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            4usize,
                                            &"struct DatabaseTermEntry with 14 elements",
                                        ),
                                    );
                                }
                            };
                            let __field5 = match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            5usize,
                                            &"struct DatabaseTermEntry with 14 elements",
                                        ),
                                    );
                                }
                            };
                            let __field6 = match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            6usize,
                                            &"struct DatabaseTermEntry with 14 elements",
                                        ),
                                    );
                                }
                            };
                            let __field7 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            7usize,
                                            &"struct DatabaseTermEntry with 14 elements",
                                        ),
                                    );
                                }
                            };
                            let __field8 = match _serde::de::SeqAccess::next_element::<
                                i128,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            8usize,
                                            &"struct DatabaseTermEntry with 14 elements",
                                        ),
                                    );
                                }
                            };
                            let __field9 = match _serde::de::SeqAccess::next_element::<
                                Vec<TermGlossary>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            9usize,
                                            &"struct DatabaseTermEntry with 14 elements",
                                        ),
                                    );
                                }
                            };
                            let __field10 = match _serde::de::SeqAccess::next_element::<
                                Option<i128>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            10usize,
                                            &"struct DatabaseTermEntry with 14 elements",
                                        ),
                                    );
                                }
                            };
                            let __field11 = match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            11usize,
                                            &"struct DatabaseTermEntry with 14 elements",
                                        ),
                                    );
                                }
                            };
                            let __field12 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            12usize,
                                            &"struct DatabaseTermEntry with 14 elements",
                                        ),
                                    );
                                }
                            };
                            let __field13 = match _serde::de::SeqAccess::next_element::<
                                OsString,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            13usize,
                                            &"struct DatabaseTermEntry with 14 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DatabaseTermEntry {
                                id: __field0,
                                expression: __field1,
                                reading: __field2,
                                expression_reverse: __field3,
                                reading_reverse: __field4,
                                definition_tags: __field5,
                                tags: __field6,
                                rules: __field7,
                                score: __field8,
                                glossary: __field9,
                                sequence: __field10,
                                term_tags: __field11,
                                dictionary: __field12,
                                file_path: __field13,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field4: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field5: _serde::__private::Option<
                                Option<String>,
                            > = _serde::__private::None;
                            let mut __field6: _serde::__private::Option<
                                Option<String>,
                            > = _serde::__private::None;
                            let mut __field7: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field8: _serde::__private::Option<i128> = _serde::__private::None;
                            let mut __field9: _serde::__private::Option<
                                Vec<TermGlossary>,
                            > = _serde::__private::None;
                            let mut __field10: _serde::__private::Option<Option<i128>> = _serde::__private::None;
                            let mut __field11: _serde::__private::Option<
                                Option<String>,
                            > = _serde::__private::None;
                            let mut __field12: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field13: _serde::__private::Option<OsString> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "expression",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "reading",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "expression_reverse",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field4 => {
                                        if _serde::__private::Option::is_some(&__field4) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "reading_reverse",
                                                ),
                                            );
                                        }
                                        __field4 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field5 => {
                                        if _serde::__private::Option::is_some(&__field5) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "definition_tags",
                                                ),
                                            );
                                        }
                                        __field5 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<String>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field6 => {
                                        if _serde::__private::Option::is_some(&__field6) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("tags"),
                                            );
                                        }
                                        __field6 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<String>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field7 => {
                                        if _serde::__private::Option::is_some(&__field7) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("rules"),
                                            );
                                        }
                                        __field7 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field8 => {
                                        if _serde::__private::Option::is_some(&__field8) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("score"),
                                            );
                                        }
                                        __field8 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<i128>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field9 => {
                                        if _serde::__private::Option::is_some(&__field9) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "glossary",
                                                ),
                                            );
                                        }
                                        __field9 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Vec<TermGlossary>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field10 => {
                                        if _serde::__private::Option::is_some(&__field10) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "sequence",
                                                ),
                                            );
                                        }
                                        __field10 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<i128>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field11 => {
                                        if _serde::__private::Option::is_some(&__field11) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "term_tags",
                                                ),
                                            );
                                        }
                                        __field11 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<String>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field12 => {
                                        if _serde::__private::Option::is_some(&__field12) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "dictionary",
                                                ),
                                            );
                                        }
                                        __field12 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field13 => {
                                        if _serde::__private::Option::is_some(&__field13) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "file_path",
                                                ),
                                            );
                                        }
                                        __field13 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<OsString>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("id")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("expression")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("reading")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("expression_reverse")?
                                }
                            };
                            let __field4 = match __field4 {
                                _serde::__private::Some(__field4) => __field4,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("reading_reverse")?
                                }
                            };
                            let __field5 = match __field5 {
                                _serde::__private::Some(__field5) => __field5,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("definition_tags")?
                                }
                            };
                            let __field6 = match __field6 {
                                _serde::__private::Some(__field6) => __field6,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("tags")?
                                }
                            };
                            let __field7 = match __field7 {
                                _serde::__private::Some(__field7) => __field7,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("rules")?
                                }
                            };
                            let __field8 = match __field8 {
                                _serde::__private::Some(__field8) => __field8,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("score")?
                                }
                            };
                            let __field9 = match __field9 {
                                _serde::__private::Some(__field9) => __field9,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("glossary")?
                                }
                            };
                            let __field10 = match __field10 {
                                _serde::__private::Some(__field10) => __field10,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("sequence")?
                                }
                            };
                            let __field11 = match __field11 {
                                _serde::__private::Some(__field11) => __field11,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("term_tags")?
                                }
                            };
                            let __field12 = match __field12 {
                                _serde::__private::Some(__field12) => __field12,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("dictionary")?
                                }
                            };
                            let __field13 = match __field13 {
                                _serde::__private::Some(__field13) => __field13,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("file_path")?
                                }
                            };
                            _serde::__private::Ok(DatabaseTermEntry {
                                id: __field0,
                                expression: __field1,
                                reading: __field2,
                                expression_reverse: __field3,
                                reading_reverse: __field4,
                                definition_tags: __field5,
                                tags: __field6,
                                rules: __field7,
                                score: __field8,
                                glossary: __field9,
                                sequence: __field10,
                                term_tags: __field11,
                                dictionary: __field12,
                                file_path: __field13,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "id",
                        "expression",
                        "reading",
                        "expression_reverse",
                        "reading_reverse",
                        "definition_tags",
                        "tags",
                        "rules",
                        "score",
                        "glossary",
                        "sequence",
                        "term_tags",
                        "dictionary",
                        "file_path",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DatabaseTermEntry",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DatabaseTermEntry>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::default::Default for DatabaseTermEntry {
            #[inline]
            fn default() -> DatabaseTermEntry {
                DatabaseTermEntry {
                    id: ::core::default::Default::default(),
                    expression: ::core::default::Default::default(),
                    reading: ::core::default::Default::default(),
                    expression_reverse: ::core::default::Default::default(),
                    reading_reverse: ::core::default::Default::default(),
                    definition_tags: ::core::default::Default::default(),
                    tags: ::core::default::Default::default(),
                    rules: ::core::default::Default::default(),
                    score: ::core::default::Default::default(),
                    glossary: ::core::default::Default::default(),
                    sequence: ::core::default::Default::default(),
                    term_tags: ::core::default::Default::default(),
                    dictionary: ::core::default::Default::default(),
                    file_path: ::core::default::Default::default(),
                }
            }
        }
        pub struct TermEntry {
            pub id: String,
            pub index: usize,
            pub match_type: TermSourceMatchType,
            pub match_source: TermSourceMatchSource,
            pub term: String,
            pub reading: String,
            pub definition_tags: Vec<String>,
            pub term_tags: Vec<String>,
            pub rules: Vec<String>,
            pub definitions: Vec<TermGlossary>,
            pub score: i128,
            pub dictionary: String,
            pub sequence: i128,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for TermEntry {
            #[inline]
            fn clone(&self) -> TermEntry {
                TermEntry {
                    id: ::core::clone::Clone::clone(&self.id),
                    index: ::core::clone::Clone::clone(&self.index),
                    match_type: ::core::clone::Clone::clone(&self.match_type),
                    match_source: ::core::clone::Clone::clone(&self.match_source),
                    term: ::core::clone::Clone::clone(&self.term),
                    reading: ::core::clone::Clone::clone(&self.reading),
                    definition_tags: ::core::clone::Clone::clone(&self.definition_tags),
                    term_tags: ::core::clone::Clone::clone(&self.term_tags),
                    rules: ::core::clone::Clone::clone(&self.rules),
                    definitions: ::core::clone::Clone::clone(&self.definitions),
                    score: ::core::clone::Clone::clone(&self.score),
                    dictionary: ::core::clone::Clone::clone(&self.dictionary),
                    sequence: ::core::clone::Clone::clone(&self.sequence),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for TermEntry {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "index",
                    "match_type",
                    "match_source",
                    "term",
                    "reading",
                    "definition_tags",
                    "term_tags",
                    "rules",
                    "definitions",
                    "score",
                    "dictionary",
                    "sequence",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.index,
                    &self.match_type,
                    &self.match_source,
                    &self.term,
                    &self.reading,
                    &self.definition_tags,
                    &self.term_tags,
                    &self.rules,
                    &self.definitions,
                    &self.score,
                    &self.dictionary,
                    &&self.sequence,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "TermEntry",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for TermEntry {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for TermEntry {
            #[inline]
            fn eq(&self, other: &TermEntry) -> bool {
                self.id == other.id && self.index == other.index
                    && self.match_type == other.match_type
                    && self.match_source == other.match_source && self.term == other.term
                    && self.reading == other.reading
                    && self.definition_tags == other.definition_tags
                    && self.term_tags == other.term_tags && self.rules == other.rules
                    && self.definitions == other.definitions && self.score == other.score
                    && self.dictionary == other.dictionary
                    && self.sequence == other.sequence
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for TermEntry {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "TermEntry",
                        false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1
                            + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "id",
                        &self.id,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "index",
                        &self.index,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "match_type",
                        &self.match_type,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "match_source",
                        &self.match_source,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "term",
                        &self.term,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "reading",
                        &self.reading,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "definition_tags",
                        &self.definition_tags,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "term_tags",
                        &self.term_tags,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "rules",
                        &self.rules,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "definitions",
                        &self.definitions,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "score",
                        &self.score,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "dictionary",
                        &self.dictionary,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "sequence",
                        &self.sequence,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for TermEntry {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __field6,
                        __field7,
                        __field8,
                        __field9,
                        __field10,
                        __field11,
                        __field12,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                6u64 => _serde::__private::Ok(__Field::__field6),
                                7u64 => _serde::__private::Ok(__Field::__field7),
                                8u64 => _serde::__private::Ok(__Field::__field8),
                                9u64 => _serde::__private::Ok(__Field::__field9),
                                10u64 => _serde::__private::Ok(__Field::__field10),
                                11u64 => _serde::__private::Ok(__Field::__field11),
                                12u64 => _serde::__private::Ok(__Field::__field12),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "id" => _serde::__private::Ok(__Field::__field0),
                                "index" => _serde::__private::Ok(__Field::__field1),
                                "match_type" => _serde::__private::Ok(__Field::__field2),
                                "match_source" => _serde::__private::Ok(__Field::__field3),
                                "term" => _serde::__private::Ok(__Field::__field4),
                                "reading" => _serde::__private::Ok(__Field::__field5),
                                "definition_tags" => {
                                    _serde::__private::Ok(__Field::__field6)
                                }
                                "term_tags" => _serde::__private::Ok(__Field::__field7),
                                "rules" => _serde::__private::Ok(__Field::__field8),
                                "definitions" => _serde::__private::Ok(__Field::__field9),
                                "score" => _serde::__private::Ok(__Field::__field10),
                                "dictionary" => _serde::__private::Ok(__Field::__field11),
                                "sequence" => _serde::__private::Ok(__Field::__field12),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"id" => _serde::__private::Ok(__Field::__field0),
                                b"index" => _serde::__private::Ok(__Field::__field1),
                                b"match_type" => _serde::__private::Ok(__Field::__field2),
                                b"match_source" => _serde::__private::Ok(__Field::__field3),
                                b"term" => _serde::__private::Ok(__Field::__field4),
                                b"reading" => _serde::__private::Ok(__Field::__field5),
                                b"definition_tags" => {
                                    _serde::__private::Ok(__Field::__field6)
                                }
                                b"term_tags" => _serde::__private::Ok(__Field::__field7),
                                b"rules" => _serde::__private::Ok(__Field::__field8),
                                b"definitions" => _serde::__private::Ok(__Field::__field9),
                                b"score" => _serde::__private::Ok(__Field::__field10),
                                b"dictionary" => _serde::__private::Ok(__Field::__field11),
                                b"sequence" => _serde::__private::Ok(__Field::__field12),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<TermEntry>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = TermEntry;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct TermEntry",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct TermEntry with 13 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                usize,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct TermEntry with 13 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                TermSourceMatchType,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct TermEntry with 13 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match _serde::de::SeqAccess::next_element::<
                                TermSourceMatchSource,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct TermEntry with 13 elements",
                                        ),
                                    );
                                }
                            };
                            let __field4 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            4usize,
                                            &"struct TermEntry with 13 elements",
                                        ),
                                    );
                                }
                            };
                            let __field5 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            5usize,
                                            &"struct TermEntry with 13 elements",
                                        ),
                                    );
                                }
                            };
                            let __field6 = match _serde::de::SeqAccess::next_element::<
                                Vec<String>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            6usize,
                                            &"struct TermEntry with 13 elements",
                                        ),
                                    );
                                }
                            };
                            let __field7 = match _serde::de::SeqAccess::next_element::<
                                Vec<String>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            7usize,
                                            &"struct TermEntry with 13 elements",
                                        ),
                                    );
                                }
                            };
                            let __field8 = match _serde::de::SeqAccess::next_element::<
                                Vec<String>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            8usize,
                                            &"struct TermEntry with 13 elements",
                                        ),
                                    );
                                }
                            };
                            let __field9 = match _serde::de::SeqAccess::next_element::<
                                Vec<TermGlossary>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            9usize,
                                            &"struct TermEntry with 13 elements",
                                        ),
                                    );
                                }
                            };
                            let __field10 = match _serde::de::SeqAccess::next_element::<
                                i128,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            10usize,
                                            &"struct TermEntry with 13 elements",
                                        ),
                                    );
                                }
                            };
                            let __field11 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            11usize,
                                            &"struct TermEntry with 13 elements",
                                        ),
                                    );
                                }
                            };
                            let __field12 = match _serde::de::SeqAccess::next_element::<
                                i128,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            12usize,
                                            &"struct TermEntry with 13 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(TermEntry {
                                id: __field0,
                                index: __field1,
                                match_type: __field2,
                                match_source: __field3,
                                term: __field4,
                                reading: __field5,
                                definition_tags: __field6,
                                term_tags: __field7,
                                rules: __field8,
                                definitions: __field9,
                                score: __field10,
                                dictionary: __field11,
                                sequence: __field12,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<usize> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<
                                TermSourceMatchType,
                            > = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<
                                TermSourceMatchSource,
                            > = _serde::__private::None;
                            let mut __field4: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field5: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field6: _serde::__private::Option<Vec<String>> = _serde::__private::None;
                            let mut __field7: _serde::__private::Option<Vec<String>> = _serde::__private::None;
                            let mut __field8: _serde::__private::Option<Vec<String>> = _serde::__private::None;
                            let mut __field9: _serde::__private::Option<
                                Vec<TermGlossary>,
                            > = _serde::__private::None;
                            let mut __field10: _serde::__private::Option<i128> = _serde::__private::None;
                            let mut __field11: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field12: _serde::__private::Option<i128> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("index"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<usize>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "match_type",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                TermSourceMatchType,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "match_source",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                TermSourceMatchSource,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field4 => {
                                        if _serde::__private::Option::is_some(&__field4) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("term"),
                                            );
                                        }
                                        __field4 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field5 => {
                                        if _serde::__private::Option::is_some(&__field5) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "reading",
                                                ),
                                            );
                                        }
                                        __field5 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field6 => {
                                        if _serde::__private::Option::is_some(&__field6) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "definition_tags",
                                                ),
                                            );
                                        }
                                        __field6 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Vec<String>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field7 => {
                                        if _serde::__private::Option::is_some(&__field7) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "term_tags",
                                                ),
                                            );
                                        }
                                        __field7 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Vec<String>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field8 => {
                                        if _serde::__private::Option::is_some(&__field8) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("rules"),
                                            );
                                        }
                                        __field8 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Vec<String>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field9 => {
                                        if _serde::__private::Option::is_some(&__field9) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "definitions",
                                                ),
                                            );
                                        }
                                        __field9 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Vec<TermGlossary>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field10 => {
                                        if _serde::__private::Option::is_some(&__field10) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("score"),
                                            );
                                        }
                                        __field10 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<i128>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field11 => {
                                        if _serde::__private::Option::is_some(&__field11) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "dictionary",
                                                ),
                                            );
                                        }
                                        __field11 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field12 => {
                                        if _serde::__private::Option::is_some(&__field12) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "sequence",
                                                ),
                                            );
                                        }
                                        __field12 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<i128>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("id")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("index")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("match_type")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("match_source")?
                                }
                            };
                            let __field4 = match __field4 {
                                _serde::__private::Some(__field4) => __field4,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("term")?
                                }
                            };
                            let __field5 = match __field5 {
                                _serde::__private::Some(__field5) => __field5,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("reading")?
                                }
                            };
                            let __field6 = match __field6 {
                                _serde::__private::Some(__field6) => __field6,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("definition_tags")?
                                }
                            };
                            let __field7 = match __field7 {
                                _serde::__private::Some(__field7) => __field7,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("term_tags")?
                                }
                            };
                            let __field8 = match __field8 {
                                _serde::__private::Some(__field8) => __field8,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("rules")?
                                }
                            };
                            let __field9 = match __field9 {
                                _serde::__private::Some(__field9) => __field9,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("definitions")?
                                }
                            };
                            let __field10 = match __field10 {
                                _serde::__private::Some(__field10) => __field10,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("score")?
                                }
                            };
                            let __field11 = match __field11 {
                                _serde::__private::Some(__field11) => __field11,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("dictionary")?
                                }
                            };
                            let __field12 = match __field12 {
                                _serde::__private::Some(__field12) => __field12,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("sequence")?
                                }
                            };
                            _serde::__private::Ok(TermEntry {
                                id: __field0,
                                index: __field1,
                                match_type: __field2,
                                match_source: __field3,
                                term: __field4,
                                reading: __field5,
                                definition_tags: __field6,
                                term_tags: __field7,
                                rules: __field8,
                                definitions: __field9,
                                score: __field10,
                                dictionary: __field11,
                                sequence: __field12,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "id",
                        "index",
                        "match_type",
                        "match_source",
                        "term",
                        "reading",
                        "definition_tags",
                        "term_tags",
                        "rules",
                        "definitions",
                        "score",
                        "dictionary",
                        "sequence",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "TermEntry",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<TermEntry>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        impl DatabaseTermEntry {
            pub fn into_term_generic(
                self,
                match_type: &mut TermSourceMatchType,
                data: FindMulitBulkData,
            ) -> TermEntry {
                let match_source_is_term = data.index_index == 0;
                let match_source = match match_source_is_term {
                    true => TermSourceMatchSource::Term,
                    false => TermSourceMatchSource::Reading,
                };
                let found = match match_source {
                    TermSourceMatchSource::Term => self.expression == data.item,
                    TermSourceMatchSource::Reading => self.reading == data.item,
                    _ => {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "internal error: entered unreachable code: {0}",
                                format_args!(
                                    "DictionaryDatabase::into_term_generic does not expect the match_to be a sequence.",
                                ),
                            ),
                        );
                    }
                };
                if found {
                    *match_type = TermSourceMatchType::Exact;
                }
                self.into_term_entry_specific(match_source, *match_type, data.item_index)
            }
            pub fn into_term_entry_specific(
                self,
                match_source: TermSourceMatchSource,
                match_type: TermSourceMatchType,
                index: usize,
            ) -> TermEntry {
                let DatabaseTermEntry {
                    id,
                    expression,
                    reading,
                    expression_reverse: _expression_reverse,
                    reading_reverse: _reading_reverse,
                    definition_tags,
                    tags: _tags,
                    rules,
                    score,
                    glossary,
                    sequence,
                    term_tags,
                    dictionary,
                    file_path: _file_path,
                } = self;
                TermEntry {
                    id,
                    index,
                    match_type,
                    match_source,
                    term: expression,
                    reading,
                    definition_tags: split_optional_string_field(definition_tags),
                    term_tags: split_optional_string_field(term_tags),
                    rules: split_optional_string_field(Some(rules)),
                    definitions: glossary,
                    score,
                    dictionary,
                    sequence: sequence.unwrap_or(-1),
                }
            }
        }
        pub struct DatabaseTag {
            /// id field doesn't exist in JS
            /// need it because primary keys must be unique
            #[primary_key]
            pub id: String,
            #[secondary_key]
            pub name: String,
            #[secondary_key]
            pub category: String,
            pub order: u64,
            pub notes: String,
            pub score: i128,
            /// dictionary gets added afterwards
            /// it doesn't exist in any yomitan dictionary
            #[secondary_key]
            pub dictionary: String,
        }
        impl native_db::db_type::ToInput for DatabaseTag {
            fn native_db_bincode_encode_to_vec(
                &self,
            ) -> native_db::db_type::Result<Vec<u8>> {
                native_db::bincode_encode_to_vec(self)
            }
            fn native_db_bincode_decode_from_slice(
                slice: &[u8],
            ) -> native_db::db_type::Result<Self> {
                Ok(native_db::bincode_decode_from_slice(slice)?.0)
            }
            fn native_db_model() -> native_db::Model {
                let mut secondary_tables_name = std::collections::HashSet::new();
                secondary_tables_name
                    .insert(
                        native_db::db_type::KeyDefinition::new(
                            DatabaseTag::native_model_id(),
                            DatabaseTag::native_model_version(),
                            "dictionary",
                            <String>::key_names(),
                            native_db::db_type::KeyOptions {
                                unique: false,
                                optional: false,
                            },
                        ),
                    );
                secondary_tables_name
                    .insert(
                        native_db::db_type::KeyDefinition::new(
                            DatabaseTag::native_model_id(),
                            DatabaseTag::native_model_version(),
                            "name",
                            <String>::key_names(),
                            native_db::db_type::KeyOptions {
                                unique: false,
                                optional: false,
                            },
                        ),
                    );
                secondary_tables_name
                    .insert(
                        native_db::db_type::KeyDefinition::new(
                            DatabaseTag::native_model_id(),
                            DatabaseTag::native_model_version(),
                            "category",
                            <String>::key_names(),
                            native_db::db_type::KeyOptions {
                                unique: false,
                                optional: false,
                            },
                        ),
                    );
                native_db::Model {
                    primary_key: native_db::db_type::KeyDefinition::new(
                        DatabaseTag::native_model_id(),
                        DatabaseTag::native_model_version(),
                        "id",
                        <String>::key_names(),
                        (),
                    ),
                    secondary_keys: secondary_tables_name,
                }
            }
            fn native_db_primary_key(&self) -> native_db::db_type::Key {
                (&self.id).to_key()
            }
            fn native_db_secondary_keys(
                &self,
            ) -> std::collections::HashMap<
                native_db::db_type::KeyDefinition<native_db::db_type::KeyOptions>,
                native_db::db_type::KeyEntry,
            > {
                let mut secondary_tables_name = std::collections::HashMap::new();
                let value: native_db::db_type::Key = (&self.dictionary).to_key();
                let value = native_db::db_type::KeyEntry::Default(value);
                secondary_tables_name
                    .insert(
                        native_db::db_type::KeyDefinition::new(
                            DatabaseTag::native_model_id(),
                            DatabaseTag::native_model_version(),
                            "dictionary",
                            <String>::key_names(),
                            native_db::db_type::KeyOptions {
                                unique: false,
                                optional: false,
                            },
                        ),
                        value,
                    );
                let value: native_db::db_type::Key = (&self.name).to_key();
                let value = native_db::db_type::KeyEntry::Default(value);
                secondary_tables_name
                    .insert(
                        native_db::db_type::KeyDefinition::new(
                            DatabaseTag::native_model_id(),
                            DatabaseTag::native_model_version(),
                            "name",
                            <String>::key_names(),
                            native_db::db_type::KeyOptions {
                                unique: false,
                                optional: false,
                            },
                        ),
                        value,
                    );
                let value: native_db::db_type::Key = (&self.category).to_key();
                let value = native_db::db_type::KeyEntry::Default(value);
                secondary_tables_name
                    .insert(
                        native_db::db_type::KeyDefinition::new(
                            DatabaseTag::native_model_id(),
                            DatabaseTag::native_model_version(),
                            "category",
                            <String>::key_names(),
                            native_db::db_type::KeyOptions {
                                unique: false,
                                optional: false,
                            },
                        ),
                        value,
                    );
                secondary_tables_name
            }
        }
        #[allow(non_camel_case_types)]
        pub(crate) enum DatabaseTagKey {
            #[allow(non_camel_case_types, dead_code)]
            dictionary,
            #[allow(non_camel_case_types, dead_code)]
            name,
            #[allow(non_camel_case_types, dead_code)]
            category,
        }
        impl native_db::db_type::ToKeyDefinition<native_db::db_type::KeyOptions>
        for DatabaseTagKey {
            fn key_definition(
                &self,
            ) -> native_db::db_type::KeyDefinition<native_db::db_type::KeyOptions> {
                match self {
                    DatabaseTagKey::dictionary => {
                        native_db::db_type::KeyDefinition::new(
                            DatabaseTag::native_model_id(),
                            DatabaseTag::native_model_version(),
                            "dictionary",
                            <String>::key_names(),
                            native_db::db_type::KeyOptions {
                                unique: false,
                                optional: false,
                            },
                        )
                    }
                    DatabaseTagKey::name => {
                        native_db::db_type::KeyDefinition::new(
                            DatabaseTag::native_model_id(),
                            DatabaseTag::native_model_version(),
                            "name",
                            <String>::key_names(),
                            native_db::db_type::KeyOptions {
                                unique: false,
                                optional: false,
                            },
                        )
                    }
                    DatabaseTagKey::category => {
                        native_db::db_type::KeyDefinition::new(
                            DatabaseTag::native_model_id(),
                            DatabaseTag::native_model_version(),
                            "category",
                            <String>::key_names(),
                            native_db::db_type::KeyOptions {
                                unique: false,
                                optional: false,
                            },
                        )
                    }
                    _ => {
                        ::std::rt::begin_panic("Unknown key");
                    }
                }
            }
        }
        impl native_model::Model for DatabaseTag {
            fn native_model_id() -> u32 {
                9
            }
            fn native_model_id_str() -> &'static str {
                "9"
            }
            fn native_model_version() -> u32 {
                1
            }
            fn native_model_version_str() -> &'static str {
                "1"
            }
            fn native_model_encode_body(
                &self,
            ) -> std::result::Result<Vec<u8>, native_model::EncodeBodyError> {
                use native_model::Encode;
                native_model::bincode_1_3::Bincode::encode(self)
                    .map_err(|e| native_model::EncodeBodyError {
                        msg: ::alloc::__export::must_use({
                            let res = ::alloc::fmt::format(format_args!("{0}", e));
                            res
                        }),
                        source: e.into(),
                    })
            }
            fn native_model_encode_downgrade_body(
                self,
                version: u32,
            ) -> native_model::Result<Vec<u8>> {
                if version == Self::native_model_version() {
                    let result = self.native_model_encode_body()?;
                    Ok(result)
                } else if version < Self::native_model_version() {
                    Err(native_model::Error::DowngradeNotSupported {
                        from: version,
                        to: Self::native_model_version(),
                    })
                } else {
                    Err(native_model::Error::DowngradeNotSupported {
                        from: version,
                        to: Self::native_model_version(),
                    })
                }
            }
            fn native_model_decode_body(
                data: Vec<u8>,
                id: u32,
            ) -> std::result::Result<Self, native_model::DecodeBodyError> {
                if id != 9 {
                    return Err(native_model::DecodeBodyError::MismatchedModelId);
                }
                use native_model::Decode;
                native_model::bincode_1_3::Bincode::decode(data)
                    .map_err(|e| native_model::DecodeBodyError::DecodeError {
                        msg: ::alloc::__export::must_use({
                            let res = ::alloc::fmt::format(format_args!("{0}", e));
                            res
                        }),
                        source: e.into(),
                    })
            }
            fn native_model_decode_upgrade_body(
                data: Vec<u8>,
                id: u32,
                version: u32,
            ) -> native_model::Result<Self> {
                if version == Self::native_model_version() {
                    let result = Self::native_model_decode_body(data, id)?;
                    Ok(result)
                } else if version < Self::native_model_version() {
                    Err(native_model::Error::UpgradeNotSupported {
                        from: version,
                        to: Self::native_model_version(),
                    })
                } else {
                    Err(native_model::Error::UpgradeNotSupported {
                        from: version,
                        to: Self::native_model_version(),
                    })
                }
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for DatabaseTag {
            #[inline]
            fn clone(&self) -> DatabaseTag {
                DatabaseTag {
                    id: ::core::clone::Clone::clone(&self.id),
                    name: ::core::clone::Clone::clone(&self.name),
                    category: ::core::clone::Clone::clone(&self.category),
                    order: ::core::clone::Clone::clone(&self.order),
                    notes: ::core::clone::Clone::clone(&self.notes),
                    score: ::core::clone::Clone::clone(&self.score),
                    dictionary: ::core::clone::Clone::clone(&self.dictionary),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for DatabaseTag {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "id",
                    "name",
                    "category",
                    "order",
                    "notes",
                    "score",
                    "dictionary",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.id,
                    &self.name,
                    &self.category,
                    &self.order,
                    &self.notes,
                    &self.score,
                    &&self.dictionary,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "DatabaseTag",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for DatabaseTag {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for DatabaseTag {
            #[inline]
            fn eq(&self, other: &DatabaseTag) -> bool {
                self.id == other.id && self.name == other.name
                    && self.category == other.category && self.order == other.order
                    && self.notes == other.notes && self.score == other.score
                    && self.dictionary == other.dictionary
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for DatabaseTag {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<String>;
                let _: ::core::cmp::AssertParamIsEq<u64>;
                let _: ::core::cmp::AssertParamIsEq<i128>;
            }
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for DatabaseTag {
            #[inline]
            fn partial_cmp(
                &self,
                other: &DatabaseTag,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                match ::core::cmp::PartialOrd::partial_cmp(&self.id, &other.id) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        match ::core::cmp::PartialOrd::partial_cmp(
                            &self.name,
                            &other.name,
                        ) {
                            ::core::option::Option::Some(
                                ::core::cmp::Ordering::Equal,
                            ) => {
                                match ::core::cmp::PartialOrd::partial_cmp(
                                    &self.category,
                                    &other.category,
                                ) {
                                    ::core::option::Option::Some(
                                        ::core::cmp::Ordering::Equal,
                                    ) => {
                                        match ::core::cmp::PartialOrd::partial_cmp(
                                            &self.order,
                                            &other.order,
                                        ) {
                                            ::core::option::Option::Some(
                                                ::core::cmp::Ordering::Equal,
                                            ) => {
                                                match ::core::cmp::PartialOrd::partial_cmp(
                                                    &self.notes,
                                                    &other.notes,
                                                ) {
                                                    ::core::option::Option::Some(
                                                        ::core::cmp::Ordering::Equal,
                                                    ) => {
                                                        match ::core::cmp::PartialOrd::partial_cmp(
                                                            &self.score,
                                                            &other.score,
                                                        ) {
                                                            ::core::option::Option::Some(
                                                                ::core::cmp::Ordering::Equal,
                                                            ) => {
                                                                ::core::cmp::PartialOrd::partial_cmp(
                                                                    &self.dictionary,
                                                                    &other.dictionary,
                                                                )
                                                            }
                                                            cmp => cmp,
                                                        }
                                                    }
                                                    cmp => cmp,
                                                }
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for DatabaseTag {
            #[inline]
            fn cmp(&self, other: &DatabaseTag) -> ::core::cmp::Ordering {
                match ::core::cmp::Ord::cmp(&self.id, &other.id) {
                    ::core::cmp::Ordering::Equal => {
                        match ::core::cmp::Ord::cmp(&self.name, &other.name) {
                            ::core::cmp::Ordering::Equal => {
                                match ::core::cmp::Ord::cmp(
                                    &self.category,
                                    &other.category,
                                ) {
                                    ::core::cmp::Ordering::Equal => {
                                        match ::core::cmp::Ord::cmp(&self.order, &other.order) {
                                            ::core::cmp::Ordering::Equal => {
                                                match ::core::cmp::Ord::cmp(&self.notes, &other.notes) {
                                                    ::core::cmp::Ordering::Equal => {
                                                        match ::core::cmp::Ord::cmp(&self.score, &other.score) {
                                                            ::core::cmp::Ordering::Equal => {
                                                                ::core::cmp::Ord::cmp(&self.dictionary, &other.dictionary)
                                                            }
                                                            cmp => cmp,
                                                        }
                                                    }
                                                    cmp => cmp,
                                                }
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for DatabaseTag {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.id, state);
                ::core::hash::Hash::hash(&self.name, state);
                ::core::hash::Hash::hash(&self.category, state);
                ::core::hash::Hash::hash(&self.order, state);
                ::core::hash::Hash::hash(&self.notes, state);
                ::core::hash::Hash::hash(&self.score, state);
                ::core::hash::Hash::hash(&self.dictionary, state)
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for DatabaseTag {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "DatabaseTag",
                        false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "id",
                        &self.id,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "category",
                        &self.category,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "order",
                        &self.order,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "notes",
                        &self.notes,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "score",
                        &self.score,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "dictionary",
                        &self.dictionary,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DatabaseTag {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __field6,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                6u64 => _serde::__private::Ok(__Field::__field6),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "id" => _serde::__private::Ok(__Field::__field0),
                                "name" => _serde::__private::Ok(__Field::__field1),
                                "category" => _serde::__private::Ok(__Field::__field2),
                                "order" => _serde::__private::Ok(__Field::__field3),
                                "notes" => _serde::__private::Ok(__Field::__field4),
                                "score" => _serde::__private::Ok(__Field::__field5),
                                "dictionary" => _serde::__private::Ok(__Field::__field6),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"id" => _serde::__private::Ok(__Field::__field0),
                                b"name" => _serde::__private::Ok(__Field::__field1),
                                b"category" => _serde::__private::Ok(__Field::__field2),
                                b"order" => _serde::__private::Ok(__Field::__field3),
                                b"notes" => _serde::__private::Ok(__Field::__field4),
                                b"score" => _serde::__private::Ok(__Field::__field5),
                                b"dictionary" => _serde::__private::Ok(__Field::__field6),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DatabaseTag>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DatabaseTag;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DatabaseTag",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DatabaseTag with 7 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct DatabaseTag with 7 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct DatabaseTag with 7 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match _serde::de::SeqAccess::next_element::<
                                u64,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct DatabaseTag with 7 elements",
                                        ),
                                    );
                                }
                            };
                            let __field4 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            4usize,
                                            &"struct DatabaseTag with 7 elements",
                                        ),
                                    );
                                }
                            };
                            let __field5 = match _serde::de::SeqAccess::next_element::<
                                i128,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            5usize,
                                            &"struct DatabaseTag with 7 elements",
                                        ),
                                    );
                                }
                            };
                            let __field6 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            6usize,
                                            &"struct DatabaseTag with 7 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DatabaseTag {
                                id: __field0,
                                name: __field1,
                                category: __field2,
                                order: __field3,
                                notes: __field4,
                                score: __field5,
                                dictionary: __field6,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<u64> = _serde::__private::None;
                            let mut __field4: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field5: _serde::__private::Option<i128> = _serde::__private::None;
                            let mut __field6: _serde::__private::Option<String> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "category",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("order"),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field4 => {
                                        if _serde::__private::Option::is_some(&__field4) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("notes"),
                                            );
                                        }
                                        __field4 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field5 => {
                                        if _serde::__private::Option::is_some(&__field5) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("score"),
                                            );
                                        }
                                        __field5 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<i128>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field6 => {
                                        if _serde::__private::Option::is_some(&__field6) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "dictionary",
                                                ),
                                            );
                                        }
                                        __field6 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("id")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("name")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("category")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("order")?
                                }
                            };
                            let __field4 = match __field4 {
                                _serde::__private::Some(__field4) => __field4,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("notes")?
                                }
                            };
                            let __field5 = match __field5 {
                                _serde::__private::Some(__field5) => __field5,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("score")?
                                }
                            };
                            let __field6 = match __field6 {
                                _serde::__private::Some(__field6) => __field6,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("dictionary")?
                                }
                            };
                            _serde::__private::Ok(DatabaseTag {
                                id: __field0,
                                name: __field1,
                                category: __field2,
                                order: __field3,
                                notes: __field4,
                                score: __field5,
                                dictionary: __field6,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "id",
                        "name",
                        "category",
                        "order",
                        "notes",
                        "score",
                        "dictionary",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DatabaseTag",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DatabaseTag>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        pub trait DBMetaType {
            fn mode(&self) -> &TermMetaModeType;
            fn expression(&self) -> &str;
        }
        pub enum DatabaseMetaMatchType {
            Frequency(DatabaseMetaFrequency),
            Pitch(DatabaseMetaPitch),
            Phonetic(DatabaseMetaPhonetic),
        }
        #[automatically_derived]
        impl ::core::clone::Clone for DatabaseMetaMatchType {
            #[inline]
            fn clone(&self) -> DatabaseMetaMatchType {
                match self {
                    DatabaseMetaMatchType::Frequency(__self_0) => {
                        DatabaseMetaMatchType::Frequency(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    DatabaseMetaMatchType::Pitch(__self_0) => {
                        DatabaseMetaMatchType::Pitch(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    DatabaseMetaMatchType::Phonetic(__self_0) => {
                        DatabaseMetaMatchType::Phonetic(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for DatabaseMetaMatchType {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    DatabaseMetaMatchType::Frequency(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Frequency",
                            &__self_0,
                        )
                    }
                    DatabaseMetaMatchType::Pitch(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Pitch",
                            &__self_0,
                        )
                    }
                    DatabaseMetaMatchType::Phonetic(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Phonetic",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for DatabaseMetaMatchType {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for DatabaseMetaMatchType {
            #[inline]
            fn eq(&self, other: &DatabaseMetaMatchType) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
                    && match (self, other) {
                        (
                            DatabaseMetaMatchType::Frequency(__self_0),
                            DatabaseMetaMatchType::Frequency(__arg1_0),
                        ) => __self_0 == __arg1_0,
                        (
                            DatabaseMetaMatchType::Pitch(__self_0),
                            DatabaseMetaMatchType::Pitch(__arg1_0),
                        ) => __self_0 == __arg1_0,
                        (
                            DatabaseMetaMatchType::Phonetic(__self_0),
                            DatabaseMetaMatchType::Phonetic(__arg1_0),
                        ) => __self_0 == __arg1_0,
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for DatabaseMetaMatchType {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        DatabaseMetaMatchType::Frequency(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "DatabaseMetaMatchType",
                                0u32,
                                "Frequency",
                                __field0,
                            )
                        }
                        DatabaseMetaMatchType::Pitch(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "DatabaseMetaMatchType",
                                1u32,
                                "Pitch",
                                __field0,
                            )
                        }
                        DatabaseMetaMatchType::Phonetic(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "DatabaseMetaMatchType",
                                2u32,
                                "Phonetic",
                                __field0,
                            )
                        }
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DatabaseMetaMatchType {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 3",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "Frequency" => _serde::__private::Ok(__Field::__field0),
                                "Pitch" => _serde::__private::Ok(__Field::__field1),
                                "Phonetic" => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"Frequency" => _serde::__private::Ok(__Field::__field0),
                                b"Pitch" => _serde::__private::Ok(__Field::__field1),
                                b"Phonetic" => _serde::__private::Ok(__Field::__field2),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DatabaseMetaMatchType>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DatabaseMetaMatchType;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum DatabaseMetaMatchType",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            DatabaseMetaFrequency,
                                        >(__variant),
                                        DatabaseMetaMatchType::Frequency,
                                    )
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            DatabaseMetaPitch,
                                        >(__variant),
                                        DatabaseMetaMatchType::Pitch,
                                    )
                                }
                                (__Field::__field2, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            DatabaseMetaPhonetic,
                                        >(__variant),
                                        DatabaseMetaMatchType::Phonetic,
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &[
                        "Frequency",
                        "Pitch",
                        "Phonetic",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "DatabaseMetaMatchType",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                DatabaseMetaMatchType,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        impl DatabaseMetaMatchType {
            pub fn convert_kanji_meta_file(
                outpath: PathBuf,
                dict_name: String,
            ) -> Result<Vec<DatabaseMetaFrequency>, DictionaryFileError> {
                let file = fs::File::open(&outpath)
                    .map_err(|reason| DictionaryFileError::FailedOpen {
                        outpath: outpath.clone(),
                        reason: reason.to_string(),
                    })?;
                let reader = BufReader::new(file);
                let mut stream = JsonDeserializer::from_reader(reader)
                    .into_iter::<Vec<DatabaseMetaFrequency>>();
                let mut entries = match stream.next() {
                    Some(Ok(entries)) => entries,
                    Some(Err(reason)) => {
                        return Err(crate::errors::DictionaryFileError::File {
                            outpath,
                            reason: reason.to_string(),
                        });
                    }
                    None => return Err(DictionaryFileError::Empty(outpath)),
                };
                entries
                    .iter_mut()
                    .for_each(|entry| {
                        entry.id = Uuid::now_v7().to_string();
                        entry.dictionary = dict_name.clone();
                    });
                Ok(entries)
            }
            pub fn convert_term_meta_file(
                outpath: PathBuf,
                dict_name: String,
            ) -> Result<Vec<DatabaseMetaMatchType>, DictionaryFileError> {
                let file = fs::File::open(&outpath)
                    .map_err(|reason| DictionaryFileError::FailedOpen {
                        outpath: outpath.clone(),
                        reason: reason.to_string(),
                    })?;
                let reader = BufReader::new(file);
                let mut stream = JsonDeserializer::from_reader(reader)
                    .into_iter::<Vec<TermMeta>>();
                let mut entries = match stream.next() {
                    Some(Ok(entries)) => entries,
                    Some(Err(reason)) => {
                        return Err(crate::errors::DictionaryFileError::File {
                            outpath,
                            reason: reason.to_string(),
                        });
                    }
                    None => return Err(DictionaryFileError::Empty(outpath)),
                };
                let term_metas: Vec<DatabaseMetaMatchType> = entries
                    .into_iter()
                    .map(|entry| {
                        let id = Uuid::now_v7().to_string();
                        let TermMeta { expression, mode, data } = entry;
                        match data {
                            MetaDataMatchType::Frequency(data) => {
                                DatabaseMetaMatchType::Frequency(DatabaseMetaFrequency {
                                    id,
                                    freq_expression: expression,
                                    mode: TermMetaModeType::Freq,
                                    data,
                                    dictionary: dict_name.clone(),
                                })
                            }
                            MetaDataMatchType::Pitch(data) => {
                                DatabaseMetaMatchType::Pitch(DatabaseMetaPitch {
                                    id,
                                    pitch_expression: expression,
                                    mode: TermMetaModeType::Pitch,
                                    data,
                                    dictionary: dict_name.clone(),
                                })
                            }
                            MetaDataMatchType::Phonetic(data) => {
                                DatabaseMetaMatchType::Phonetic(DatabaseMetaPhonetic {
                                    id,
                                    phonetic_expression: expression,
                                    mode: TermMetaModeType::Ipa,
                                    data,
                                    dictionary: dict_name.clone(),
                                })
                            }
                        }
                    })
                    .collect();
                Ok(term_metas)
            }
        }
        /// Used to store the frequency metadata of a term in the db.
        pub struct DatabaseMetaFrequency {
            #[primary_key]
            pub id: String,
            #[secondary_key]
            pub freq_expression: String,
            /// Is of type [`TermMetaModeType::Freq`]
            pub mode: TermMetaModeType,
            pub data: TermMetaFreqDataMatchType,
            pub dictionary: String,
        }
        impl native_db::db_type::ToInput for DatabaseMetaFrequency {
            fn native_db_bincode_encode_to_vec(
                &self,
            ) -> native_db::db_type::Result<Vec<u8>> {
                native_db::bincode_encode_to_vec(self)
            }
            fn native_db_bincode_decode_from_slice(
                slice: &[u8],
            ) -> native_db::db_type::Result<Self> {
                Ok(native_db::bincode_decode_from_slice(slice)?.0)
            }
            fn native_db_model() -> native_db::Model {
                let mut secondary_tables_name = std::collections::HashSet::new();
                secondary_tables_name
                    .insert(
                        native_db::db_type::KeyDefinition::new(
                            DatabaseMetaFrequency::native_model_id(),
                            DatabaseMetaFrequency::native_model_version(),
                            "freq_expression",
                            <String>::key_names(),
                            native_db::db_type::KeyOptions {
                                unique: false,
                                optional: false,
                            },
                        ),
                    );
                native_db::Model {
                    primary_key: native_db::db_type::KeyDefinition::new(
                        DatabaseMetaFrequency::native_model_id(),
                        DatabaseMetaFrequency::native_model_version(),
                        "id",
                        <String>::key_names(),
                        (),
                    ),
                    secondary_keys: secondary_tables_name,
                }
            }
            fn native_db_primary_key(&self) -> native_db::db_type::Key {
                (&self.id).to_key()
            }
            fn native_db_secondary_keys(
                &self,
            ) -> std::collections::HashMap<
                native_db::db_type::KeyDefinition<native_db::db_type::KeyOptions>,
                native_db::db_type::KeyEntry,
            > {
                let mut secondary_tables_name = std::collections::HashMap::new();
                let value: native_db::db_type::Key = (&self.freq_expression).to_key();
                let value = native_db::db_type::KeyEntry::Default(value);
                secondary_tables_name
                    .insert(
                        native_db::db_type::KeyDefinition::new(
                            DatabaseMetaFrequency::native_model_id(),
                            DatabaseMetaFrequency::native_model_version(),
                            "freq_expression",
                            <String>::key_names(),
                            native_db::db_type::KeyOptions {
                                unique: false,
                                optional: false,
                            },
                        ),
                        value,
                    );
                secondary_tables_name
            }
        }
        #[allow(non_camel_case_types)]
        pub(crate) enum DatabaseMetaFrequencyKey {
            #[allow(non_camel_case_types, dead_code)]
            freq_expression,
        }
        impl native_db::db_type::ToKeyDefinition<native_db::db_type::KeyOptions>
        for DatabaseMetaFrequencyKey {
            fn key_definition(
                &self,
            ) -> native_db::db_type::KeyDefinition<native_db::db_type::KeyOptions> {
                match self {
                    DatabaseMetaFrequencyKey::freq_expression => {
                        native_db::db_type::KeyDefinition::new(
                            DatabaseMetaFrequency::native_model_id(),
                            DatabaseMetaFrequency::native_model_version(),
                            "freq_expression",
                            <String>::key_names(),
                            native_db::db_type::KeyOptions {
                                unique: false,
                                optional: false,
                            },
                        )
                    }
                    _ => {
                        ::std::rt::begin_panic("Unknown key");
                    }
                }
            }
        }
        impl native_model::Model for DatabaseMetaFrequency {
            fn native_model_id() -> u32 {
                3
            }
            fn native_model_id_str() -> &'static str {
                "3"
            }
            fn native_model_version() -> u32 {
                1
            }
            fn native_model_version_str() -> &'static str {
                "1"
            }
            fn native_model_encode_body(
                &self,
            ) -> std::result::Result<Vec<u8>, native_model::EncodeBodyError> {
                use native_model::Encode;
                native_model::rmp_serde_1_3::RmpSerde::encode(self)
                    .map_err(|e| native_model::EncodeBodyError {
                        msg: ::alloc::__export::must_use({
                            let res = ::alloc::fmt::format(format_args!("{0}", e));
                            res
                        }),
                        source: e.into(),
                    })
            }
            fn native_model_encode_downgrade_body(
                self,
                version: u32,
            ) -> native_model::Result<Vec<u8>> {
                if version == Self::native_model_version() {
                    let result = self.native_model_encode_body()?;
                    Ok(result)
                } else if version < Self::native_model_version() {
                    Err(native_model::Error::DowngradeNotSupported {
                        from: version,
                        to: Self::native_model_version(),
                    })
                } else {
                    Err(native_model::Error::DowngradeNotSupported {
                        from: version,
                        to: Self::native_model_version(),
                    })
                }
            }
            fn native_model_decode_body(
                data: Vec<u8>,
                id: u32,
            ) -> std::result::Result<Self, native_model::DecodeBodyError> {
                if id != 3 {
                    return Err(native_model::DecodeBodyError::MismatchedModelId);
                }
                use native_model::Decode;
                native_model::rmp_serde_1_3::RmpSerde::decode(data)
                    .map_err(|e| native_model::DecodeBodyError::DecodeError {
                        msg: ::alloc::__export::must_use({
                            let res = ::alloc::fmt::format(format_args!("{0}", e));
                            res
                        }),
                        source: e.into(),
                    })
            }
            fn native_model_decode_upgrade_body(
                data: Vec<u8>,
                id: u32,
                version: u32,
            ) -> native_model::Result<Self> {
                if version == Self::native_model_version() {
                    let result = Self::native_model_decode_body(data, id)?;
                    Ok(result)
                } else if version < Self::native_model_version() {
                    Err(native_model::Error::UpgradeNotSupported {
                        from: version,
                        to: Self::native_model_version(),
                    })
                } else {
                    Err(native_model::Error::UpgradeNotSupported {
                        from: version,
                        to: Self::native_model_version(),
                    })
                }
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for DatabaseMetaFrequency {
            #[inline]
            fn clone(&self) -> DatabaseMetaFrequency {
                DatabaseMetaFrequency {
                    id: ::core::clone::Clone::clone(&self.id),
                    freq_expression: ::core::clone::Clone::clone(&self.freq_expression),
                    mode: ::core::clone::Clone::clone(&self.mode),
                    data: ::core::clone::Clone::clone(&self.data),
                    dictionary: ::core::clone::Clone::clone(&self.dictionary),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for DatabaseMetaFrequency {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field5_finish(
                    f,
                    "DatabaseMetaFrequency",
                    "id",
                    &self.id,
                    "freq_expression",
                    &self.freq_expression,
                    "mode",
                    &self.mode,
                    "data",
                    &self.data,
                    "dictionary",
                    &&self.dictionary,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for DatabaseMetaFrequency {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for DatabaseMetaFrequency {
            #[inline]
            fn eq(&self, other: &DatabaseMetaFrequency) -> bool {
                self.id == other.id && self.freq_expression == other.freq_expression
                    && self.mode == other.mode && self.data == other.data
                    && self.dictionary == other.dictionary
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for DatabaseMetaFrequency {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "DatabaseMetaFrequency",
                        false as usize + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "id",
                        &self.id,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "freq_expression",
                        &self.freq_expression,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "mode",
                        &self.mode,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "data",
                        &self.data,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "dictionary",
                        &self.dictionary,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DatabaseMetaFrequency {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "id" => _serde::__private::Ok(__Field::__field0),
                                "freq_expression" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                "mode" => _serde::__private::Ok(__Field::__field2),
                                "data" => _serde::__private::Ok(__Field::__field3),
                                "dictionary" => _serde::__private::Ok(__Field::__field4),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"id" => _serde::__private::Ok(__Field::__field0),
                                b"freq_expression" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                b"mode" => _serde::__private::Ok(__Field::__field2),
                                b"data" => _serde::__private::Ok(__Field::__field3),
                                b"dictionary" => _serde::__private::Ok(__Field::__field4),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DatabaseMetaFrequency>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DatabaseMetaFrequency;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DatabaseMetaFrequency",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DatabaseMetaFrequency with 5 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct DatabaseMetaFrequency with 5 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                TermMetaModeType,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct DatabaseMetaFrequency with 5 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match _serde::de::SeqAccess::next_element::<
                                TermMetaFreqDataMatchType,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct DatabaseMetaFrequency with 5 elements",
                                        ),
                                    );
                                }
                            };
                            let __field4 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            4usize,
                                            &"struct DatabaseMetaFrequency with 5 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DatabaseMetaFrequency {
                                id: __field0,
                                freq_expression: __field1,
                                mode: __field2,
                                data: __field3,
                                dictionary: __field4,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<
                                TermMetaModeType,
                            > = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<
                                TermMetaFreqDataMatchType,
                            > = _serde::__private::None;
                            let mut __field4: _serde::__private::Option<String> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "freq_expression",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("mode"),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                TermMetaModeType,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("data"),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                TermMetaFreqDataMatchType,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field4 => {
                                        if _serde::__private::Option::is_some(&__field4) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "dictionary",
                                                ),
                                            );
                                        }
                                        __field4 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("id")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("freq_expression")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("mode")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("data")?
                                }
                            };
                            let __field4 = match __field4 {
                                _serde::__private::Some(__field4) => __field4,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("dictionary")?
                                }
                            };
                            _serde::__private::Ok(DatabaseMetaFrequency {
                                id: __field0,
                                freq_expression: __field1,
                                mode: __field2,
                                data: __field3,
                                dictionary: __field4,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "id",
                        "freq_expression",
                        "mode",
                        "data",
                        "dictionary",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DatabaseMetaFrequency",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                DatabaseMetaFrequency,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        impl DBMetaType for DatabaseMetaFrequency {
            fn mode(&self) -> &TermMetaModeType {
                &self.mode
            }
            fn expression(&self) -> &str {
                &self.freq_expression
            }
        }
        /// Used to store the pitch metadata of a term in the db.
        pub struct DatabaseMetaPitch {
            #[primary_key]
            pub id: String,
            #[secondary_key]
            pub pitch_expression: String,
            /// Is of type [`TermMetaModeType::Pitch`]
            pub mode: TermMetaModeType,
            pub data: TermMetaPitchData,
            pub dictionary: String,
        }
        impl native_db::db_type::ToInput for DatabaseMetaPitch {
            fn native_db_bincode_encode_to_vec(
                &self,
            ) -> native_db::db_type::Result<Vec<u8>> {
                native_db::bincode_encode_to_vec(self)
            }
            fn native_db_bincode_decode_from_slice(
                slice: &[u8],
            ) -> native_db::db_type::Result<Self> {
                Ok(native_db::bincode_decode_from_slice(slice)?.0)
            }
            fn native_db_model() -> native_db::Model {
                let mut secondary_tables_name = std::collections::HashSet::new();
                secondary_tables_name
                    .insert(
                        native_db::db_type::KeyDefinition::new(
                            DatabaseMetaPitch::native_model_id(),
                            DatabaseMetaPitch::native_model_version(),
                            "pitch_expression",
                            <String>::key_names(),
                            native_db::db_type::KeyOptions {
                                unique: false,
                                optional: false,
                            },
                        ),
                    );
                native_db::Model {
                    primary_key: native_db::db_type::KeyDefinition::new(
                        DatabaseMetaPitch::native_model_id(),
                        DatabaseMetaPitch::native_model_version(),
                        "id",
                        <String>::key_names(),
                        (),
                    ),
                    secondary_keys: secondary_tables_name,
                }
            }
            fn native_db_primary_key(&self) -> native_db::db_type::Key {
                (&self.id).to_key()
            }
            fn native_db_secondary_keys(
                &self,
            ) -> std::collections::HashMap<
                native_db::db_type::KeyDefinition<native_db::db_type::KeyOptions>,
                native_db::db_type::KeyEntry,
            > {
                let mut secondary_tables_name = std::collections::HashMap::new();
                let value: native_db::db_type::Key = (&self.pitch_expression).to_key();
                let value = native_db::db_type::KeyEntry::Default(value);
                secondary_tables_name
                    .insert(
                        native_db::db_type::KeyDefinition::new(
                            DatabaseMetaPitch::native_model_id(),
                            DatabaseMetaPitch::native_model_version(),
                            "pitch_expression",
                            <String>::key_names(),
                            native_db::db_type::KeyOptions {
                                unique: false,
                                optional: false,
                            },
                        ),
                        value,
                    );
                secondary_tables_name
            }
        }
        #[allow(non_camel_case_types)]
        pub(crate) enum DatabaseMetaPitchKey {
            #[allow(non_camel_case_types, dead_code)]
            pitch_expression,
        }
        impl native_db::db_type::ToKeyDefinition<native_db::db_type::KeyOptions>
        for DatabaseMetaPitchKey {
            fn key_definition(
                &self,
            ) -> native_db::db_type::KeyDefinition<native_db::db_type::KeyOptions> {
                match self {
                    DatabaseMetaPitchKey::pitch_expression => {
                        native_db::db_type::KeyDefinition::new(
                            DatabaseMetaPitch::native_model_id(),
                            DatabaseMetaPitch::native_model_version(),
                            "pitch_expression",
                            <String>::key_names(),
                            native_db::db_type::KeyOptions {
                                unique: false,
                                optional: false,
                            },
                        )
                    }
                    _ => {
                        ::std::rt::begin_panic("Unknown key");
                    }
                }
            }
        }
        impl native_model::Model for DatabaseMetaPitch {
            fn native_model_id() -> u32 {
                4
            }
            fn native_model_id_str() -> &'static str {
                "4"
            }
            fn native_model_version() -> u32 {
                1
            }
            fn native_model_version_str() -> &'static str {
                "1"
            }
            fn native_model_encode_body(
                &self,
            ) -> std::result::Result<Vec<u8>, native_model::EncodeBodyError> {
                use native_model::Encode;
                native_model::bincode_1_3::Bincode::encode(self)
                    .map_err(|e| native_model::EncodeBodyError {
                        msg: ::alloc::__export::must_use({
                            let res = ::alloc::fmt::format(format_args!("{0}", e));
                            res
                        }),
                        source: e.into(),
                    })
            }
            fn native_model_encode_downgrade_body(
                self,
                version: u32,
            ) -> native_model::Result<Vec<u8>> {
                if version == Self::native_model_version() {
                    let result = self.native_model_encode_body()?;
                    Ok(result)
                } else if version < Self::native_model_version() {
                    Err(native_model::Error::DowngradeNotSupported {
                        from: version,
                        to: Self::native_model_version(),
                    })
                } else {
                    Err(native_model::Error::DowngradeNotSupported {
                        from: version,
                        to: Self::native_model_version(),
                    })
                }
            }
            fn native_model_decode_body(
                data: Vec<u8>,
                id: u32,
            ) -> std::result::Result<Self, native_model::DecodeBodyError> {
                if id != 4 {
                    return Err(native_model::DecodeBodyError::MismatchedModelId);
                }
                use native_model::Decode;
                native_model::bincode_1_3::Bincode::decode(data)
                    .map_err(|e| native_model::DecodeBodyError::DecodeError {
                        msg: ::alloc::__export::must_use({
                            let res = ::alloc::fmt::format(format_args!("{0}", e));
                            res
                        }),
                        source: e.into(),
                    })
            }
            fn native_model_decode_upgrade_body(
                data: Vec<u8>,
                id: u32,
                version: u32,
            ) -> native_model::Result<Self> {
                if version == Self::native_model_version() {
                    let result = Self::native_model_decode_body(data, id)?;
                    Ok(result)
                } else if version < Self::native_model_version() {
                    Err(native_model::Error::UpgradeNotSupported {
                        from: version,
                        to: Self::native_model_version(),
                    })
                } else {
                    Err(native_model::Error::UpgradeNotSupported {
                        from: version,
                        to: Self::native_model_version(),
                    })
                }
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for DatabaseMetaPitch {
            #[inline]
            fn clone(&self) -> DatabaseMetaPitch {
                DatabaseMetaPitch {
                    id: ::core::clone::Clone::clone(&self.id),
                    pitch_expression: ::core::clone::Clone::clone(
                        &self.pitch_expression,
                    ),
                    mode: ::core::clone::Clone::clone(&self.mode),
                    data: ::core::clone::Clone::clone(&self.data),
                    dictionary: ::core::clone::Clone::clone(&self.dictionary),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for DatabaseMetaPitch {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field5_finish(
                    f,
                    "DatabaseMetaPitch",
                    "id",
                    &self.id,
                    "pitch_expression",
                    &self.pitch_expression,
                    "mode",
                    &self.mode,
                    "data",
                    &self.data,
                    "dictionary",
                    &&self.dictionary,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for DatabaseMetaPitch {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for DatabaseMetaPitch {
            #[inline]
            fn eq(&self, other: &DatabaseMetaPitch) -> bool {
                self.id == other.id && self.pitch_expression == other.pitch_expression
                    && self.mode == other.mode && self.data == other.data
                    && self.dictionary == other.dictionary
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for DatabaseMetaPitch {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "DatabaseMetaPitch",
                        false as usize + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "id",
                        &self.id,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "pitch_expression",
                        &self.pitch_expression,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "mode",
                        &self.mode,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "data",
                        &self.data,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "dictionary",
                        &self.dictionary,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DatabaseMetaPitch {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "id" => _serde::__private::Ok(__Field::__field0),
                                "pitch_expression" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                "mode" => _serde::__private::Ok(__Field::__field2),
                                "data" => _serde::__private::Ok(__Field::__field3),
                                "dictionary" => _serde::__private::Ok(__Field::__field4),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"id" => _serde::__private::Ok(__Field::__field0),
                                b"pitch_expression" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                b"mode" => _serde::__private::Ok(__Field::__field2),
                                b"data" => _serde::__private::Ok(__Field::__field3),
                                b"dictionary" => _serde::__private::Ok(__Field::__field4),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DatabaseMetaPitch>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DatabaseMetaPitch;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DatabaseMetaPitch",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DatabaseMetaPitch with 5 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct DatabaseMetaPitch with 5 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                TermMetaModeType,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct DatabaseMetaPitch with 5 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match _serde::de::SeqAccess::next_element::<
                                TermMetaPitchData,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct DatabaseMetaPitch with 5 elements",
                                        ),
                                    );
                                }
                            };
                            let __field4 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            4usize,
                                            &"struct DatabaseMetaPitch with 5 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DatabaseMetaPitch {
                                id: __field0,
                                pitch_expression: __field1,
                                mode: __field2,
                                data: __field3,
                                dictionary: __field4,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<
                                TermMetaModeType,
                            > = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<
                                TermMetaPitchData,
                            > = _serde::__private::None;
                            let mut __field4: _serde::__private::Option<String> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "pitch_expression",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("mode"),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                TermMetaModeType,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("data"),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                TermMetaPitchData,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field4 => {
                                        if _serde::__private::Option::is_some(&__field4) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "dictionary",
                                                ),
                                            );
                                        }
                                        __field4 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("id")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("pitch_expression")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("mode")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("data")?
                                }
                            };
                            let __field4 = match __field4 {
                                _serde::__private::Some(__field4) => __field4,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("dictionary")?
                                }
                            };
                            _serde::__private::Ok(DatabaseMetaPitch {
                                id: __field0,
                                pitch_expression: __field1,
                                mode: __field2,
                                data: __field3,
                                dictionary: __field4,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "id",
                        "pitch_expression",
                        "mode",
                        "data",
                        "dictionary",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DatabaseMetaPitch",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DatabaseMetaPitch>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        /// Pitch accent information for a term, represented as the position of the downstep.
        pub struct PitchAccent {
            /// Type of the pronunciation, for disambiguation between union type members.
            /// Should be `"pitch-accent"` in the json.
            pub term: TermPronunciationMatchType,
            /// Position of the downstep, as a number of mora.
            pub position: u8,
            /// Positions of morae with a nasal sound.
            pub nasal_positions: Vec<u8>,
            /// Positions of morae with a devoiced sound.
            pub devoice_positions: Vec<u8>,
            /// Tags for the pitch accent.
            pub tags: Vec<DictionaryTag>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for PitchAccent {
            #[inline]
            fn clone(&self) -> PitchAccent {
                PitchAccent {
                    term: ::core::clone::Clone::clone(&self.term),
                    position: ::core::clone::Clone::clone(&self.position),
                    nasal_positions: ::core::clone::Clone::clone(&self.nasal_positions),
                    devoice_positions: ::core::clone::Clone::clone(
                        &self.devoice_positions,
                    ),
                    tags: ::core::clone::Clone::clone(&self.tags),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for PitchAccent {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field5_finish(
                    f,
                    "PitchAccent",
                    "term",
                    &self.term,
                    "position",
                    &self.position,
                    "nasal_positions",
                    &self.nasal_positions,
                    "devoice_positions",
                    &self.devoice_positions,
                    "tags",
                    &&self.tags,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for PitchAccent {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for PitchAccent {
            #[inline]
            fn eq(&self, other: &PitchAccent) -> bool {
                self.term == other.term && self.position == other.position
                    && self.nasal_positions == other.nasal_positions
                    && self.devoice_positions == other.devoice_positions
                    && self.tags == other.tags
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for PitchAccent {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<TermPronunciationMatchType>;
                let _: ::core::cmp::AssertParamIsEq<u8>;
                let _: ::core::cmp::AssertParamIsEq<Vec<u8>>;
                let _: ::core::cmp::AssertParamIsEq<Vec<u8>>;
                let _: ::core::cmp::AssertParamIsEq<Vec<DictionaryTag>>;
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for PitchAccent {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.term, state);
                ::core::hash::Hash::hash(&self.position, state);
                ::core::hash::Hash::hash(&self.nasal_positions, state);
                ::core::hash::Hash::hash(&self.devoice_positions, state);
                ::core::hash::Hash::hash(&self.tags, state)
            }
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for PitchAccent {
            #[inline]
            fn partial_cmp(
                &self,
                other: &PitchAccent,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                match ::core::cmp::PartialOrd::partial_cmp(&self.term, &other.term) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        match ::core::cmp::PartialOrd::partial_cmp(
                            &self.position,
                            &other.position,
                        ) {
                            ::core::option::Option::Some(
                                ::core::cmp::Ordering::Equal,
                            ) => {
                                match ::core::cmp::PartialOrd::partial_cmp(
                                    &self.nasal_positions,
                                    &other.nasal_positions,
                                ) {
                                    ::core::option::Option::Some(
                                        ::core::cmp::Ordering::Equal,
                                    ) => {
                                        match ::core::cmp::PartialOrd::partial_cmp(
                                            &self.devoice_positions,
                                            &other.devoice_positions,
                                        ) {
                                            ::core::option::Option::Some(
                                                ::core::cmp::Ordering::Equal,
                                            ) => {
                                                ::core::cmp::PartialOrd::partial_cmp(
                                                    &self.tags,
                                                    &other.tags,
                                                )
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for PitchAccent {
            #[inline]
            fn cmp(&self, other: &PitchAccent) -> ::core::cmp::Ordering {
                match ::core::cmp::Ord::cmp(&self.term, &other.term) {
                    ::core::cmp::Ordering::Equal => {
                        match ::core::cmp::Ord::cmp(&self.position, &other.position) {
                            ::core::cmp::Ordering::Equal => {
                                match ::core::cmp::Ord::cmp(
                                    &self.nasal_positions,
                                    &other.nasal_positions,
                                ) {
                                    ::core::cmp::Ordering::Equal => {
                                        match ::core::cmp::Ord::cmp(
                                            &self.devoice_positions,
                                            &other.devoice_positions,
                                        ) {
                                            ::core::cmp::Ordering::Equal => {
                                                ::core::cmp::Ord::cmp(&self.tags, &other.tags)
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for PitchAccent {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "PitchAccent",
                        false as usize + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "term",
                        &self.term,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "position",
                        &self.position,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "nasal_positions",
                        &self.nasal_positions,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "devoice_positions",
                        &self.devoice_positions,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "tags",
                        &self.tags,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for PitchAccent {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "term" => _serde::__private::Ok(__Field::__field0),
                                "position" => _serde::__private::Ok(__Field::__field1),
                                "nasal_positions" => {
                                    _serde::__private::Ok(__Field::__field2)
                                }
                                "devoice_positions" => {
                                    _serde::__private::Ok(__Field::__field3)
                                }
                                "tags" => _serde::__private::Ok(__Field::__field4),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"term" => _serde::__private::Ok(__Field::__field0),
                                b"position" => _serde::__private::Ok(__Field::__field1),
                                b"nasal_positions" => {
                                    _serde::__private::Ok(__Field::__field2)
                                }
                                b"devoice_positions" => {
                                    _serde::__private::Ok(__Field::__field3)
                                }
                                b"tags" => _serde::__private::Ok(__Field::__field4),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<PitchAccent>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = PitchAccent;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct PitchAccent",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                TermPronunciationMatchType,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct PitchAccent with 5 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                u8,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct PitchAccent with 5 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                Vec<u8>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct PitchAccent with 5 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match _serde::de::SeqAccess::next_element::<
                                Vec<u8>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct PitchAccent with 5 elements",
                                        ),
                                    );
                                }
                            };
                            let __field4 = match _serde::de::SeqAccess::next_element::<
                                Vec<DictionaryTag>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            4usize,
                                            &"struct PitchAccent with 5 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(PitchAccent {
                                term: __field0,
                                position: __field1,
                                nasal_positions: __field2,
                                devoice_positions: __field3,
                                tags: __field4,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                TermPronunciationMatchType,
                            > = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<u8> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<Vec<u8>> = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<Vec<u8>> = _serde::__private::None;
                            let mut __field4: _serde::__private::Option<
                                Vec<DictionaryTag>,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("term"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                TermPronunciationMatchType,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "position",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<u8>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "nasal_positions",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Vec<u8>>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "devoice_positions",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Vec<u8>>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field4 => {
                                        if _serde::__private::Option::is_some(&__field4) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("tags"),
                                            );
                                        }
                                        __field4 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Vec<DictionaryTag>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("term")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("position")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("nasal_positions")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("devoice_positions")?
                                }
                            };
                            let __field4 = match __field4 {
                                _serde::__private::Some(__field4) => __field4,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("tags")?
                                }
                            };
                            _serde::__private::Ok(PitchAccent {
                                term: __field0,
                                position: __field1,
                                nasal_positions: __field2,
                                devoice_positions: __field3,
                                tags: __field4,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "term",
                        "position",
                        "nasal_positions",
                        "devoice_positions",
                        "tags",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "PitchAccent",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<PitchAccent>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        impl DBMetaType for DatabaseMetaPitch {
            fn mode(&self) -> &TermMetaModeType {
                &self.mode
            }
            fn expression(&self) -> &str {
                &self.pitch_expression
            }
        }
        /// Used to store the phonetic metadata of a term in the db.
        pub struct DatabaseMetaPhonetic {
            #[primary_key]
            pub id: String,
            #[secondary_key]
            pub phonetic_expression: String,
            /// Is of type [`TermMetaModeType::Ipa`]
            pub mode: TermMetaModeType,
            pub data: TermMetaPhoneticData,
            pub dictionary: String,
        }
        impl native_db::db_type::ToInput for DatabaseMetaPhonetic {
            fn native_db_bincode_encode_to_vec(
                &self,
            ) -> native_db::db_type::Result<Vec<u8>> {
                native_db::bincode_encode_to_vec(self)
            }
            fn native_db_bincode_decode_from_slice(
                slice: &[u8],
            ) -> native_db::db_type::Result<Self> {
                Ok(native_db::bincode_decode_from_slice(slice)?.0)
            }
            fn native_db_model() -> native_db::Model {
                let mut secondary_tables_name = std::collections::HashSet::new();
                secondary_tables_name
                    .insert(
                        native_db::db_type::KeyDefinition::new(
                            DatabaseMetaPhonetic::native_model_id(),
                            DatabaseMetaPhonetic::native_model_version(),
                            "phonetic_expression",
                            <String>::key_names(),
                            native_db::db_type::KeyOptions {
                                unique: false,
                                optional: false,
                            },
                        ),
                    );
                native_db::Model {
                    primary_key: native_db::db_type::KeyDefinition::new(
                        DatabaseMetaPhonetic::native_model_id(),
                        DatabaseMetaPhonetic::native_model_version(),
                        "id",
                        <String>::key_names(),
                        (),
                    ),
                    secondary_keys: secondary_tables_name,
                }
            }
            fn native_db_primary_key(&self) -> native_db::db_type::Key {
                (&self.id).to_key()
            }
            fn native_db_secondary_keys(
                &self,
            ) -> std::collections::HashMap<
                native_db::db_type::KeyDefinition<native_db::db_type::KeyOptions>,
                native_db::db_type::KeyEntry,
            > {
                let mut secondary_tables_name = std::collections::HashMap::new();
                let value: native_db::db_type::Key = (&self.phonetic_expression)
                    .to_key();
                let value = native_db::db_type::KeyEntry::Default(value);
                secondary_tables_name
                    .insert(
                        native_db::db_type::KeyDefinition::new(
                            DatabaseMetaPhonetic::native_model_id(),
                            DatabaseMetaPhonetic::native_model_version(),
                            "phonetic_expression",
                            <String>::key_names(),
                            native_db::db_type::KeyOptions {
                                unique: false,
                                optional: false,
                            },
                        ),
                        value,
                    );
                secondary_tables_name
            }
        }
        #[allow(non_camel_case_types)]
        pub(crate) enum DatabaseMetaPhoneticKey {
            #[allow(non_camel_case_types, dead_code)]
            phonetic_expression,
        }
        impl native_db::db_type::ToKeyDefinition<native_db::db_type::KeyOptions>
        for DatabaseMetaPhoneticKey {
            fn key_definition(
                &self,
            ) -> native_db::db_type::KeyDefinition<native_db::db_type::KeyOptions> {
                match self {
                    DatabaseMetaPhoneticKey::phonetic_expression => {
                        native_db::db_type::KeyDefinition::new(
                            DatabaseMetaPhonetic::native_model_id(),
                            DatabaseMetaPhonetic::native_model_version(),
                            "phonetic_expression",
                            <String>::key_names(),
                            native_db::db_type::KeyOptions {
                                unique: false,
                                optional: false,
                            },
                        )
                    }
                    _ => {
                        ::std::rt::begin_panic("Unknown key");
                    }
                }
            }
        }
        impl native_model::Model for DatabaseMetaPhonetic {
            fn native_model_id() -> u32 {
                5
            }
            fn native_model_id_str() -> &'static str {
                "5"
            }
            fn native_model_version() -> u32 {
                1
            }
            fn native_model_version_str() -> &'static str {
                "1"
            }
            fn native_model_encode_body(
                &self,
            ) -> std::result::Result<Vec<u8>, native_model::EncodeBodyError> {
                use native_model::Encode;
                native_model::bincode_1_3::Bincode::encode(self)
                    .map_err(|e| native_model::EncodeBodyError {
                        msg: ::alloc::__export::must_use({
                            let res = ::alloc::fmt::format(format_args!("{0}", e));
                            res
                        }),
                        source: e.into(),
                    })
            }
            fn native_model_encode_downgrade_body(
                self,
                version: u32,
            ) -> native_model::Result<Vec<u8>> {
                if version == Self::native_model_version() {
                    let result = self.native_model_encode_body()?;
                    Ok(result)
                } else if version < Self::native_model_version() {
                    Err(native_model::Error::DowngradeNotSupported {
                        from: version,
                        to: Self::native_model_version(),
                    })
                } else {
                    Err(native_model::Error::DowngradeNotSupported {
                        from: version,
                        to: Self::native_model_version(),
                    })
                }
            }
            fn native_model_decode_body(
                data: Vec<u8>,
                id: u32,
            ) -> std::result::Result<Self, native_model::DecodeBodyError> {
                if id != 5 {
                    return Err(native_model::DecodeBodyError::MismatchedModelId);
                }
                use native_model::Decode;
                native_model::bincode_1_3::Bincode::decode(data)
                    .map_err(|e| native_model::DecodeBodyError::DecodeError {
                        msg: ::alloc::__export::must_use({
                            let res = ::alloc::fmt::format(format_args!("{0}", e));
                            res
                        }),
                        source: e.into(),
                    })
            }
            fn native_model_decode_upgrade_body(
                data: Vec<u8>,
                id: u32,
                version: u32,
            ) -> native_model::Result<Self> {
                if version == Self::native_model_version() {
                    let result = Self::native_model_decode_body(data, id)?;
                    Ok(result)
                } else if version < Self::native_model_version() {
                    Err(native_model::Error::UpgradeNotSupported {
                        from: version,
                        to: Self::native_model_version(),
                    })
                } else {
                    Err(native_model::Error::UpgradeNotSupported {
                        from: version,
                        to: Self::native_model_version(),
                    })
                }
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for DatabaseMetaPhonetic {
            #[inline]
            fn clone(&self) -> DatabaseMetaPhonetic {
                DatabaseMetaPhonetic {
                    id: ::core::clone::Clone::clone(&self.id),
                    phonetic_expression: ::core::clone::Clone::clone(
                        &self.phonetic_expression,
                    ),
                    mode: ::core::clone::Clone::clone(&self.mode),
                    data: ::core::clone::Clone::clone(&self.data),
                    dictionary: ::core::clone::Clone::clone(&self.dictionary),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for DatabaseMetaPhonetic {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field5_finish(
                    f,
                    "DatabaseMetaPhonetic",
                    "id",
                    &self.id,
                    "phonetic_expression",
                    &self.phonetic_expression,
                    "mode",
                    &self.mode,
                    "data",
                    &self.data,
                    "dictionary",
                    &&self.dictionary,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for DatabaseMetaPhonetic {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for DatabaseMetaPhonetic {
            #[inline]
            fn eq(&self, other: &DatabaseMetaPhonetic) -> bool {
                self.id == other.id
                    && self.phonetic_expression == other.phonetic_expression
                    && self.mode == other.mode && self.data == other.data
                    && self.dictionary == other.dictionary
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for DatabaseMetaPhonetic {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "DatabaseMetaPhonetic",
                        false as usize + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "id",
                        &self.id,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "phonetic_expression",
                        &self.phonetic_expression,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "mode",
                        &self.mode,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "data",
                        &self.data,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "dictionary",
                        &self.dictionary,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DatabaseMetaPhonetic {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "id" => _serde::__private::Ok(__Field::__field0),
                                "phonetic_expression" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                "mode" => _serde::__private::Ok(__Field::__field2),
                                "data" => _serde::__private::Ok(__Field::__field3),
                                "dictionary" => _serde::__private::Ok(__Field::__field4),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"id" => _serde::__private::Ok(__Field::__field0),
                                b"phonetic_expression" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                b"mode" => _serde::__private::Ok(__Field::__field2),
                                b"data" => _serde::__private::Ok(__Field::__field3),
                                b"dictionary" => _serde::__private::Ok(__Field::__field4),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DatabaseMetaPhonetic>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DatabaseMetaPhonetic;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DatabaseMetaPhonetic",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DatabaseMetaPhonetic with 5 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct DatabaseMetaPhonetic with 5 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                TermMetaModeType,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct DatabaseMetaPhonetic with 5 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match _serde::de::SeqAccess::next_element::<
                                TermMetaPhoneticData,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct DatabaseMetaPhonetic with 5 elements",
                                        ),
                                    );
                                }
                            };
                            let __field4 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            4usize,
                                            &"struct DatabaseMetaPhonetic with 5 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DatabaseMetaPhonetic {
                                id: __field0,
                                phonetic_expression: __field1,
                                mode: __field2,
                                data: __field3,
                                dictionary: __field4,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<
                                TermMetaModeType,
                            > = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<
                                TermMetaPhoneticData,
                            > = _serde::__private::None;
                            let mut __field4: _serde::__private::Option<String> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "phonetic_expression",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("mode"),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                TermMetaModeType,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("data"),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                TermMetaPhoneticData,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field4 => {
                                        if _serde::__private::Option::is_some(&__field4) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "dictionary",
                                                ),
                                            );
                                        }
                                        __field4 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("id")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("phonetic_expression")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("mode")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("data")?
                                }
                            };
                            let __field4 = match __field4 {
                                _serde::__private::Some(__field4) => __field4,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("dictionary")?
                                }
                            };
                            _serde::__private::Ok(DatabaseMetaPhonetic {
                                id: __field0,
                                phonetic_expression: __field1,
                                mode: __field2,
                                data: __field3,
                                dictionary: __field4,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "id",
                        "phonetic_expression",
                        "mode",
                        "data",
                        "dictionary",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DatabaseMetaPhonetic",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                DatabaseMetaPhonetic,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        pub struct TermMetaPhoneticData {
            pub reading: String,
            /// List of different IPA transcription information for the term and reading combination.
            pub transcriptions: Vec<PhoneticTranscription>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for TermMetaPhoneticData {
            #[inline]
            fn clone(&self) -> TermMetaPhoneticData {
                TermMetaPhoneticData {
                    reading: ::core::clone::Clone::clone(&self.reading),
                    transcriptions: ::core::clone::Clone::clone(&self.transcriptions),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for TermMetaPhoneticData {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "TermMetaPhoneticData",
                    "reading",
                    &self.reading,
                    "transcriptions",
                    &&self.transcriptions,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for TermMetaPhoneticData {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for TermMetaPhoneticData {
            #[inline]
            fn eq(&self, other: &TermMetaPhoneticData) -> bool {
                self.reading == other.reading
                    && self.transcriptions == other.transcriptions
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for TermMetaPhoneticData {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "TermMetaPhoneticData",
                        false as usize + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "reading",
                        &self.reading,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "transcriptions",
                        &self.transcriptions,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for TermMetaPhoneticData {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "reading" => _serde::__private::Ok(__Field::__field0),
                                "transcriptions" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"reading" => _serde::__private::Ok(__Field::__field0),
                                b"transcriptions" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<TermMetaPhoneticData>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = TermMetaPhoneticData;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct TermMetaPhoneticData",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct TermMetaPhoneticData with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Vec<PhoneticTranscription>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct TermMetaPhoneticData with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(TermMetaPhoneticData {
                                reading: __field0,
                                transcriptions: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<
                                Vec<PhoneticTranscription>,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "reading",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "transcriptions",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Vec<PhoneticTranscription>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("reading")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("transcriptions")?
                                }
                            };
                            _serde::__private::Ok(TermMetaPhoneticData {
                                reading: __field0,
                                transcriptions: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "reading",
                        "transcriptions",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "TermMetaPhoneticData",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                TermMetaPhoneticData,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        pub struct PhoneticTranscription {
            /// Type of the pronunciation, for disambiguation between union type members.
            /// Should be `"phonetic-transcription"` in the json.
            pub match_type: TermPronunciationMatchType,
            /// IPA transcription for the term.
            pub ipa: String,
            /// List of tags for this IPA transcription.
            pub tags: Vec<DictionaryTag>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for PhoneticTranscription {
            #[inline]
            fn clone(&self) -> PhoneticTranscription {
                PhoneticTranscription {
                    match_type: ::core::clone::Clone::clone(&self.match_type),
                    ipa: ::core::clone::Clone::clone(&self.ipa),
                    tags: ::core::clone::Clone::clone(&self.tags),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for PhoneticTranscription {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "PhoneticTranscription",
                    "match_type",
                    &self.match_type,
                    "ipa",
                    &self.ipa,
                    "tags",
                    &&self.tags,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for PhoneticTranscription {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for PhoneticTranscription {
            #[inline]
            fn eq(&self, other: &PhoneticTranscription) -> bool {
                self.match_type == other.match_type && self.ipa == other.ipa
                    && self.tags == other.tags
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for PhoneticTranscription {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<TermPronunciationMatchType>;
                let _: ::core::cmp::AssertParamIsEq<String>;
                let _: ::core::cmp::AssertParamIsEq<Vec<DictionaryTag>>;
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for PhoneticTranscription {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.match_type, state);
                ::core::hash::Hash::hash(&self.ipa, state);
                ::core::hash::Hash::hash(&self.tags, state)
            }
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for PhoneticTranscription {
            #[inline]
            fn partial_cmp(
                &self,
                other: &PhoneticTranscription,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                match ::core::cmp::PartialOrd::partial_cmp(
                    &self.match_type,
                    &other.match_type,
                ) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        match ::core::cmp::PartialOrd::partial_cmp(
                            &self.ipa,
                            &other.ipa,
                        ) {
                            ::core::option::Option::Some(
                                ::core::cmp::Ordering::Equal,
                            ) => {
                                ::core::cmp::PartialOrd::partial_cmp(
                                    &self.tags,
                                    &other.tags,
                                )
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for PhoneticTranscription {
            #[inline]
            fn cmp(&self, other: &PhoneticTranscription) -> ::core::cmp::Ordering {
                match ::core::cmp::Ord::cmp(&self.match_type, &other.match_type) {
                    ::core::cmp::Ordering::Equal => {
                        match ::core::cmp::Ord::cmp(&self.ipa, &other.ipa) {
                            ::core::cmp::Ordering::Equal => {
                                ::core::cmp::Ord::cmp(&self.tags, &other.tags)
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for PhoneticTranscription {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "PhoneticTranscription",
                        false as usize + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "match_type",
                        &self.match_type,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "ipa",
                        &self.ipa,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "tags",
                        &self.tags,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for PhoneticTranscription {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "match_type" => _serde::__private::Ok(__Field::__field0),
                                "ipa" => _serde::__private::Ok(__Field::__field1),
                                "tags" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"match_type" => _serde::__private::Ok(__Field::__field0),
                                b"ipa" => _serde::__private::Ok(__Field::__field1),
                                b"tags" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<PhoneticTranscription>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = PhoneticTranscription;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct PhoneticTranscription",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                TermPronunciationMatchType,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct PhoneticTranscription with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct PhoneticTranscription with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                Vec<DictionaryTag>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct PhoneticTranscription with 3 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(PhoneticTranscription {
                                match_type: __field0,
                                ipa: __field1,
                                tags: __field2,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                TermPronunciationMatchType,
                            > = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<
                                Vec<DictionaryTag>,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "match_type",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                TermPronunciationMatchType,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("ipa"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("tags"),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Vec<DictionaryTag>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("match_type")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("ipa")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("tags")?
                                }
                            };
                            _serde::__private::Ok(PhoneticTranscription {
                                match_type: __field0,
                                ipa: __field1,
                                tags: __field2,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "match_type",
                        "ipa",
                        "tags",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "PhoneticTranscription",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                PhoneticTranscription,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        pub enum TermPronunciationMatchType {
            #[serde(rename = "lowercase")]
            PitchAccent,
            #[serde(rename = "phonetic-transcription")]
            PhoneticTranscription,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for TermPronunciationMatchType {
            #[inline]
            fn clone(&self) -> TermPronunciationMatchType {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for TermPronunciationMatchType {}
        #[automatically_derived]
        impl ::core::fmt::Debug for TermPronunciationMatchType {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        TermPronunciationMatchType::PitchAccent => "PitchAccent",
                        TermPronunciationMatchType::PhoneticTranscription => {
                            "PhoneticTranscription"
                        }
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for TermPronunciationMatchType {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for TermPronunciationMatchType {
            #[inline]
            fn eq(&self, other: &TermPronunciationMatchType) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for TermPronunciationMatchType {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::hash::Hash for TermPronunciationMatchType {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_discr, state)
            }
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for TermPronunciationMatchType {
            #[inline]
            fn partial_cmp(
                &self,
                other: &TermPronunciationMatchType,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                ::core::cmp::PartialOrd::partial_cmp(&__self_discr, &__arg1_discr)
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for TermPronunciationMatchType {
            #[inline]
            fn cmp(&self, other: &TermPronunciationMatchType) -> ::core::cmp::Ordering {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                ::core::cmp::Ord::cmp(&__self_discr, &__arg1_discr)
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for TermPronunciationMatchType {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        TermPronunciationMatchType::PitchAccent => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "TermPronunciationMatchType",
                                0u32,
                                "lowercase",
                            )
                        }
                        TermPronunciationMatchType::PhoneticTranscription => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "TermPronunciationMatchType",
                                1u32,
                                "phonetic-transcription",
                            )
                        }
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for TermPronunciationMatchType {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 2",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "lowercase" => _serde::__private::Ok(__Field::__field0),
                                "phonetic-transcription" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"lowercase" => _serde::__private::Ok(__Field::__field0),
                                b"phonetic-transcription" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<
                            TermPronunciationMatchType,
                        >,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = TermPronunciationMatchType;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum TermPronunciationMatchType",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(
                                        TermPronunciationMatchType::PitchAccent,
                                    )
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(
                                        TermPronunciationMatchType::PhoneticTranscription,
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &[
                        "lowercase",
                        "phonetic-transcription",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "TermPronunciationMatchType",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                TermPronunciationMatchType,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        pub enum Pronunciation {
            PitchAccent(PitchAccent),
            PhoneticTranscription(PhoneticTranscription),
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Pronunciation {
            #[inline]
            fn clone(&self) -> Pronunciation {
                match self {
                    Pronunciation::PitchAccent(__self_0) => {
                        Pronunciation::PitchAccent(::core::clone::Clone::clone(__self_0))
                    }
                    Pronunciation::PhoneticTranscription(__self_0) => {
                        Pronunciation::PhoneticTranscription(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Pronunciation {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    Pronunciation::PitchAccent(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "PitchAccent",
                            &__self_0,
                        )
                    }
                    Pronunciation::PhoneticTranscription(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "PhoneticTranscription",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Pronunciation {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Pronunciation {
            #[inline]
            fn eq(&self, other: &Pronunciation) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
                    && match (self, other) {
                        (
                            Pronunciation::PitchAccent(__self_0),
                            Pronunciation::PitchAccent(__arg1_0),
                        ) => __self_0 == __arg1_0,
                        (
                            Pronunciation::PhoneticTranscription(__self_0),
                            Pronunciation::PhoneticTranscription(__arg1_0),
                        ) => __self_0 == __arg1_0,
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for Pronunciation {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<PitchAccent>;
                let _: ::core::cmp::AssertParamIsEq<PhoneticTranscription>;
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for Pronunciation {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_discr, state);
                match self {
                    Pronunciation::PitchAccent(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    Pronunciation::PhoneticTranscription(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for Pronunciation {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Pronunciation,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                match (self, other) {
                    (
                        Pronunciation::PitchAccent(__self_0),
                        Pronunciation::PitchAccent(__arg1_0),
                    ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                    (
                        Pronunciation::PhoneticTranscription(__self_0),
                        Pronunciation::PhoneticTranscription(__arg1_0),
                    ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                    _ => {
                        ::core::cmp::PartialOrd::partial_cmp(
                            &__self_discr,
                            &__arg1_discr,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for Pronunciation {
            #[inline]
            fn cmp(&self, other: &Pronunciation) -> ::core::cmp::Ordering {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                match ::core::cmp::Ord::cmp(&__self_discr, &__arg1_discr) {
                    ::core::cmp::Ordering::Equal => {
                        match (self, other) {
                            (
                                Pronunciation::PitchAccent(__self_0),
                                Pronunciation::PitchAccent(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (
                                Pronunciation::PhoneticTranscription(__self_0),
                                Pronunciation::PhoneticTranscription(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() }
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for Pronunciation {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        Pronunciation::PitchAccent(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "Pronunciation",
                                0u32,
                                "PitchAccent",
                                __field0,
                            )
                        }
                        Pronunciation::PhoneticTranscription(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "Pronunciation",
                                1u32,
                                "PhoneticTranscription",
                                __field0,
                            )
                        }
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Pronunciation {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 2",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "PitchAccent" => _serde::__private::Ok(__Field::__field0),
                                "PhoneticTranscription" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"PitchAccent" => _serde::__private::Ok(__Field::__field0),
                                b"PhoneticTranscription" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Pronunciation>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Pronunciation;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum Pronunciation",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            PitchAccent,
                                        >(__variant),
                                        Pronunciation::PitchAccent,
                                    )
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            PhoneticTranscription,
                                        >(__variant),
                                        Pronunciation::PhoneticTranscription,
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &[
                        "PitchAccent",
                        "PhoneticTranscription",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "Pronunciation",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Pronunciation>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        impl DBMetaType for DatabaseMetaPhonetic {
            fn mode(&self) -> &TermMetaModeType {
                &self.mode
            }
            fn expression(&self) -> &str {
                &self.phonetic_expression
            }
        }
        /// Kanji Meta's only have frequency data
        pub struct DatabaseKanjiMeta {
            #[primary_key]
            pub character: String,
            /// Is of type [TermMetaModeType::Freq]
            pub mode: TermMetaModeType,
            pub data: TermMetaFreqDataMatchType,
            #[secondary_key]
            pub dictionary: String,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for DatabaseKanjiMeta {
            #[inline]
            fn clone(&self) -> DatabaseKanjiMeta {
                DatabaseKanjiMeta {
                    character: ::core::clone::Clone::clone(&self.character),
                    mode: ::core::clone::Clone::clone(&self.mode),
                    data: ::core::clone::Clone::clone(&self.data),
                    dictionary: ::core::clone::Clone::clone(&self.dictionary),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for DatabaseKanjiMeta {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "DatabaseKanjiMeta",
                    "character",
                    &self.character,
                    "mode",
                    &self.mode,
                    "data",
                    &self.data,
                    "dictionary",
                    &&self.dictionary,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for DatabaseKanjiMeta {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for DatabaseKanjiMeta {
            #[inline]
            fn eq(&self, other: &DatabaseKanjiMeta) -> bool {
                self.character == other.character && self.mode == other.mode
                    && self.data == other.data && self.dictionary == other.dictionary
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for DatabaseKanjiMeta {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "DatabaseKanjiMeta",
                        false as usize + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "character",
                        &self.character,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "mode",
                        &self.mode,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "data",
                        &self.data,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "dictionary",
                        &self.dictionary,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DatabaseKanjiMeta {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "character" => _serde::__private::Ok(__Field::__field0),
                                "mode" => _serde::__private::Ok(__Field::__field1),
                                "data" => _serde::__private::Ok(__Field::__field2),
                                "dictionary" => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"character" => _serde::__private::Ok(__Field::__field0),
                                b"mode" => _serde::__private::Ok(__Field::__field1),
                                b"data" => _serde::__private::Ok(__Field::__field2),
                                b"dictionary" => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DatabaseKanjiMeta>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DatabaseKanjiMeta;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DatabaseKanjiMeta",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DatabaseKanjiMeta with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                TermMetaModeType,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct DatabaseKanjiMeta with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                TermMetaFreqDataMatchType,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct DatabaseKanjiMeta with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct DatabaseKanjiMeta with 4 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DatabaseKanjiMeta {
                                character: __field0,
                                mode: __field1,
                                data: __field2,
                                dictionary: __field3,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<
                                TermMetaModeType,
                            > = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<
                                TermMetaFreqDataMatchType,
                            > = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<String> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "character",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("mode"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                TermMetaModeType,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("data"),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                TermMetaFreqDataMatchType,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "dictionary",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("character")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("mode")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("data")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("dictionary")?
                                }
                            };
                            _serde::__private::Ok(DatabaseKanjiMeta {
                                character: __field0,
                                mode: __field1,
                                data: __field2,
                                dictionary: __field3,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "character",
                        "mode",
                        "data",
                        "dictionary",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DatabaseKanjiMeta",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DatabaseKanjiMeta>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        impl native_model::Model for DatabaseKanjiMeta {
            fn native_model_id() -> u32 {
                8
            }
            fn native_model_id_str() -> &'static str {
                "8"
            }
            fn native_model_version() -> u32 {
                1
            }
            fn native_model_version_str() -> &'static str {
                "1"
            }
            fn native_model_encode_body(
                &self,
            ) -> std::result::Result<Vec<u8>, native_model::EncodeBodyError> {
                use native_model::Encode;
                native_model::bincode_1_3::Bincode::encode(self)
                    .map_err(|e| native_model::EncodeBodyError {
                        msg: ::alloc::__export::must_use({
                            let res = ::alloc::fmt::format(format_args!("{0}", e));
                            res
                        }),
                        source: e.into(),
                    })
            }
            fn native_model_encode_downgrade_body(
                self,
                version: u32,
            ) -> native_model::Result<Vec<u8>> {
                if version == Self::native_model_version() {
                    let result = self.native_model_encode_body()?;
                    Ok(result)
                } else if version < Self::native_model_version() {
                    Err(native_model::Error::DowngradeNotSupported {
                        from: version,
                        to: Self::native_model_version(),
                    })
                } else {
                    Err(native_model::Error::DowngradeNotSupported {
                        from: version,
                        to: Self::native_model_version(),
                    })
                }
            }
            fn native_model_decode_body(
                data: Vec<u8>,
                id: u32,
            ) -> std::result::Result<Self, native_model::DecodeBodyError> {
                if id != 8 {
                    return Err(native_model::DecodeBodyError::MismatchedModelId);
                }
                use native_model::Decode;
                native_model::bincode_1_3::Bincode::decode(data)
                    .map_err(|e| native_model::DecodeBodyError::DecodeError {
                        msg: ::alloc::__export::must_use({
                            let res = ::alloc::fmt::format(format_args!("{0}", e));
                            res
                        }),
                        source: e.into(),
                    })
            }
            fn native_model_decode_upgrade_body(
                data: Vec<u8>,
                id: u32,
                version: u32,
            ) -> native_model::Result<Self> {
                if version == Self::native_model_version() {
                    let result = Self::native_model_decode_body(data, id)?;
                    Ok(result)
                } else if version < Self::native_model_version() {
                    Err(native_model::Error::UpgradeNotSupported {
                        from: version,
                        to: Self::native_model_version(),
                    })
                } else {
                    Err(native_model::Error::UpgradeNotSupported {
                        from: version,
                        to: Self::native_model_version(),
                    })
                }
            }
        }
        impl native_db::db_type::ToInput for DatabaseKanjiMeta {
            fn native_db_bincode_encode_to_vec(
                &self,
            ) -> native_db::db_type::Result<Vec<u8>> {
                native_db::bincode_encode_to_vec(self)
            }
            fn native_db_bincode_decode_from_slice(
                slice: &[u8],
            ) -> native_db::db_type::Result<Self> {
                Ok(native_db::bincode_decode_from_slice(slice)?.0)
            }
            fn native_db_model() -> native_db::Model {
                let mut secondary_tables_name = std::collections::HashSet::new();
                secondary_tables_name
                    .insert(
                        native_db::db_type::KeyDefinition::new(
                            DatabaseKanjiMeta::native_model_id(),
                            DatabaseKanjiMeta::native_model_version(),
                            "dictionary",
                            <String>::key_names(),
                            native_db::db_type::KeyOptions {
                                unique: false,
                                optional: false,
                            },
                        ),
                    );
                native_db::Model {
                    primary_key: native_db::db_type::KeyDefinition::new(
                        DatabaseKanjiMeta::native_model_id(),
                        DatabaseKanjiMeta::native_model_version(),
                        "character",
                        <String>::key_names(),
                        (),
                    ),
                    secondary_keys: secondary_tables_name,
                }
            }
            fn native_db_primary_key(&self) -> native_db::db_type::Key {
                (&self.character).to_key()
            }
            fn native_db_secondary_keys(
                &self,
            ) -> std::collections::HashMap<
                native_db::db_type::KeyDefinition<native_db::db_type::KeyOptions>,
                native_db::db_type::KeyEntry,
            > {
                let mut secondary_tables_name = std::collections::HashMap::new();
                let value: native_db::db_type::Key = (&self.dictionary).to_key();
                let value = native_db::db_type::KeyEntry::Default(value);
                secondary_tables_name
                    .insert(
                        native_db::db_type::KeyDefinition::new(
                            DatabaseKanjiMeta::native_model_id(),
                            DatabaseKanjiMeta::native_model_version(),
                            "dictionary",
                            <String>::key_names(),
                            native_db::db_type::KeyOptions {
                                unique: false,
                                optional: false,
                            },
                        ),
                        value,
                    );
                secondary_tables_name
            }
        }
        #[allow(non_camel_case_types)]
        pub(crate) enum DatabaseKanjiMetaKey {
            #[allow(non_camel_case_types, dead_code)]
            dictionary,
        }
        impl native_db::db_type::ToKeyDefinition<native_db::db_type::KeyOptions>
        for DatabaseKanjiMetaKey {
            fn key_definition(
                &self,
            ) -> native_db::db_type::KeyDefinition<native_db::db_type::KeyOptions> {
                match self {
                    DatabaseKanjiMetaKey::dictionary => {
                        native_db::db_type::KeyDefinition::new(
                            DatabaseKanjiMeta::native_model_id(),
                            DatabaseKanjiMeta::native_model_version(),
                            "dictionary",
                            <String>::key_names(),
                            native_db::db_type::KeyOptions {
                                unique: false,
                                optional: false,
                            },
                        )
                    }
                    _ => {
                        ::std::rt::begin_panic("Unknown key");
                    }
                }
            }
        }
        pub struct DatabaseKanjiEntry {
            #[primary_key]
            pub character: String,
            #[secondary_key]
            #[serde_as(r#as = "NoneAsEmptyString")]
            #[serde(with = ":: serde_with :: As :: < NoneAsEmptyString >")]
            pub onyomi: Option<String>,
            #[secondary_key]
            #[serde_as(r#as = "NoneAsEmptyString")]
            #[serde(with = ":: serde_with :: As :: < NoneAsEmptyString >")]
            pub kunyomi: Option<String>,
            #[secondary_key]
            #[serde_as(r#as = "NoneAsEmptyString")]
            #[serde(with = ":: serde_with :: As :: < NoneAsEmptyString >")]
            pub tags: Option<String>,
            pub meanings: Vec<String>,
            pub stats: Option<IndexMap<String, String>>,
            /// The kanji dictionary name.
            /// Does not exist within the JSON, gets added _after_ deserialization.
            #[secondary_key]
            pub dictionary: Option<String>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for DatabaseKanjiEntry {
            #[inline]
            fn clone(&self) -> DatabaseKanjiEntry {
                DatabaseKanjiEntry {
                    character: ::core::clone::Clone::clone(&self.character),
                    onyomi: ::core::clone::Clone::clone(&self.onyomi),
                    kunyomi: ::core::clone::Clone::clone(&self.kunyomi),
                    tags: ::core::clone::Clone::clone(&self.tags),
                    meanings: ::core::clone::Clone::clone(&self.meanings),
                    stats: ::core::clone::Clone::clone(&self.stats),
                    dictionary: ::core::clone::Clone::clone(&self.dictionary),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for DatabaseKanjiEntry {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "character",
                    "onyomi",
                    "kunyomi",
                    "tags",
                    "meanings",
                    "stats",
                    "dictionary",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.character,
                    &self.onyomi,
                    &self.kunyomi,
                    &self.tags,
                    &self.meanings,
                    &self.stats,
                    &&self.dictionary,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "DatabaseKanjiEntry",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for DatabaseKanjiEntry {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for DatabaseKanjiEntry {
            #[inline]
            fn eq(&self, other: &DatabaseKanjiEntry) -> bool {
                self.character == other.character && self.onyomi == other.onyomi
                    && self.kunyomi == other.kunyomi && self.tags == other.tags
                    && self.meanings == other.meanings && self.stats == other.stats
                    && self.dictionary == other.dictionary
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for DatabaseKanjiEntry {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<String>;
                let _: ::core::cmp::AssertParamIsEq<Option<String>>;
                let _: ::core::cmp::AssertParamIsEq<Option<String>>;
                let _: ::core::cmp::AssertParamIsEq<Option<String>>;
                let _: ::core::cmp::AssertParamIsEq<Vec<String>>;
                let _: ::core::cmp::AssertParamIsEq<Option<IndexMap<String, String>>>;
                let _: ::core::cmp::AssertParamIsEq<Option<String>>;
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for DatabaseKanjiEntry {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "DatabaseKanjiEntry",
                        false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "character",
                        &self.character,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "onyomi",
                        {
                            #[doc(hidden)]
                            struct __SerializeWith<'__a> {
                                values: (&'__a Option<String>,),
                                phantom: _serde::__private::PhantomData<DatabaseKanjiEntry>,
                            }
                            #[automatically_derived]
                            impl<'__a> _serde::Serialize for __SerializeWith<'__a> {
                                fn serialize<__S>(
                                    &self,
                                    __s: __S,
                                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                                where
                                    __S: _serde::Serializer,
                                {
                                    ::serde_with::As::<
                                        NoneAsEmptyString,
                                    >::serialize(self.values.0, __s)
                                }
                            }
                            &__SerializeWith {
                                values: (&self.onyomi,),
                                phantom: _serde::__private::PhantomData::<
                                    DatabaseKanjiEntry,
                                >,
                            }
                        },
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "kunyomi",
                        {
                            #[doc(hidden)]
                            struct __SerializeWith<'__a> {
                                values: (&'__a Option<String>,),
                                phantom: _serde::__private::PhantomData<DatabaseKanjiEntry>,
                            }
                            #[automatically_derived]
                            impl<'__a> _serde::Serialize for __SerializeWith<'__a> {
                                fn serialize<__S>(
                                    &self,
                                    __s: __S,
                                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                                where
                                    __S: _serde::Serializer,
                                {
                                    ::serde_with::As::<
                                        NoneAsEmptyString,
                                    >::serialize(self.values.0, __s)
                                }
                            }
                            &__SerializeWith {
                                values: (&self.kunyomi,),
                                phantom: _serde::__private::PhantomData::<
                                    DatabaseKanjiEntry,
                                >,
                            }
                        },
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "tags",
                        {
                            #[doc(hidden)]
                            struct __SerializeWith<'__a> {
                                values: (&'__a Option<String>,),
                                phantom: _serde::__private::PhantomData<DatabaseKanjiEntry>,
                            }
                            #[automatically_derived]
                            impl<'__a> _serde::Serialize for __SerializeWith<'__a> {
                                fn serialize<__S>(
                                    &self,
                                    __s: __S,
                                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                                where
                                    __S: _serde::Serializer,
                                {
                                    ::serde_with::As::<
                                        NoneAsEmptyString,
                                    >::serialize(self.values.0, __s)
                                }
                            }
                            &__SerializeWith {
                                values: (&self.tags,),
                                phantom: _serde::__private::PhantomData::<
                                    DatabaseKanjiEntry,
                                >,
                            }
                        },
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "meanings",
                        &self.meanings,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "stats",
                        &self.stats,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "dictionary",
                        &self.dictionary,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DatabaseKanjiEntry {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __field6,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                6u64 => _serde::__private::Ok(__Field::__field6),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "character" => _serde::__private::Ok(__Field::__field0),
                                "onyomi" => _serde::__private::Ok(__Field::__field1),
                                "kunyomi" => _serde::__private::Ok(__Field::__field2),
                                "tags" => _serde::__private::Ok(__Field::__field3),
                                "meanings" => _serde::__private::Ok(__Field::__field4),
                                "stats" => _serde::__private::Ok(__Field::__field5),
                                "dictionary" => _serde::__private::Ok(__Field::__field6),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"character" => _serde::__private::Ok(__Field::__field0),
                                b"onyomi" => _serde::__private::Ok(__Field::__field1),
                                b"kunyomi" => _serde::__private::Ok(__Field::__field2),
                                b"tags" => _serde::__private::Ok(__Field::__field3),
                                b"meanings" => _serde::__private::Ok(__Field::__field4),
                                b"stats" => _serde::__private::Ok(__Field::__field5),
                                b"dictionary" => _serde::__private::Ok(__Field::__field6),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DatabaseKanjiEntry>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DatabaseKanjiEntry;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DatabaseKanjiEntry",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DatabaseKanjiEntry with 7 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match {
                                #[doc(hidden)]
                                struct __DeserializeWith<'de> {
                                    value: Option<String>,
                                    phantom: _serde::__private::PhantomData<DatabaseKanjiEntry>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                #[automatically_derived]
                                impl<'de> _serde::Deserialize<'de>
                                for __DeserializeWith<'de> {
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::__private::Ok(__DeserializeWith {
                                            value: ::serde_with::As::<
                                                NoneAsEmptyString,
                                            >::deserialize(__deserializer)?,
                                            phantom: _serde::__private::PhantomData,
                                            lifetime: _serde::__private::PhantomData,
                                        })
                                    }
                                }
                                _serde::__private::Option::map(
                                    _serde::de::SeqAccess::next_element::<
                                        __DeserializeWith<'de>,
                                    >(&mut __seq)?,
                                    |__wrap| __wrap.value,
                                )
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct DatabaseKanjiEntry with 7 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match {
                                #[doc(hidden)]
                                struct __DeserializeWith<'de> {
                                    value: Option<String>,
                                    phantom: _serde::__private::PhantomData<DatabaseKanjiEntry>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                #[automatically_derived]
                                impl<'de> _serde::Deserialize<'de>
                                for __DeserializeWith<'de> {
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::__private::Ok(__DeserializeWith {
                                            value: ::serde_with::As::<
                                                NoneAsEmptyString,
                                            >::deserialize(__deserializer)?,
                                            phantom: _serde::__private::PhantomData,
                                            lifetime: _serde::__private::PhantomData,
                                        })
                                    }
                                }
                                _serde::__private::Option::map(
                                    _serde::de::SeqAccess::next_element::<
                                        __DeserializeWith<'de>,
                                    >(&mut __seq)?,
                                    |__wrap| __wrap.value,
                                )
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct DatabaseKanjiEntry with 7 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match {
                                #[doc(hidden)]
                                struct __DeserializeWith<'de> {
                                    value: Option<String>,
                                    phantom: _serde::__private::PhantomData<DatabaseKanjiEntry>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                #[automatically_derived]
                                impl<'de> _serde::Deserialize<'de>
                                for __DeserializeWith<'de> {
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::__private::Ok(__DeserializeWith {
                                            value: ::serde_with::As::<
                                                NoneAsEmptyString,
                                            >::deserialize(__deserializer)?,
                                            phantom: _serde::__private::PhantomData,
                                            lifetime: _serde::__private::PhantomData,
                                        })
                                    }
                                }
                                _serde::__private::Option::map(
                                    _serde::de::SeqAccess::next_element::<
                                        __DeserializeWith<'de>,
                                    >(&mut __seq)?,
                                    |__wrap| __wrap.value,
                                )
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct DatabaseKanjiEntry with 7 elements",
                                        ),
                                    );
                                }
                            };
                            let __field4 = match _serde::de::SeqAccess::next_element::<
                                Vec<String>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            4usize,
                                            &"struct DatabaseKanjiEntry with 7 elements",
                                        ),
                                    );
                                }
                            };
                            let __field5 = match _serde::de::SeqAccess::next_element::<
                                Option<IndexMap<String, String>>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            5usize,
                                            &"struct DatabaseKanjiEntry with 7 elements",
                                        ),
                                    );
                                }
                            };
                            let __field6 = match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            6usize,
                                            &"struct DatabaseKanjiEntry with 7 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DatabaseKanjiEntry {
                                character: __field0,
                                onyomi: __field1,
                                kunyomi: __field2,
                                tags: __field3,
                                meanings: __field4,
                                stats: __field5,
                                dictionary: __field6,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<
                                Option<String>,
                            > = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<
                                Option<String>,
                            > = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<
                                Option<String>,
                            > = _serde::__private::None;
                            let mut __field4: _serde::__private::Option<Vec<String>> = _serde::__private::None;
                            let mut __field5: _serde::__private::Option<
                                Option<IndexMap<String, String>>,
                            > = _serde::__private::None;
                            let mut __field6: _serde::__private::Option<
                                Option<String>,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "character",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("onyomi"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some({
                                            #[doc(hidden)]
                                            struct __DeserializeWith<'de> {
                                                value: Option<String>,
                                                phantom: _serde::__private::PhantomData<DatabaseKanjiEntry>,
                                                lifetime: _serde::__private::PhantomData<&'de ()>,
                                            }
                                            #[automatically_derived]
                                            impl<'de> _serde::Deserialize<'de>
                                            for __DeserializeWith<'de> {
                                                fn deserialize<__D>(
                                                    __deserializer: __D,
                                                ) -> _serde::__private::Result<Self, __D::Error>
                                                where
                                                    __D: _serde::Deserializer<'de>,
                                                {
                                                    _serde::__private::Ok(__DeserializeWith {
                                                        value: ::serde_with::As::<
                                                            NoneAsEmptyString,
                                                        >::deserialize(__deserializer)?,
                                                        phantom: _serde::__private::PhantomData,
                                                        lifetime: _serde::__private::PhantomData,
                                                    })
                                                }
                                            }
                                            match _serde::de::MapAccess::next_value::<
                                                __DeserializeWith<'de>,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__wrapper) => __wrapper.value,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            }
                                        });
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "kunyomi",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some({
                                            #[doc(hidden)]
                                            struct __DeserializeWith<'de> {
                                                value: Option<String>,
                                                phantom: _serde::__private::PhantomData<DatabaseKanjiEntry>,
                                                lifetime: _serde::__private::PhantomData<&'de ()>,
                                            }
                                            #[automatically_derived]
                                            impl<'de> _serde::Deserialize<'de>
                                            for __DeserializeWith<'de> {
                                                fn deserialize<__D>(
                                                    __deserializer: __D,
                                                ) -> _serde::__private::Result<Self, __D::Error>
                                                where
                                                    __D: _serde::Deserializer<'de>,
                                                {
                                                    _serde::__private::Ok(__DeserializeWith {
                                                        value: ::serde_with::As::<
                                                            NoneAsEmptyString,
                                                        >::deserialize(__deserializer)?,
                                                        phantom: _serde::__private::PhantomData,
                                                        lifetime: _serde::__private::PhantomData,
                                                    })
                                                }
                                            }
                                            match _serde::de::MapAccess::next_value::<
                                                __DeserializeWith<'de>,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__wrapper) => __wrapper.value,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            }
                                        });
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("tags"),
                                            );
                                        }
                                        __field3 = _serde::__private::Some({
                                            #[doc(hidden)]
                                            struct __DeserializeWith<'de> {
                                                value: Option<String>,
                                                phantom: _serde::__private::PhantomData<DatabaseKanjiEntry>,
                                                lifetime: _serde::__private::PhantomData<&'de ()>,
                                            }
                                            #[automatically_derived]
                                            impl<'de> _serde::Deserialize<'de>
                                            for __DeserializeWith<'de> {
                                                fn deserialize<__D>(
                                                    __deserializer: __D,
                                                ) -> _serde::__private::Result<Self, __D::Error>
                                                where
                                                    __D: _serde::Deserializer<'de>,
                                                {
                                                    _serde::__private::Ok(__DeserializeWith {
                                                        value: ::serde_with::As::<
                                                            NoneAsEmptyString,
                                                        >::deserialize(__deserializer)?,
                                                        phantom: _serde::__private::PhantomData,
                                                        lifetime: _serde::__private::PhantomData,
                                                    })
                                                }
                                            }
                                            match _serde::de::MapAccess::next_value::<
                                                __DeserializeWith<'de>,
                                            >(&mut __map) {
                                                _serde::__private::Ok(__wrapper) => __wrapper.value,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            }
                                        });
                                    }
                                    __Field::__field4 => {
                                        if _serde::__private::Option::is_some(&__field4) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "meanings",
                                                ),
                                            );
                                        }
                                        __field4 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Vec<String>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field5 => {
                                        if _serde::__private::Option::is_some(&__field5) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("stats"),
                                            );
                                        }
                                        __field5 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<IndexMap<String, String>>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field6 => {
                                        if _serde::__private::Option::is_some(&__field6) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "dictionary",
                                                ),
                                            );
                                        }
                                        __field6 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<String>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("character")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::missing_field("onyomi"),
                                    );
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::missing_field("kunyomi"),
                                    );
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        <__A::Error as _serde::de::Error>::missing_field("tags"),
                                    );
                                }
                            };
                            let __field4 = match __field4 {
                                _serde::__private::Some(__field4) => __field4,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("meanings")?
                                }
                            };
                            let __field5 = match __field5 {
                                _serde::__private::Some(__field5) => __field5,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("stats")?
                                }
                            };
                            let __field6 = match __field6 {
                                _serde::__private::Some(__field6) => __field6,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("dictionary")?
                                }
                            };
                            _serde::__private::Ok(DatabaseKanjiEntry {
                                character: __field0,
                                onyomi: __field1,
                                kunyomi: __field2,
                                tags: __field3,
                                meanings: __field4,
                                stats: __field5,
                                dictionary: __field6,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "character",
                        "onyomi",
                        "kunyomi",
                        "tags",
                        "meanings",
                        "stats",
                        "dictionary",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DatabaseKanjiEntry",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DatabaseKanjiEntry>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        impl native_model::Model for DatabaseKanjiEntry {
            fn native_model_id() -> u32 {
                7
            }
            fn native_model_id_str() -> &'static str {
                "7"
            }
            fn native_model_version() -> u32 {
                1
            }
            fn native_model_version_str() -> &'static str {
                "1"
            }
            fn native_model_encode_body(
                &self,
            ) -> std::result::Result<Vec<u8>, native_model::EncodeBodyError> {
                use native_model::Encode;
                native_model::bincode_1_3::Bincode::encode(self)
                    .map_err(|e| native_model::EncodeBodyError {
                        msg: ::alloc::__export::must_use({
                            let res = ::alloc::fmt::format(format_args!("{0}", e));
                            res
                        }),
                        source: e.into(),
                    })
            }
            fn native_model_encode_downgrade_body(
                self,
                version: u32,
            ) -> native_model::Result<Vec<u8>> {
                if version == Self::native_model_version() {
                    let result = self.native_model_encode_body()?;
                    Ok(result)
                } else if version < Self::native_model_version() {
                    Err(native_model::Error::DowngradeNotSupported {
                        from: version,
                        to: Self::native_model_version(),
                    })
                } else {
                    Err(native_model::Error::DowngradeNotSupported {
                        from: version,
                        to: Self::native_model_version(),
                    })
                }
            }
            fn native_model_decode_body(
                data: Vec<u8>,
                id: u32,
            ) -> std::result::Result<Self, native_model::DecodeBodyError> {
                if id != 7 {
                    return Err(native_model::DecodeBodyError::MismatchedModelId);
                }
                use native_model::Decode;
                native_model::bincode_1_3::Bincode::decode(data)
                    .map_err(|e| native_model::DecodeBodyError::DecodeError {
                        msg: ::alloc::__export::must_use({
                            let res = ::alloc::fmt::format(format_args!("{0}", e));
                            res
                        }),
                        source: e.into(),
                    })
            }
            fn native_model_decode_upgrade_body(
                data: Vec<u8>,
                id: u32,
                version: u32,
            ) -> native_model::Result<Self> {
                if version == Self::native_model_version() {
                    let result = Self::native_model_decode_body(data, id)?;
                    Ok(result)
                } else if version < Self::native_model_version() {
                    Err(native_model::Error::UpgradeNotSupported {
                        from: version,
                        to: Self::native_model_version(),
                    })
                } else {
                    Err(native_model::Error::UpgradeNotSupported {
                        from: version,
                        to: Self::native_model_version(),
                    })
                }
            }
        }
        impl native_db::db_type::ToInput for DatabaseKanjiEntry {
            fn native_db_bincode_encode_to_vec(
                &self,
            ) -> native_db::db_type::Result<Vec<u8>> {
                native_db::bincode_encode_to_vec(self)
            }
            fn native_db_bincode_decode_from_slice(
                slice: &[u8],
            ) -> native_db::db_type::Result<Self> {
                Ok(native_db::bincode_decode_from_slice(slice)?.0)
            }
            fn native_db_model() -> native_db::Model {
                let mut secondary_tables_name = std::collections::HashSet::new();
                secondary_tables_name
                    .insert(
                        native_db::db_type::KeyDefinition::new(
                            DatabaseKanjiEntry::native_model_id(),
                            DatabaseKanjiEntry::native_model_version(),
                            "onyomi",
                            <Option<String>>::key_names(),
                            native_db::db_type::KeyOptions {
                                unique: false,
                                optional: false,
                            },
                        ),
                    );
                secondary_tables_name
                    .insert(
                        native_db::db_type::KeyDefinition::new(
                            DatabaseKanjiEntry::native_model_id(),
                            DatabaseKanjiEntry::native_model_version(),
                            "dictionary",
                            <Option<String>>::key_names(),
                            native_db::db_type::KeyOptions {
                                unique: false,
                                optional: false,
                            },
                        ),
                    );
                secondary_tables_name
                    .insert(
                        native_db::db_type::KeyDefinition::new(
                            DatabaseKanjiEntry::native_model_id(),
                            DatabaseKanjiEntry::native_model_version(),
                            "tags",
                            <Option<String>>::key_names(),
                            native_db::db_type::KeyOptions {
                                unique: false,
                                optional: false,
                            },
                        ),
                    );
                secondary_tables_name
                    .insert(
                        native_db::db_type::KeyDefinition::new(
                            DatabaseKanjiEntry::native_model_id(),
                            DatabaseKanjiEntry::native_model_version(),
                            "kunyomi",
                            <Option<String>>::key_names(),
                            native_db::db_type::KeyOptions {
                                unique: false,
                                optional: false,
                            },
                        ),
                    );
                native_db::Model {
                    primary_key: native_db::db_type::KeyDefinition::new(
                        DatabaseKanjiEntry::native_model_id(),
                        DatabaseKanjiEntry::native_model_version(),
                        "character",
                        <String>::key_names(),
                        (),
                    ),
                    secondary_keys: secondary_tables_name,
                }
            }
            fn native_db_primary_key(&self) -> native_db::db_type::Key {
                (&self.character).to_key()
            }
            fn native_db_secondary_keys(
                &self,
            ) -> std::collections::HashMap<
                native_db::db_type::KeyDefinition<native_db::db_type::KeyOptions>,
                native_db::db_type::KeyEntry,
            > {
                let mut secondary_tables_name = std::collections::HashMap::new();
                let value: native_db::db_type::Key = (&self.onyomi).to_key();
                let value = native_db::db_type::KeyEntry::Default(value);
                secondary_tables_name
                    .insert(
                        native_db::db_type::KeyDefinition::new(
                            DatabaseKanjiEntry::native_model_id(),
                            DatabaseKanjiEntry::native_model_version(),
                            "onyomi",
                            <Option<String>>::key_names(),
                            native_db::db_type::KeyOptions {
                                unique: false,
                                optional: false,
                            },
                        ),
                        value,
                    );
                let value: native_db::db_type::Key = (&self.dictionary).to_key();
                let value = native_db::db_type::KeyEntry::Default(value);
                secondary_tables_name
                    .insert(
                        native_db::db_type::KeyDefinition::new(
                            DatabaseKanjiEntry::native_model_id(),
                            DatabaseKanjiEntry::native_model_version(),
                            "dictionary",
                            <Option<String>>::key_names(),
                            native_db::db_type::KeyOptions {
                                unique: false,
                                optional: false,
                            },
                        ),
                        value,
                    );
                let value: native_db::db_type::Key = (&self.tags).to_key();
                let value = native_db::db_type::KeyEntry::Default(value);
                secondary_tables_name
                    .insert(
                        native_db::db_type::KeyDefinition::new(
                            DatabaseKanjiEntry::native_model_id(),
                            DatabaseKanjiEntry::native_model_version(),
                            "tags",
                            <Option<String>>::key_names(),
                            native_db::db_type::KeyOptions {
                                unique: false,
                                optional: false,
                            },
                        ),
                        value,
                    );
                let value: native_db::db_type::Key = (&self.kunyomi).to_key();
                let value = native_db::db_type::KeyEntry::Default(value);
                secondary_tables_name
                    .insert(
                        native_db::db_type::KeyDefinition::new(
                            DatabaseKanjiEntry::native_model_id(),
                            DatabaseKanjiEntry::native_model_version(),
                            "kunyomi",
                            <Option<String>>::key_names(),
                            native_db::db_type::KeyOptions {
                                unique: false,
                                optional: false,
                            },
                        ),
                        value,
                    );
                secondary_tables_name
            }
        }
        #[allow(non_camel_case_types)]
        pub(crate) enum DatabaseKanjiEntryKey {
            #[allow(non_camel_case_types, dead_code)]
            onyomi,
            #[allow(non_camel_case_types, dead_code)]
            dictionary,
            #[allow(non_camel_case_types, dead_code)]
            tags,
            #[allow(non_camel_case_types, dead_code)]
            kunyomi,
        }
        impl native_db::db_type::ToKeyDefinition<native_db::db_type::KeyOptions>
        for DatabaseKanjiEntryKey {
            fn key_definition(
                &self,
            ) -> native_db::db_type::KeyDefinition<native_db::db_type::KeyOptions> {
                match self {
                    DatabaseKanjiEntryKey::onyomi => {
                        native_db::db_type::KeyDefinition::new(
                            DatabaseKanjiEntry::native_model_id(),
                            DatabaseKanjiEntry::native_model_version(),
                            "onyomi",
                            <Option<String>>::key_names(),
                            native_db::db_type::KeyOptions {
                                unique: false,
                                optional: false,
                            },
                        )
                    }
                    DatabaseKanjiEntryKey::dictionary => {
                        native_db::db_type::KeyDefinition::new(
                            DatabaseKanjiEntry::native_model_id(),
                            DatabaseKanjiEntry::native_model_version(),
                            "dictionary",
                            <Option<String>>::key_names(),
                            native_db::db_type::KeyOptions {
                                unique: false,
                                optional: false,
                            },
                        )
                    }
                    DatabaseKanjiEntryKey::tags => {
                        native_db::db_type::KeyDefinition::new(
                            DatabaseKanjiEntry::native_model_id(),
                            DatabaseKanjiEntry::native_model_version(),
                            "tags",
                            <Option<String>>::key_names(),
                            native_db::db_type::KeyOptions {
                                unique: false,
                                optional: false,
                            },
                        )
                    }
                    DatabaseKanjiEntryKey::kunyomi => {
                        native_db::db_type::KeyDefinition::new(
                            DatabaseKanjiEntry::native_model_id(),
                            DatabaseKanjiEntry::native_model_version(),
                            "kunyomi",
                            <Option<String>>::key_names(),
                            native_db::db_type::KeyOptions {
                                unique: false,
                                optional: false,
                            },
                        )
                    }
                    _ => {
                        ::std::rt::begin_panic("Unknown key");
                    }
                }
            }
        }
        pub struct KanjiEntry {
            pub index: usize,
            pub character: String,
            pub onyomi: Vec<String>,
            pub kunyomi: Vec<String>,
            pub tags: Vec<String>,
            pub definitions: Vec<String>,
            pub stats: IndexMap<String, String>,
            pub dictionary: String,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for KanjiEntry {
            #[inline]
            fn clone(&self) -> KanjiEntry {
                KanjiEntry {
                    index: ::core::clone::Clone::clone(&self.index),
                    character: ::core::clone::Clone::clone(&self.character),
                    onyomi: ::core::clone::Clone::clone(&self.onyomi),
                    kunyomi: ::core::clone::Clone::clone(&self.kunyomi),
                    tags: ::core::clone::Clone::clone(&self.tags),
                    definitions: ::core::clone::Clone::clone(&self.definitions),
                    stats: ::core::clone::Clone::clone(&self.stats),
                    dictionary: ::core::clone::Clone::clone(&self.dictionary),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for KanjiEntry {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "index",
                    "character",
                    "onyomi",
                    "kunyomi",
                    "tags",
                    "definitions",
                    "stats",
                    "dictionary",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.index,
                    &self.character,
                    &self.onyomi,
                    &self.kunyomi,
                    &self.tags,
                    &self.definitions,
                    &self.stats,
                    &&self.dictionary,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "KanjiEntry",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for KanjiEntry {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for KanjiEntry {
            #[inline]
            fn eq(&self, other: &KanjiEntry) -> bool {
                self.index == other.index && self.character == other.character
                    && self.onyomi == other.onyomi && self.kunyomi == other.kunyomi
                    && self.tags == other.tags && self.definitions == other.definitions
                    && self.stats == other.stats && self.dictionary == other.dictionary
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for KanjiEntry {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<usize>;
                let _: ::core::cmp::AssertParamIsEq<String>;
                let _: ::core::cmp::AssertParamIsEq<Vec<String>>;
                let _: ::core::cmp::AssertParamIsEq<Vec<String>>;
                let _: ::core::cmp::AssertParamIsEq<Vec<String>>;
                let _: ::core::cmp::AssertParamIsEq<Vec<String>>;
                let _: ::core::cmp::AssertParamIsEq<IndexMap<String, String>>;
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for KanjiEntry {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "KanjiEntry",
                        false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "index",
                        &self.index,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "character",
                        &self.character,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "onyomi",
                        &self.onyomi,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "kunyomi",
                        &self.kunyomi,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "tags",
                        &self.tags,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "definitions",
                        &self.definitions,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "stats",
                        &self.stats,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "dictionary",
                        &self.dictionary,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for KanjiEntry {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __field6,
                        __field7,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                6u64 => _serde::__private::Ok(__Field::__field6),
                                7u64 => _serde::__private::Ok(__Field::__field7),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "index" => _serde::__private::Ok(__Field::__field0),
                                "character" => _serde::__private::Ok(__Field::__field1),
                                "onyomi" => _serde::__private::Ok(__Field::__field2),
                                "kunyomi" => _serde::__private::Ok(__Field::__field3),
                                "tags" => _serde::__private::Ok(__Field::__field4),
                                "definitions" => _serde::__private::Ok(__Field::__field5),
                                "stats" => _serde::__private::Ok(__Field::__field6),
                                "dictionary" => _serde::__private::Ok(__Field::__field7),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"index" => _serde::__private::Ok(__Field::__field0),
                                b"character" => _serde::__private::Ok(__Field::__field1),
                                b"onyomi" => _serde::__private::Ok(__Field::__field2),
                                b"kunyomi" => _serde::__private::Ok(__Field::__field3),
                                b"tags" => _serde::__private::Ok(__Field::__field4),
                                b"definitions" => _serde::__private::Ok(__Field::__field5),
                                b"stats" => _serde::__private::Ok(__Field::__field6),
                                b"dictionary" => _serde::__private::Ok(__Field::__field7),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<KanjiEntry>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = KanjiEntry;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct KanjiEntry",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                usize,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct KanjiEntry with 8 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct KanjiEntry with 8 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                Vec<String>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct KanjiEntry with 8 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match _serde::de::SeqAccess::next_element::<
                                Vec<String>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct KanjiEntry with 8 elements",
                                        ),
                                    );
                                }
                            };
                            let __field4 = match _serde::de::SeqAccess::next_element::<
                                Vec<String>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            4usize,
                                            &"struct KanjiEntry with 8 elements",
                                        ),
                                    );
                                }
                            };
                            let __field5 = match _serde::de::SeqAccess::next_element::<
                                Vec<String>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            5usize,
                                            &"struct KanjiEntry with 8 elements",
                                        ),
                                    );
                                }
                            };
                            let __field6 = match _serde::de::SeqAccess::next_element::<
                                IndexMap<String, String>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            6usize,
                                            &"struct KanjiEntry with 8 elements",
                                        ),
                                    );
                                }
                            };
                            let __field7 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            7usize,
                                            &"struct KanjiEntry with 8 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(KanjiEntry {
                                index: __field0,
                                character: __field1,
                                onyomi: __field2,
                                kunyomi: __field3,
                                tags: __field4,
                                definitions: __field5,
                                stats: __field6,
                                dictionary: __field7,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<usize> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<Vec<String>> = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<Vec<String>> = _serde::__private::None;
                            let mut __field4: _serde::__private::Option<Vec<String>> = _serde::__private::None;
                            let mut __field5: _serde::__private::Option<Vec<String>> = _serde::__private::None;
                            let mut __field6: _serde::__private::Option<
                                IndexMap<String, String>,
                            > = _serde::__private::None;
                            let mut __field7: _serde::__private::Option<String> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("index"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<usize>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "character",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("onyomi"),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Vec<String>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "kunyomi",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Vec<String>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field4 => {
                                        if _serde::__private::Option::is_some(&__field4) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("tags"),
                                            );
                                        }
                                        __field4 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Vec<String>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field5 => {
                                        if _serde::__private::Option::is_some(&__field5) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "definitions",
                                                ),
                                            );
                                        }
                                        __field5 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Vec<String>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field6 => {
                                        if _serde::__private::Option::is_some(&__field6) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("stats"),
                                            );
                                        }
                                        __field6 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                IndexMap<String, String>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field7 => {
                                        if _serde::__private::Option::is_some(&__field7) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "dictionary",
                                                ),
                                            );
                                        }
                                        __field7 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("index")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("character")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("onyomi")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("kunyomi")?
                                }
                            };
                            let __field4 = match __field4 {
                                _serde::__private::Some(__field4) => __field4,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("tags")?
                                }
                            };
                            let __field5 = match __field5 {
                                _serde::__private::Some(__field5) => __field5,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("definitions")?
                                }
                            };
                            let __field6 = match __field6 {
                                _serde::__private::Some(__field6) => __field6,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("stats")?
                                }
                            };
                            let __field7 = match __field7 {
                                _serde::__private::Some(__field7) => __field7,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("dictionary")?
                                }
                            };
                            _serde::__private::Ok(KanjiEntry {
                                index: __field0,
                                character: __field1,
                                onyomi: __field2,
                                kunyomi: __field3,
                                tags: __field4,
                                definitions: __field5,
                                stats: __field6,
                                dictionary: __field7,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "index",
                        "character",
                        "onyomi",
                        "kunyomi",
                        "tags",
                        "definitions",
                        "stats",
                        "dictionary",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "KanjiEntry",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<KanjiEntry>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        pub type DictionaryCountGroup = IndexMap<String, u16>;
        pub struct DictionaryCounts {
            total: Option<DictionaryCountGroup>,
            counts: Vec<DictionaryCountGroup>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for DictionaryCounts {
            #[inline]
            fn clone(&self) -> DictionaryCounts {
                DictionaryCounts {
                    total: ::core::clone::Clone::clone(&self.total),
                    counts: ::core::clone::Clone::clone(&self.counts),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for DictionaryCounts {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "DictionaryCounts",
                    "total",
                    &self.total,
                    "counts",
                    &&self.counts,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for DictionaryCounts {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for DictionaryCounts {
            #[inline]
            fn eq(&self, other: &DictionaryCounts) -> bool {
                self.total == other.total && self.counts == other.counts
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for DictionaryCounts {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "DictionaryCounts",
                        false as usize + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "total",
                        &self.total,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "counts",
                        &self.counts,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DictionaryCounts {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "total" => _serde::__private::Ok(__Field::__field0),
                                "counts" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"total" => _serde::__private::Ok(__Field::__field0),
                                b"counts" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DictionaryCounts>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DictionaryCounts;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DictionaryCounts",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                Option<DictionaryCountGroup>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DictionaryCounts with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Vec<DictionaryCountGroup>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct DictionaryCounts with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DictionaryCounts {
                                total: __field0,
                                counts: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                Option<DictionaryCountGroup>,
                            > = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<
                                Vec<DictionaryCountGroup>,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("total"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<DictionaryCountGroup>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("counts"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Vec<DictionaryCountGroup>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("total")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("counts")?
                                }
                            };
                            _serde::__private::Ok(DictionaryCounts {
                                total: __field0,
                                counts: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["total", "counts"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DictionaryCounts",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DictionaryCounts>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        pub struct DeleteDictionaryProgressData {
            count: u64,
            processed: u64,
            store_count: u16,
            stores_processed: u64,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for DeleteDictionaryProgressData {
            #[inline]
            fn clone(&self) -> DeleteDictionaryProgressData {
                DeleteDictionaryProgressData {
                    count: ::core::clone::Clone::clone(&self.count),
                    processed: ::core::clone::Clone::clone(&self.processed),
                    store_count: ::core::clone::Clone::clone(&self.store_count),
                    stores_processed: ::core::clone::Clone::clone(&self.stores_processed),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for DeleteDictionaryProgressData {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "DeleteDictionaryProgressData",
                    "count",
                    &self.count,
                    "processed",
                    &self.processed,
                    "store_count",
                    &self.store_count,
                    "stores_processed",
                    &&self.stores_processed,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for DeleteDictionaryProgressData {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for DeleteDictionaryProgressData {
            #[inline]
            fn eq(&self, other: &DeleteDictionaryProgressData) -> bool {
                self.count == other.count && self.processed == other.processed
                    && self.store_count == other.store_count
                    && self.stores_processed == other.stores_processed
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for DeleteDictionaryProgressData {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "DeleteDictionaryProgressData",
                        false as usize + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "count",
                        &self.count,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "processed",
                        &self.processed,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "store_count",
                        &self.store_count,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "stores_processed",
                        &self.stores_processed,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DeleteDictionaryProgressData {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "count" => _serde::__private::Ok(__Field::__field0),
                                "processed" => _serde::__private::Ok(__Field::__field1),
                                "store_count" => _serde::__private::Ok(__Field::__field2),
                                "stores_processed" => {
                                    _serde::__private::Ok(__Field::__field3)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"count" => _serde::__private::Ok(__Field::__field0),
                                b"processed" => _serde::__private::Ok(__Field::__field1),
                                b"store_count" => _serde::__private::Ok(__Field::__field2),
                                b"stores_processed" => {
                                    _serde::__private::Ok(__Field::__field3)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<
                            DeleteDictionaryProgressData,
                        >,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DeleteDictionaryProgressData;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DeleteDictionaryProgressData",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                u64,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DeleteDictionaryProgressData with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                u64,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct DeleteDictionaryProgressData with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                u16,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct DeleteDictionaryProgressData with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match _serde::de::SeqAccess::next_element::<
                                u64,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct DeleteDictionaryProgressData with 4 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DeleteDictionaryProgressData {
                                count: __field0,
                                processed: __field1,
                                store_count: __field2,
                                stores_processed: __field3,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<u64> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<u64> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<u16> = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<u64> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("count"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "processed",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "store_count",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<u16>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "stores_processed",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("count")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("processed")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("store_count")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("stores_processed")?
                                }
                            };
                            _serde::__private::Ok(DeleteDictionaryProgressData {
                                count: __field0,
                                processed: __field1,
                                store_count: __field2,
                                stores_processed: __field3,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "count",
                        "processed",
                        "store_count",
                        "stores_processed",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DeleteDictionaryProgressData",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                DeleteDictionaryProgressData,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[error("queries returned None:\n {queries:#?}\n reason: {reason}")]
        pub struct QueryRequestError {
            queries: Vec<QueryRequestMatchType>,
            reason: Box<native_db::db_type::Error>,
        }
        #[allow(unused_qualifications)]
        #[automatically_derived]
        impl ::thiserror::__private::Error for QueryRequestError {}
        #[allow(unused_qualifications)]
        #[automatically_derived]
        impl ::core::fmt::Display for QueryRequestError {
            #[allow(clippy::used_underscore_binding)]
            fn fmt(
                &self,
                __formatter: &mut ::core::fmt::Formatter,
            ) -> ::core::fmt::Result {
                use ::thiserror::__private::AsDisplay as _;
                #[allow(unused_variables, deprecated)]
                let Self { queries, reason } = self;
                match (queries, reason.as_display()) {
                    (__field_queries, __display_reason) => {
                        __formatter
                            .write_fmt(
                                format_args!(
                                    "queries returned None:\n {0:#?}\n reason: {1}",
                                    __field_queries,
                                    __display_reason,
                                ),
                            )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for QueryRequestError {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "QueryRequestError",
                    "queries",
                    &self.queries,
                    "reason",
                    &&self.reason,
                )
            }
        }
        pub enum QueryRequestMatchType {
            TermExactQueryRequest(TermExactQueryRequest),
            GenericQueryRequest(GenericQueryRequest),
        }
        #[automatically_derived]
        impl ::core::clone::Clone for QueryRequestMatchType {
            #[inline]
            fn clone(&self) -> QueryRequestMatchType {
                match self {
                    QueryRequestMatchType::TermExactQueryRequest(__self_0) => {
                        QueryRequestMatchType::TermExactQueryRequest(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    QueryRequestMatchType::GenericQueryRequest(__self_0) => {
                        QueryRequestMatchType::GenericQueryRequest(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for QueryRequestMatchType {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    QueryRequestMatchType::TermExactQueryRequest(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "TermExactQueryRequest",
                            &__self_0,
                        )
                    }
                    QueryRequestMatchType::GenericQueryRequest(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "GenericQueryRequest",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for QueryRequestMatchType {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for QueryRequestMatchType {
            #[inline]
            fn eq(&self, other: &QueryRequestMatchType) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
                    && match (self, other) {
                        (
                            QueryRequestMatchType::TermExactQueryRequest(__self_0),
                            QueryRequestMatchType::TermExactQueryRequest(__arg1_0),
                        ) => __self_0 == __arg1_0,
                        (
                            QueryRequestMatchType::GenericQueryRequest(__self_0),
                            QueryRequestMatchType::GenericQueryRequest(__arg1_0),
                        ) => __self_0 == __arg1_0,
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for QueryRequestMatchType {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<TermExactQueryRequest>;
                let _: ::core::cmp::AssertParamIsEq<GenericQueryRequest>;
            }
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for QueryRequestMatchType {
            #[inline]
            fn partial_cmp(
                &self,
                other: &QueryRequestMatchType,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                match (self, other) {
                    (
                        QueryRequestMatchType::TermExactQueryRequest(__self_0),
                        QueryRequestMatchType::TermExactQueryRequest(__arg1_0),
                    ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                    (
                        QueryRequestMatchType::GenericQueryRequest(__self_0),
                        QueryRequestMatchType::GenericQueryRequest(__arg1_0),
                    ) => ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0),
                    _ => {
                        ::core::cmp::PartialOrd::partial_cmp(
                            &__self_discr,
                            &__arg1_discr,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for QueryRequestMatchType {
            #[inline]
            fn cmp(&self, other: &QueryRequestMatchType) -> ::core::cmp::Ordering {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                match ::core::cmp::Ord::cmp(&__self_discr, &__arg1_discr) {
                    ::core::cmp::Ordering::Equal => {
                        match (self, other) {
                            (
                                QueryRequestMatchType::TermExactQueryRequest(__self_0),
                                QueryRequestMatchType::TermExactQueryRequest(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (
                                QueryRequestMatchType::GenericQueryRequest(__self_0),
                                QueryRequestMatchType::GenericQueryRequest(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() }
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for QueryRequestMatchType {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_discr, state);
                match self {
                    QueryRequestMatchType::TermExactQueryRequest(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    QueryRequestMatchType::GenericQueryRequest(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                }
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for QueryRequestMatchType {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        QueryRequestMatchType::TermExactQueryRequest(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "QueryRequestMatchType",
                                0u32,
                                "TermExactQueryRequest",
                                __field0,
                            )
                        }
                        QueryRequestMatchType::GenericQueryRequest(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "QueryRequestMatchType",
                                1u32,
                                "GenericQueryRequest",
                                __field0,
                            )
                        }
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for QueryRequestMatchType {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 2",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "TermExactQueryRequest" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                "GenericQueryRequest" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"TermExactQueryRequest" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                b"GenericQueryRequest" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<QueryRequestMatchType>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = QueryRequestMatchType;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum QueryRequestMatchType",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            TermExactQueryRequest,
                                        >(__variant),
                                        QueryRequestMatchType::TermExactQueryRequest,
                                    )
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            GenericQueryRequest,
                                        >(__variant),
                                        QueryRequestMatchType::GenericQueryRequest,
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &[
                        "TermExactQueryRequest",
                        "GenericQueryRequest",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "QueryRequestMatchType",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                QueryRequestMatchType,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        pub enum DictionaryDatabaseError {
            #[error("database error: {0}")]
            Database(#[from] Box<native_db::db_type::Error>),
            #[error("failed to find terms: {0}")]
            QueryRequest(#[from] QueryRequestError),
            #[error("incorrect variant(s) passed: {wrong:#?}\nexpected: {expected:#?}")]
            WrongQueryRequestMatchType {
                wrong: QueryRequestMatchType,
                expected: QueryRequestMatchType,
            },
        }
        #[allow(unused_qualifications)]
        #[automatically_derived]
        impl ::thiserror::__private::Error for DictionaryDatabaseError {
            fn source(
                &self,
            ) -> ::core::option::Option<&(dyn ::thiserror::__private::Error + 'static)> {
                use ::thiserror::__private::AsDynError as _;
                #[allow(deprecated)]
                match self {
                    DictionaryDatabaseError::Database { 0: source, .. } => {
                        ::core::option::Option::Some(source.as_dyn_error())
                    }
                    DictionaryDatabaseError::QueryRequest { 0: source, .. } => {
                        ::core::option::Option::Some(source.as_dyn_error())
                    }
                    DictionaryDatabaseError::WrongQueryRequestMatchType { .. } => {
                        ::core::option::Option::None
                    }
                }
            }
        }
        #[allow(unused_qualifications)]
        #[automatically_derived]
        impl ::core::fmt::Display for DictionaryDatabaseError {
            fn fmt(
                &self,
                __formatter: &mut ::core::fmt::Formatter,
            ) -> ::core::fmt::Result {
                use ::thiserror::__private::AsDisplay as _;
                #[allow(unused_variables, deprecated, clippy::used_underscore_binding)]
                match self {
                    DictionaryDatabaseError::Database(_0) => {
                        match (_0.as_display(),) {
                            (__display0,) => {
                                __formatter
                                    .write_fmt(format_args!("database error: {0}", __display0))
                            }
                        }
                    }
                    DictionaryDatabaseError::QueryRequest(_0) => {
                        match (_0.as_display(),) {
                            (__display0,) => {
                                __formatter
                                    .write_fmt(
                                        format_args!("failed to find terms: {0}", __display0),
                                    )
                            }
                        }
                    }
                    DictionaryDatabaseError::WrongQueryRequestMatchType {
                        wrong,
                        expected,
                    } => {
                        match (wrong, expected) {
                            (__field_wrong, __field_expected) => {
                                __formatter
                                    .write_fmt(
                                        format_args!(
                                            "incorrect variant(s) passed: {0:#?}\nexpected: {1:#?}",
                                            __field_wrong,
                                            __field_expected,
                                        ),
                                    )
                            }
                        }
                    }
                }
            }
        }
        #[allow(
            deprecated,
            unused_qualifications,
            clippy::elidable_lifetime_names,
            clippy::needless_lifetimes,
        )]
        #[automatically_derived]
        impl ::core::convert::From<Box<native_db::db_type::Error>>
        for DictionaryDatabaseError {
            fn from(source: Box<native_db::db_type::Error>) -> Self {
                DictionaryDatabaseError::Database {
                    0: source,
                }
            }
        }
        #[allow(
            deprecated,
            unused_qualifications,
            clippy::elidable_lifetime_names,
            clippy::needless_lifetimes,
        )]
        #[automatically_derived]
        impl ::core::convert::From<QueryRequestError> for DictionaryDatabaseError {
            fn from(source: QueryRequestError) -> Self {
                DictionaryDatabaseError::QueryRequest {
                    0: source,
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for DictionaryDatabaseError {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    DictionaryDatabaseError::Database(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Database",
                            &__self_0,
                        )
                    }
                    DictionaryDatabaseError::QueryRequest(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "QueryRequest",
                            &__self_0,
                        )
                    }
                    DictionaryDatabaseError::WrongQueryRequestMatchType {
                        wrong: __self_0,
                        expected: __self_1,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "WrongQueryRequestMatchType",
                            "wrong",
                            __self_0,
                            "expected",
                            &__self_1,
                        )
                    }
                }
            }
        }
        pub struct TermExactQueryRequest {
            pub term: String,
            pub reading: String,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for TermExactQueryRequest {
            #[inline]
            fn clone(&self) -> TermExactQueryRequest {
                TermExactQueryRequest {
                    term: ::core::clone::Clone::clone(&self.term),
                    reading: ::core::clone::Clone::clone(&self.reading),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for TermExactQueryRequest {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "TermExactQueryRequest",
                    "term",
                    &self.term,
                    "reading",
                    &&self.reading,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for TermExactQueryRequest {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for TermExactQueryRequest {
            #[inline]
            fn eq(&self, other: &TermExactQueryRequest) -> bool {
                self.term == other.term && self.reading == other.reading
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for TermExactQueryRequest {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<String>;
            }
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for TermExactQueryRequest {
            #[inline]
            fn partial_cmp(
                &self,
                other: &TermExactQueryRequest,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                match ::core::cmp::PartialOrd::partial_cmp(&self.term, &other.term) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        ::core::cmp::PartialOrd::partial_cmp(
                            &self.reading,
                            &other.reading,
                        )
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for TermExactQueryRequest {
            #[inline]
            fn cmp(&self, other: &TermExactQueryRequest) -> ::core::cmp::Ordering {
                match ::core::cmp::Ord::cmp(&self.term, &other.term) {
                    ::core::cmp::Ordering::Equal => {
                        ::core::cmp::Ord::cmp(&self.reading, &other.reading)
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for TermExactQueryRequest {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.term, state);
                ::core::hash::Hash::hash(&self.reading, state)
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for TermExactQueryRequest {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "TermExactQueryRequest",
                        false as usize + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "term",
                        &self.term,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "reading",
                        &self.reading,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for TermExactQueryRequest {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "term" => _serde::__private::Ok(__Field::__field0),
                                "reading" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"term" => _serde::__private::Ok(__Field::__field0),
                                b"reading" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<TermExactQueryRequest>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = TermExactQueryRequest;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct TermExactQueryRequest",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct TermExactQueryRequest with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct TermExactQueryRequest with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(TermExactQueryRequest {
                                term: __field0,
                                reading: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("term"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "reading",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("term")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("reading")?
                                }
                            };
                            _serde::__private::Ok(TermExactQueryRequest {
                                term: __field0,
                                reading: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["term", "reading"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "TermExactQueryRequest",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                TermExactQueryRequest,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        pub enum QueryType {
            String(String),
            Sequence(i128),
        }
        #[automatically_derived]
        impl ::core::clone::Clone for QueryType {
            #[inline]
            fn clone(&self) -> QueryType {
                match self {
                    QueryType::String(__self_0) => {
                        QueryType::String(::core::clone::Clone::clone(__self_0))
                    }
                    QueryType::Sequence(__self_0) => {
                        QueryType::Sequence(::core::clone::Clone::clone(__self_0))
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for QueryType {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    QueryType::String(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "String",
                            &__self_0,
                        )
                    }
                    QueryType::Sequence(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Sequence",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for QueryType {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for QueryType {
            #[inline]
            fn eq(&self, other: &QueryType) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
                    && match (self, other) {
                        (QueryType::String(__self_0), QueryType::String(__arg1_0)) => {
                            __self_0 == __arg1_0
                        }
                        (
                            QueryType::Sequence(__self_0),
                            QueryType::Sequence(__arg1_0),
                        ) => __self_0 == __arg1_0,
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for QueryType {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        QueryType::String(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "QueryType",
                                0u32,
                                "String",
                                __field0,
                            )
                        }
                        QueryType::Sequence(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "QueryType",
                                1u32,
                                "Sequence",
                                __field0,
                            )
                        }
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for QueryType {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 2",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "String" => _serde::__private::Ok(__Field::__field0),
                                "Sequence" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"String" => _serde::__private::Ok(__Field::__field0),
                                b"Sequence" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<QueryType>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = QueryType;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum QueryType",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            String,
                                        >(__variant),
                                        QueryType::String,
                                    )
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            i128,
                                        >(__variant),
                                        QueryType::Sequence,
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &["String", "Sequence"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "QueryType",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<QueryType>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::cmp::Eq for QueryType {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<String>;
                let _: ::core::cmp::AssertParamIsEq<i128>;
            }
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for QueryType {
            #[inline]
            fn partial_cmp(
                &self,
                other: &QueryType,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                match (self, other) {
                    (QueryType::String(__self_0), QueryType::String(__arg1_0)) => {
                        ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                    }
                    (QueryType::Sequence(__self_0), QueryType::Sequence(__arg1_0)) => {
                        ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                    }
                    _ => {
                        ::core::cmp::PartialOrd::partial_cmp(
                            &__self_discr,
                            &__arg1_discr,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for QueryType {
            #[inline]
            fn cmp(&self, other: &QueryType) -> ::core::cmp::Ordering {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                match ::core::cmp::Ord::cmp(&__self_discr, &__arg1_discr) {
                    ::core::cmp::Ordering::Equal => {
                        match (self, other) {
                            (
                                QueryType::String(__self_0),
                                QueryType::String(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            (
                                QueryType::Sequence(__self_0),
                                QueryType::Sequence(__arg1_0),
                            ) => ::core::cmp::Ord::cmp(__self_0, __arg1_0),
                            _ => unsafe { ::core::intrinsics::unreachable() }
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for QueryType {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_discr, state);
                match self {
                    QueryType::String(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    QueryType::Sequence(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                }
            }
        }
        /// so far it seems this can be refactored to use references
        /// for now keep owned so don't have to deal with lifetimes
        pub struct GenericQueryRequest {
            pub query_type: QueryType,
            pub dictionary: String,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for GenericQueryRequest {
            #[inline]
            fn clone(&self) -> GenericQueryRequest {
                GenericQueryRequest {
                    query_type: ::core::clone::Clone::clone(&self.query_type),
                    dictionary: ::core::clone::Clone::clone(&self.dictionary),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for GenericQueryRequest {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "GenericQueryRequest",
                    "query_type",
                    &self.query_type,
                    "dictionary",
                    &&self.dictionary,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for GenericQueryRequest {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for GenericQueryRequest {
            #[inline]
            fn eq(&self, other: &GenericQueryRequest) -> bool {
                self.query_type == other.query_type
                    && self.dictionary == other.dictionary
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for GenericQueryRequest {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "GenericQueryRequest",
                        false as usize + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "query_type",
                        &self.query_type,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "dictionary",
                        &self.dictionary,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for GenericQueryRequest {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "query_type" => _serde::__private::Ok(__Field::__field0),
                                "dictionary" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"query_type" => _serde::__private::Ok(__Field::__field0),
                                b"dictionary" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<GenericQueryRequest>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = GenericQueryRequest;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct GenericQueryRequest",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                QueryType,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct GenericQueryRequest with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct GenericQueryRequest with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(GenericQueryRequest {
                                query_type: __field0,
                                dictionary: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<QueryType> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "query_type",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<QueryType>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "dictionary",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("query_type")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("dictionary")?
                                }
                            };
                            _serde::__private::Ok(GenericQueryRequest {
                                query_type: __field0,
                                dictionary: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "query_type",
                        "dictionary",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "GenericQueryRequest",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                GenericQueryRequest,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::cmp::Eq for GenericQueryRequest {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<QueryType>;
                let _: ::core::cmp::AssertParamIsEq<String>;
            }
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for GenericQueryRequest {
            #[inline]
            fn partial_cmp(
                &self,
                other: &GenericQueryRequest,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                match ::core::cmp::PartialOrd::partial_cmp(
                    &self.query_type,
                    &other.query_type,
                ) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        ::core::cmp::PartialOrd::partial_cmp(
                            &self.dictionary,
                            &other.dictionary,
                        )
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for GenericQueryRequest {
            #[inline]
            fn cmp(&self, other: &GenericQueryRequest) -> ::core::cmp::Ordering {
                match ::core::cmp::Ord::cmp(&self.query_type, &other.query_type) {
                    ::core::cmp::Ordering::Equal => {
                        ::core::cmp::Ord::cmp(&self.dictionary, &other.dictionary)
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for GenericQueryRequest {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.query_type, state);
                ::core::hash::Hash::hash(&self.dictionary, state)
            }
        }
        impl From<&TagTargetItem> for GenericQueryRequest {
            fn from(value: &TagTargetItem) -> Self {
                Self {
                    query_type: QueryType::String(value.query.clone()),
                    dictionary: value.dictionary.clone(),
                }
            }
        }
        impl From<TagTargetItem> for GenericQueryRequest {
            fn from(value: TagTargetItem) -> Self {
                Self {
                    query_type: QueryType::String(value.query),
                    dictionary: value.dictionary,
                }
            }
        }
        impl GenericQueryRequest {
            pub fn new(query_type: QueryType, dictionary: &str) -> Self {
                Self {
                    query_type,
                    dictionary: dictionary.to_string(),
                }
            }
            pub fn from_query_type_slice_to_vec(
                queries: &[QueryType],
                dictionary: &str,
            ) -> Vec<Self> {
                queries.iter().map(|q| Self::new(q.clone(), dictionary)).collect()
            }
        }
        pub struct MediaRequest {
            path: String,
            dictionary: String,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for MediaRequest {
            #[inline]
            fn clone(&self) -> MediaRequest {
                MediaRequest {
                    path: ::core::clone::Clone::clone(&self.path),
                    dictionary: ::core::clone::Clone::clone(&self.dictionary),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for MediaRequest {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "MediaRequest",
                    "path",
                    &self.path,
                    "dictionary",
                    &&self.dictionary,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for MediaRequest {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for MediaRequest {
            #[inline]
            fn eq(&self, other: &MediaRequest) -> bool {
                self.path == other.path && self.dictionary == other.dictionary
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for MediaRequest {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "MediaRequest",
                        false as usize + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "path",
                        &self.path,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "dictionary",
                        &self.dictionary,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for MediaRequest {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "path" => _serde::__private::Ok(__Field::__field0),
                                "dictionary" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"path" => _serde::__private::Ok(__Field::__field0),
                                b"dictionary" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<MediaRequest>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = MediaRequest;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct MediaRequest",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct MediaRequest with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct MediaRequest with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(MediaRequest {
                                path: __field0,
                                dictionary: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("path"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "dictionary",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("path")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("dictionary")?
                                }
                            };
                            _serde::__private::Ok(MediaRequest {
                                path: __field0,
                                dictionary: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["path", "dictionary"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "MediaRequest",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<MediaRequest>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        pub enum FindMultiBulkDataItemType {
            String(String),
        }
        #[automatically_derived]
        impl ::core::clone::Clone for FindMultiBulkDataItemType {
            #[inline]
            fn clone(&self) -> FindMultiBulkDataItemType {
                match self {
                    FindMultiBulkDataItemType::String(__self_0) => {
                        FindMultiBulkDataItemType::String(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for FindMultiBulkDataItemType {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    FindMultiBulkDataItemType::String(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "String",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for FindMultiBulkDataItemType {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for FindMultiBulkDataItemType {
            #[inline]
            fn eq(&self, other: &FindMultiBulkDataItemType) -> bool {
                match (self, other) {
                    (
                        FindMultiBulkDataItemType::String(__self_0),
                        FindMultiBulkDataItemType::String(__arg1_0),
                    ) => __self_0 == __arg1_0,
                }
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for FindMultiBulkDataItemType {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        FindMultiBulkDataItemType::String(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "FindMultiBulkDataItemType",
                                0u32,
                                "String",
                                __field0,
                            )
                        }
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for FindMultiBulkDataItemType {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 1",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "String" => _serde::__private::Ok(__Field::__field0),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"String" => _serde::__private::Ok(__Field::__field0),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<
                            FindMultiBulkDataItemType,
                        >,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = FindMultiBulkDataItemType;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum FindMultiBulkDataItemType",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            String,
                                        >(__variant),
                                        FindMultiBulkDataItemType::String,
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &["String"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "FindMultiBulkDataItemType",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                FindMultiBulkDataItemType,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        impl PartialEq<FindMultiBulkDataItemType> for String {
            fn eq(&self, other: &FindMultiBulkDataItemType) -> bool {
                match other {
                    FindMultiBulkDataItemType::String(s_other) => self == s_other,
                }
            }
        }
        pub struct FindMulitBulkData {
            item: FindMultiBulkDataItemType,
            item_index: usize,
            index_index: usize,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for FindMulitBulkData {
            #[inline]
            fn clone(&self) -> FindMulitBulkData {
                FindMulitBulkData {
                    item: ::core::clone::Clone::clone(&self.item),
                    item_index: ::core::clone::Clone::clone(&self.item_index),
                    index_index: ::core::clone::Clone::clone(&self.index_index),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for FindMulitBulkData {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "FindMulitBulkData",
                    "item",
                    &self.item,
                    "item_index",
                    &self.item_index,
                    "index_index",
                    &&self.index_index,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for FindMulitBulkData {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for FindMulitBulkData {
            #[inline]
            fn eq(&self, other: &FindMulitBulkData) -> bool {
                self.item == other.item && self.item_index == other.item_index
                    && self.index_index == other.index_index
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for FindMulitBulkData {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "FindMulitBulkData",
                        false as usize + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "item",
                        &self.item,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "item_index",
                        &self.item_index,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "index_index",
                        &self.index_index,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for FindMulitBulkData {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "item" => _serde::__private::Ok(__Field::__field0),
                                "item_index" => _serde::__private::Ok(__Field::__field1),
                                "index_index" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"item" => _serde::__private::Ok(__Field::__field0),
                                b"item_index" => _serde::__private::Ok(__Field::__field1),
                                b"index_index" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<FindMulitBulkData>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = FindMulitBulkData;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct FindMulitBulkData",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                FindMultiBulkDataItemType,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct FindMulitBulkData with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                usize,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct FindMulitBulkData with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                usize,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct FindMulitBulkData with 3 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(FindMulitBulkData {
                                item: __field0,
                                item_index: __field1,
                                index_index: __field2,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                FindMultiBulkDataItemType,
                            > = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<usize> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<usize> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("item"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                FindMultiBulkDataItemType,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "item_index",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<usize>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "index_index",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<usize>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("item")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("item_index")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("index_index")?
                                }
                            };
                            _serde::__private::Ok(FindMulitBulkData {
                                item: __field0,
                                item_index: __field1,
                                index_index: __field2,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "item",
                        "item_index",
                        "index_index",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "FindMulitBulkData",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<FindMulitBulkData>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        trait DBReadWrite {
            fn rw_insert(&self, db: Database) -> Result<(), DBError>;
        }
        pub struct DictionaryDataDetails {
            pub summary: DictionarySummary,
            pub dictionary_options: DictionaryOptions,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for DictionaryDataDetails {
            #[inline]
            fn clone(&self) -> DictionaryDataDetails {
                DictionaryDataDetails {
                    summary: ::core::clone::Clone::clone(&self.summary),
                    dictionary_options: ::core::clone::Clone::clone(
                        &self.dictionary_options,
                    ),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for DictionaryDataDetails {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "DictionaryDataDetails",
                    "summary",
                    &self.summary,
                    "dictionary_options",
                    &&self.dictionary_options,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for DictionaryDataDetails {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for DictionaryDataDetails {
            #[inline]
            fn eq(&self, other: &DictionaryDataDetails) -> bool {
                self.summary == other.summary
                    && self.dictionary_options == other.dictionary_options
            }
        }
        pub struct DatabaseDictData {
            pub tag_list: Vec<DatabaseTag>,
            pub kanji_meta_list: Vec<DatabaseMetaFrequency>,
            pub kanji_list: Vec<DatabaseKanjiEntry>,
            pub term_meta_list: Vec<DatabaseMetaMatchType>,
            pub term_list: Vec<DatabaseTermEntry>,
            pub summary: DictionarySummary,
            pub dictionary_options: DictionaryOptions,
        }
        pub enum Queries<'a, Q: AsRef<str>> {
            Exact(&'a [Q]),
            StartsWith(&'a [Q]),
        }
        #[automatically_derived]
        impl<'a, Q: ::core::clone::Clone + AsRef<str>> ::core::clone::Clone
        for Queries<'a, Q> {
            #[inline]
            fn clone(&self) -> Queries<'a, Q> {
                match self {
                    Queries::Exact(__self_0) => {
                        Queries::Exact(::core::clone::Clone::clone(__self_0))
                    }
                    Queries::StartsWith(__self_0) => {
                        Queries::StartsWith(::core::clone::Clone::clone(__self_0))
                    }
                }
            }
        }
        #[automatically_derived]
        impl<'a, Q: ::core::fmt::Debug + AsRef<str>> ::core::fmt::Debug
        for Queries<'a, Q> {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    Queries::Exact(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Exact",
                            &__self_0,
                        )
                    }
                    Queries::StartsWith(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "StartsWith",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl<'a, Q: AsRef<str>> ::core::marker::StructuralPartialEq for Queries<'a, Q> {}
        #[automatically_derived]
        impl<'a, Q: ::core::cmp::PartialEq + AsRef<str>> ::core::cmp::PartialEq
        for Queries<'a, Q> {
            #[inline]
            fn eq(&self, other: &Queries<'a, Q>) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
                    && match (self, other) {
                        (Queries::Exact(__self_0), Queries::Exact(__arg1_0)) => {
                            __self_0 == __arg1_0
                        }
                        (
                            Queries::StartsWith(__self_0),
                            Queries::StartsWith(__arg1_0),
                        ) => __self_0 == __arg1_0,
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
            }
        }
        pub trait DictionarySet: Sync + Send {
            fn has(&self, value: &str) -> bool;
        }
        use native_db::{
            db_type::KeyRange, db_type::{KeyDefinition, ToKey},
            native_model::Model as NativeDbModelTrait, Key,
        };
        use std::ops::{Bound, Deref, RangeBounds};
        use super::dictionary_importer::DictionarySummaryKey;
        /// Describes the kind of secondary key to query.
        /// This enum IS `Clone` and `Copy`.
        pub enum SecondaryKeyQueryKind {
            Expression,
            Reading,
            Sequence,
            ExpressionReverse,
            ReadingReverse,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for SecondaryKeyQueryKind {
            #[inline]
            fn clone(&self) -> SecondaryKeyQueryKind {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for SecondaryKeyQueryKind {}
        #[automatically_derived]
        impl ::core::fmt::Debug for SecondaryKeyQueryKind {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        SecondaryKeyQueryKind::Expression => "Expression",
                        SecondaryKeyQueryKind::Reading => "Reading",
                        SecondaryKeyQueryKind::Sequence => "Sequence",
                        SecondaryKeyQueryKind::ExpressionReverse => "ExpressionReverse",
                        SecondaryKeyQueryKind::ReadingReverse => "ReadingReverse",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for SecondaryKeyQueryKind {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for SecondaryKeyQueryKind {
            #[inline]
            fn eq(&self, other: &SecondaryKeyQueryKind) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for SecondaryKeyQueryKind {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::hash::Hash for SecondaryKeyQueryKind {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_discr, state)
            }
        }
        /// Identifies whether to scan the primary key or a specific kind of secondary key.
        /// This enum IS `Clone` and `Copy`.
        pub enum IndexQueryIdentifier {
            PrimaryKey,
            SecondaryKey(SecondaryKeyQueryKind),
        }
        #[automatically_derived]
        impl ::core::clone::Clone for IndexQueryIdentifier {
            #[inline]
            fn clone(&self) -> IndexQueryIdentifier {
                let _: ::core::clone::AssertParamIsClone<SecondaryKeyQueryKind>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for IndexQueryIdentifier {}
        #[automatically_derived]
        impl ::core::fmt::Debug for IndexQueryIdentifier {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    IndexQueryIdentifier::PrimaryKey => {
                        ::core::fmt::Formatter::write_str(f, "PrimaryKey")
                    }
                    IndexQueryIdentifier::SecondaryKey(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "SecondaryKey",
                            &__self_0,
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for IndexQueryIdentifier {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for IndexQueryIdentifier {
            #[inline]
            fn eq(&self, other: &IndexQueryIdentifier) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
                    && match (self, other) {
                        (
                            IndexQueryIdentifier::SecondaryKey(__self_0),
                            IndexQueryIdentifier::SecondaryKey(__arg1_0),
                        ) => __self_0 == __arg1_0,
                        _ => true,
                    }
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for IndexQueryIdentifier {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<SecondaryKeyQueryKind>;
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for IndexQueryIdentifier {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_discr, state);
                match self {
                    IndexQueryIdentifier::SecondaryKey(__self_0) => {
                        ::core::hash::Hash::hash(__self_0, state)
                    }
                    _ => {}
                }
            }
        }
        /// Represents the type of query to perform on an index.
        /// K is the type of the value used for querying (e.g., String).
        pub enum NativeDbQueryInfo<K: ToKey + Clone> {
            Exact(K),
            Prefix(K),
            Range { start: Bound<K>, end: Bound<K> },
        }
        #[automatically_derived]
        impl<K: ::core::clone::Clone + ToKey + Clone> ::core::clone::Clone
        for NativeDbQueryInfo<K> {
            #[inline]
            fn clone(&self) -> NativeDbQueryInfo<K> {
                match self {
                    NativeDbQueryInfo::Exact(__self_0) => {
                        NativeDbQueryInfo::Exact(::core::clone::Clone::clone(__self_0))
                    }
                    NativeDbQueryInfo::Prefix(__self_0) => {
                        NativeDbQueryInfo::Prefix(::core::clone::Clone::clone(__self_0))
                    }
                    NativeDbQueryInfo::Range { start: __self_0, end: __self_1 } => {
                        NativeDbQueryInfo::Range {
                            start: ::core::clone::Clone::clone(__self_0),
                            end: ::core::clone::Clone::clone(__self_1),
                        }
                    }
                }
            }
        }
        type CreateQueryFn<Item, KeyVal> = dyn Fn(
            &Item,
            IndexQueryIdentifier,
        ) -> NativeDbQueryInfo<KeyVal> + Sync + Send;
        pub struct DictionaryDatabase<'a> {
            db: Database<'a>,
            db_name: &'a str,
        }
        impl<'a> Deref for DictionaryDatabase<'a> {
            type Target = Database<'a>;
            fn deref(&self) -> &Self::Target {
                &self.db
            }
        }
        impl From<native_db::db_type::Error> for DictionaryDatabaseError {
            fn from(e: native_db::db_type::Error) -> Self {
                DictionaryDatabaseError::Database(Box::new(e))
            }
        }
        impl From<native_db::db_type::Error> for Box<DictionaryDatabaseError> {
            fn from(e: native_db::db_type::Error) -> Self {
                Box::new(DictionaryDatabaseError::Database(Box::new(e)))
            }
        }
        impl From<Box<native_db::db_type::Error>> for Box<DictionaryDatabaseError> {
            fn from(e: Box<native_db::db_type::Error>) -> Self {
                Box::new(DictionaryDatabaseError::Database(e))
            }
        }
        impl DictionaryDatabase<'_> {
            pub fn new(path: impl AsRef<Path>) -> Self {
                Self {
                    db: DBBuilder::new().create(&DB_MODELS, path).unwrap(),
                    db_name: "dict",
                }
            }
            pub fn get_dictionary_summaries(
                &self,
            ) -> Result<Vec<DictionarySummary>, Box<DictionaryDatabaseError>> {
                let rtx = self.db.r_transaction()?;
                let summaries: Result<
                    Vec<DictionarySummary>,
                    native_db::db_type::Error,
                > = rtx.scan().primary()?.all()?.collect();
                let mut summaries = summaries?;
                summaries.sort_by_key(|s| s.import_date);
                Ok(summaries)
            }
            fn get_field_from_entry<'a>(
                entry: &'a DatabaseTermEntry,
                kind: SecondaryKeyQueryKind,
            ) -> &'a str {
                match kind {
                    SecondaryKeyQueryKind::Expression => &entry.expression,
                    SecondaryKeyQueryKind::Reading => &entry.reading,
                    SecondaryKeyQueryKind::ExpressionReverse => &entry.expression_reverse,
                    SecondaryKeyQueryKind::ReadingReverse => &entry.reading_reverse,
                    SecondaryKeyQueryKind::Sequence => {
                        {
                            ::std::io::_eprint(
                                format_args!(
                                    "Unexpected SecondaryKeyQueryKind::Sequence in helper\n",
                                ),
                            );
                        };
                        ""
                    }
                }
            }
            /// Translates the JavaScript `findTermsBulk` function by implementing the query and filtering logic directly.
            ///
            /// Queries for a list of terms, matching against expression or reading fields,
            /// with support for exact, prefix, or suffix matching.
            /// Handles deduplication of results based on term ID.
            /// This version implements the query and filtering loop directly to ensure correct filtering.
            pub fn find_terms_bulk(
                &self,
                term_list_input: &[impl AsRef<str>],
                dictionaries: &impl DictionarySet,
                match_type: TermSourceMatchType,
            ) -> Result<Vec<TermEntry>, Box<DictionaryDatabaseError>> {
                let term_list_refs: Vec<&str> = term_list_input
                    .iter()
                    .map(|s| s.as_ref())
                    .collect();
                let (processed_term_list, actual_match_type_for_query) = match match_type {
                    TermSourceMatchType::Suffix => {
                        (
                            term_list_refs
                                .iter()
                                .map(|s| s.chars().rev().collect::<String>())
                                .collect::<Vec<String>>(),
                            TermSourceMatchType::Prefix,
                        )
                    }
                    _ => {
                        (
                            term_list_refs.iter().map(|s| s.to_string()).collect(),
                            match_type,
                        )
                    }
                };
                let index_kinds_to_query: [(SecondaryKeyQueryKind, usize); 2] = match match_type {
                    TermSourceMatchType::Suffix => {
                        [
                            (SecondaryKeyQueryKind::ExpressionReverse, 0),
                            (SecondaryKeyQueryKind::ReadingReverse, 1),
                        ]
                    }
                    _ => {
                        [
                            (SecondaryKeyQueryKind::Expression, 0),
                            (SecondaryKeyQueryKind::Reading, 1),
                        ]
                    }
                };
                let r_txn = self.db.r_transaction()?;
                let mut all_final_results: Vec<TermEntry> = Vec::new();
                let mut visited_ids: IndexSet<String> = IndexSet::new();
                for (item_idx, item_to_query) in processed_term_list.iter().enumerate() {
                    let item_string = item_to_query.as_str();
                    for (index_kind, index_kind_idx) in index_kinds_to_query
                        .iter()
                        .copied()
                    {
                        let db_key_for_query = match index_kind {
                            SecondaryKeyQueryKind::Expression => {
                                DatabaseTermEntryKey::expression
                            }
                            SecondaryKeyQueryKind::Reading => {
                                DatabaseTermEntryKey::reading
                            }
                            SecondaryKeyQueryKind::ExpressionReverse => {
                                DatabaseTermEntryKey::expression_reverse
                            }
                            SecondaryKeyQueryKind::ReadingReverse => {
                                DatabaseTermEntryKey::reading_reverse
                            }
                            SecondaryKeyQueryKind::Sequence => {
                                DatabaseTermEntryKey::sequence
                            }
                        };
                        let query_info = match actual_match_type_for_query {
                            TermSourceMatchType::Exact => {
                                NativeDbQueryInfo::Exact(item_to_query.clone())
                            }
                            _ => NativeDbQueryInfo::Prefix(item_to_query.clone()),
                        };
                        let scan_result = match query_info {
                            NativeDbQueryInfo::Exact(key_val) => {
                                r_txn
                                    .scan()
                                    .secondary::<DatabaseTermEntry>(db_key_for_query)?
                                    .range(key_val.clone()..=key_val.clone())?
                                    .collect::<Result<Vec<_>, _>>()
                            }
                            NativeDbQueryInfo::Prefix(prefix_key) => {
                                r_txn
                                    .scan()
                                    .secondary::<DatabaseTermEntry>(db_key_for_query)?
                                    .start_with(prefix_key)?
                                    .collect::<Result<Vec<_>, _>>()
                            }
                            NativeDbQueryInfo::Range { .. } => {
                                {
                                    ::std::io::_eprint(
                                        format_args!(
                                            "Unexpected Range query in find_terms_bulk_direct_query\n",
                                        ),
                                    );
                                };
                                Ok(Vec::new())
                            }
                        };
                        let current_batch_models = scan_result
                            .map_err(|e| Box::new(DictionaryDatabaseError::from(e)))?;
                        for db_model in current_batch_models {
                            if !dictionaries.has(&db_model.dictionary) {
                                continue;
                            }
                            let field_to_check = Self::get_field_from_entry(
                                &db_model,
                                index_kind,
                            );
                            let is_match = match actual_match_type_for_query {
                                TermSourceMatchType::Exact => field_to_check == item_string,
                                _ => field_to_check.starts_with(item_string),
                            };
                            if is_match {
                                let mut current_match_type_for_result = match_type;
                                let find_data = FindMulitBulkData {
                                    item: FindMultiBulkDataItemType::String(
                                        item_to_query.clone(),
                                    ),
                                    item_index: item_idx,
                                    index_index: index_kind_idx,
                                };
                                let term_entry = db_model
                                    .into_term_generic(
                                        &mut current_match_type_for_result,
                                        find_data,
                                    );
                                if visited_ids.insert(term_entry.id.clone()) {
                                    all_final_results.push(term_entry);
                                }
                            }
                        }
                    }
                }
                Ok(all_final_results)
            }
            ///
            /// Queries for a list of terms, matching against expression or reading fields,
            /// with support for exact, prefix, or suffix matching.
            /// Handles deduplication of results based on term ID.
            pub fn find_terms_exact_bulk(
                &self,
                term_list: &[TermExactQueryRequest],
                dictionaries: &impl DictionarySet,
            ) -> Result<Vec<TermEntry>, Box<DictionaryDatabaseError>> {
                let index_query_identifiers = [
                    IndexQueryIdentifier::SecondaryKey(SecondaryKeyQueryKind::Expression),
                ];
                let create_query_fn_closure = Box::new(|
                    req: &TermExactQueryRequest,
                    _idx_identifier: IndexQueryIdentifier|
                { NativeDbQueryInfo::Exact(req.term.clone()) });
                let resolve_secondary_key_fn = |kind: SecondaryKeyQueryKind| match kind {
                    SecondaryKeyQueryKind::Expression => DatabaseTermEntryKey::expression,
                    _ => {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "internal error: entered unreachable code: {0}",
                                format_args!(
                                    "Only SecondaryKeyQueryKind::Expression is expected in find_terms_exact_bulk",
                                ),
                            ),
                        );
                    }
                };
                let predicate_fn = |
                    row: &DatabaseTermEntry,
                    item_request: &TermExactQueryRequest|
                {
                    row.reading == item_request.reading
                        && dictionaries.has(&row.dictionary)
                };
                let create_result_fn = |
                    db_entry: DatabaseTermEntry,
                    _req: &TermExactQueryRequest,
                    item_idx: usize,
                    _index_kind_idx: usize,
                | -> TermEntry {
                    db_entry
                        .into_term_entry_specific(
                            TermSourceMatchSource::Term,
                            TermSourceMatchType::Exact,
                            item_idx,
                        )
                };
                match self
                    .find_multi_bulk::<
                        TermExactQueryRequest,
                        DatabaseTermEntry,
                        String,
                        DatabaseTermEntryKey,
                        TermEntry,
                        _,
                        _,
                        _,
                    >(
                        &index_query_identifiers,
                        term_list,
                        create_query_fn_closure,
                        resolve_secondary_key_fn,
                        predicate_fn,
                        create_result_fn,
                    )
                {
                    Ok(results) => Ok(results),
                    Err(reason) => {
                        Err(
                            Box::new(
                                DictionaryDatabaseError::QueryRequest(QueryRequestError {
                                    queries: term_list
                                        .to_vec()
                                        .into_iter()
                                        .map(|item_to_wrap| QueryRequestMatchType::TermExactQueryRequest(
                                            item_to_wrap,
                                        ))
                                        .collect(),
                                    reason,
                                }),
                            ),
                        )
                    }
                }
            }
            pub fn find_term_meta_bulk(
                &self,
                term_list_input: &IndexSet<impl AsRef<str> + Sync>,
                dictionaries: &(impl DictionarySet),
            ) -> Result<Vec<DatabaseTermMeta>, Box<DictionaryDatabaseError>> {
                let terms_as_strings: Vec<String> = term_list_input
                    .iter()
                    .map(|s| s.as_ref().to_string())
                    .collect();
                if terms_as_strings.is_empty() {
                    return Ok(Vec::new());
                }
                let mut all_term_meta_results: Vec<DatabaseTermMeta> = Vec::new();
                let r_txn = self.db.r_transaction()?;
                for (item_idx, term) in terms_as_strings.iter().enumerate() {
                    let freq_scan = r_txn
                        .scan()
                        .secondary::<
                            DatabaseMetaFrequency,
                        >(DatabaseMetaFrequencyKey::freq_expression)?;
                    for result in freq_scan.range(term.clone()..=term.clone())? {
                        let db_entry = result?;
                        if dictionaries.has(&db_entry.dictionary) {
                            all_term_meta_results
                                .push(DatabaseTermMeta {
                                    index: item_idx,
                                    term: db_entry.freq_expression,
                                    mode: db_entry.mode,
                                    data: MetaDataMatchType::Frequency(db_entry.data),
                                    dictionary: db_entry.dictionary,
                                });
                        }
                    }
                    let pitch_scan = r_txn
                        .scan()
                        .secondary::<
                            DatabaseMetaPitch,
                        >(DatabaseMetaPitchKey::pitch_expression)?;
                    for result in pitch_scan.range(term.clone()..=term.clone())? {
                        let db_entry = result?;
                        if dictionaries.has(&db_entry.dictionary) {
                            all_term_meta_results
                                .push(DatabaseTermMeta {
                                    index: item_idx,
                                    term: db_entry.pitch_expression,
                                    mode: db_entry.mode,
                                    data: MetaDataMatchType::Pitch(db_entry.data),
                                    dictionary: db_entry.dictionary,
                                });
                        }
                    }
                    let phonetic_scan = r_txn
                        .scan()
                        .secondary::<
                            DatabaseMetaPhonetic,
                        >(DatabaseMetaPhoneticKey::phonetic_expression)?;
                    for result in phonetic_scan.range(term.clone()..=term.clone())? {
                        let db_entry = result?;
                        if dictionaries.has(&db_entry.dictionary) {
                            all_term_meta_results
                                .push(DatabaseTermMeta {
                                    index: item_idx,
                                    term: db_entry.phonetic_expression,
                                    mode: db_entry.mode,
                                    data: MetaDataMatchType::Phonetic(db_entry.data),
                                    dictionary: db_entry.dictionary,
                                });
                        }
                    }
                }
                Ok(all_term_meta_results)
            }
            pub fn find_terms_by_sequence_bulk(
                &self,
                items_to_query_vec: Vec<GenericQueryRequest>,
            ) -> Result<Vec<TermEntry>, Box<DictionaryDatabaseError>> {
                let index_query_identifiers = [
                    IndexQueryIdentifier::SecondaryKey(SecondaryKeyQueryKind::Sequence),
                ];
                let create_query_fn_closure = Box::new(|
                    req: &GenericQueryRequest,
                    _idx_identifier: IndexQueryIdentifier|
                match req.query_type {
                    QueryType::Sequence(seq_val) => {
                        NativeDbQueryInfo::Exact(Some(seq_val))
                    }
                    _ => {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "QueryType for sequence search must be Num (i.e. Sequence)",
                                ),
                            );
                        };
                    }
                });
                let resolve_secondary_key_fn = |kind: SecondaryKeyQueryKind| match kind {
                    SecondaryKeyQueryKind::Sequence => DatabaseTermEntryKey::sequence,
                    _ => {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "internal error: entered unreachable code: {0}",
                                format_args!(
                                    "Only SecondaryKeyQueryKind::Sequence is expected in find_terms_by_sequence_bulk",
                                ),
                            ),
                        );
                    }
                };
                let predicate_fn = |
                    row: &DatabaseTermEntry,
                    current_item_request: &GenericQueryRequest|
                { row.dictionary == current_item_request.dictionary };
                let create_result_fn = |
                    db_entry: DatabaseTermEntry,
                    _req: &GenericQueryRequest,
                    item_idx: usize,
                    _index_kind_idx: usize|
                {
                    db_entry
                        .into_term_entry_specific(
                            TermSourceMatchSource::Sequence,
                            TermSourceMatchType::Exact,
                            item_idx,
                        )
                };
                match self
                    .find_multi_bulk::<
                        GenericQueryRequest,
                        DatabaseTermEntry,
                        Option<i128>,
                        DatabaseTermEntryKey,
                        TermEntry,
                        _,
                        _,
                        _,
                    >(
                        &index_query_identifiers,
                        &items_to_query_vec,
                        create_query_fn_closure,
                        resolve_secondary_key_fn,
                        predicate_fn,
                        create_result_fn,
                    )
                {
                    Ok(results) => Ok(results),
                    Err(reason) => {
                        Err(
                            Box::new(
                                DictionaryDatabaseError::QueryRequest(QueryRequestError {
                                    queries: items_to_query_vec
                                        .into_iter()
                                        .map(|item_to_wrap| QueryRequestMatchType::GenericQueryRequest(
                                            item_to_wrap,
                                        ))
                                        .collect(),
                                    reason,
                                }),
                            ),
                        )
                    }
                }
            }
            pub fn find_multi_bulk<
                ItemQueryType: Sync + Send,
                M: NativeDbModelTrait + ToInput + Clone + Send + Sync + 'static,
                ModelKeyType: ToKey + Clone + Send + Sync + 'static,
                SecondaryKeyEnumType: ToKeyDefinition<KeyOptions> + Send + Sync
                    + 'static,
                QueryResultType: Send + 'static,
                ResolveSecondaryKeyFnParamType: Fn(
                        SecondaryKeyQueryKind,
                    ) -> SecondaryKeyEnumType + Sync + Send,
                PredicateFnParamType: Fn(&M, &ItemQueryType) -> bool + Sync + Send,
                CreateResultFnParamType: Fn(
                        M,
                        &ItemQueryType,
                        usize,
                        usize,
                    ) -> QueryResultType + Sync + Send,
            >(
                &self,
                index_query_identifiers: &[IndexQueryIdentifier],
                items_to_query: &[ItemQueryType],
                create_query_fn: Box<CreateQueryFn<ItemQueryType, ModelKeyType>>,
                resolve_secondary_key_fn: ResolveSecondaryKeyFnParamType,
                predicate_fn: PredicateFnParamType,
                create_result_fn: CreateResultFnParamType,
            ) -> Result<Vec<QueryResultType>, Box<native_db::db_type::Error>> {
                let r_txn = self.db.r_transaction()?;
                let mut all_final_results = Vec::new();
                for (item_idx, item_to_query) in items_to_query.iter().enumerate() {
                    for (index_kind_idx, query_identifier_ref) in index_query_identifiers
                        .iter()
                        .enumerate()
                    {
                        let query_identifier = *query_identifier_ref;
                        let query_info = create_query_fn(
                            item_to_query,
                            query_identifier,
                        );
                        let mut current_batch_models: Vec<M> = Vec::new();
                        match query_identifier {
                            IndexQueryIdentifier::PrimaryKey => {
                                let scan = r_txn.scan().primary::<M>()?;
                                match query_info {
                                    NativeDbQueryInfo::Exact(key_val) => {
                                        current_batch_models = scan
                                            .range(key_val.clone()..=key_val.clone())?
                                            .collect::<Result<Vec<M>, _>>()?;
                                    }
                                    NativeDbQueryInfo::Prefix(prefix_key) => {
                                        current_batch_models = scan
                                            .start_with(prefix_key)?
                                            .collect::<Result<Vec<M>, _>>()?;
                                    }
                                    NativeDbQueryInfo::Range { start, end } => {
                                        current_batch_models = scan
                                            .range((start, end))?
                                            .collect::<Result<Vec<M>, _>>()?;
                                    }
                                }
                            }
                            IndexQueryIdentifier::SecondaryKey(secondary_kind) => {
                                let actual_native_db_key: SecondaryKeyEnumType = resolve_secondary_key_fn(
                                    secondary_kind,
                                );
                                let scan = r_txn
                                    .scan()
                                    .secondary::<M>(actual_native_db_key)?;
                                match query_info {
                                    NativeDbQueryInfo::Exact(key_val) => {
                                        current_batch_models = scan
                                            .range(key_val.clone()..=key_val.clone())?
                                            .collect::<Result<Vec<M>, _>>()?;
                                    }
                                    NativeDbQueryInfo::Prefix(prefix_key) => {
                                        current_batch_models = scan
                                            .start_with(prefix_key)?
                                            .collect::<Result<Vec<M>, _>>()?;
                                    }
                                    NativeDbQueryInfo::Range { start, end } => {
                                        current_batch_models = scan
                                            .range((start, end))?
                                            .collect::<Result<Vec<M>, _>>()?;
                                    }
                                }
                            }
                        }
                        for db_model in current_batch_models {
                            if predicate_fn(&db_model, item_to_query) {
                                all_final_results
                                    .push(
                                        create_result_fn(
                                            db_model,
                                            item_to_query,
                                            item_idx,
                                            index_kind_idx,
                                        ),
                                    );
                            }
                        }
                    }
                }
                Ok(all_final_results)
            }
            /// Finds tag metadata for a list of tag names and their respective dictionaries.
            ///
            /// For each query in `queries`, this function attempts to find a matching tag.
            /// The result is a `Vec` of `Option<DatabaseTag>` where each element
            /// corresponds to the query at the same index. `Some(tag)` if found, `None` otherwise.
            /// [GenericQueryRequest] is `DictionaryAndQueryRequest` in yomitan JS.
            pub fn find_tag_meta_bulk(
                &self,
                queries: &[GenericQueryRequest],
            ) -> Result<Vec<Option<DatabaseTag>>, Box<DictionaryDatabaseError>> {
                if queries.is_empty() {
                    return Ok(Vec::new());
                }
                let index_query_identifiers = [
                    IndexQueryIdentifier::SecondaryKey(SecondaryKeyQueryKind::Expression),
                ];
                let create_query_fn_closure = Box::new(|
                    req: &GenericQueryRequest,
                    _idx_identifier: IndexQueryIdentifier|
                {
                    let tag_name = match &req.query_type {
                        QueryType::String(name) => name,
                        _ => {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "internal error: entered unreachable code: {0}",
                                    format_args!("you cannot pass sequences to this function"),
                                ),
                            );
                        }
                    };
                    NativeDbQueryInfo::Exact(tag_name.clone())
                });
                let resolve_secondary_key_fn = |kind: SecondaryKeyQueryKind| match kind {
                    SecondaryKeyQueryKind::Expression => DatabaseTagKey::name,
                    _ => {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "internal error: entered unreachable code: {0}",
                                format_args!(
                                    "Only Expression-like key query is expected for tag name in find_tag_meta_bulk",
                                ),
                            ),
                        );
                    }
                };
                let predicate_fn = |db_tag: &DatabaseTag, req: &GenericQueryRequest| {
                    db_tag.dictionary == req.dictionary
                };
                let create_result_fn = |
                    db_tag: DatabaseTag,
                    _req: &GenericQueryRequest,
                    item_idx: usize,
                    _index_kind_idx: usize,
                | -> (usize, DatabaseTag) {
                    (
                        item_idx,
                        DatabaseTag {
                            id: db_tag.id,
                            name: db_tag.name,
                            category: db_tag.category,
                            order: db_tag.order,
                            notes: db_tag.notes,
                            score: db_tag.score,
                            dictionary: db_tag.dictionary,
                        },
                    )
                };
                match self
                    .find_multi_bulk::<
                        GenericQueryRequest,
                        DatabaseTag,
                        String,
                        DatabaseTagKey,
                        (usize, DatabaseTag),
                        _,
                        _,
                        _,
                    >(
                        &index_query_identifiers,
                        queries,
                        create_query_fn_closure,
                        resolve_secondary_key_fn,
                        predicate_fn,
                        create_result_fn,
                    )
                {
                    Ok(found_tags_with_indices) => {
                        let mut results: Vec<Option<DatabaseTag>> = ::alloc::vec::from_elem(
                            None,
                            queries.len(),
                        );
                        for (original_idx, tag) in found_tags_with_indices {
                            if original_idx < results.len() {
                                results[original_idx] = Some(tag);
                            }
                        }
                        Ok(results)
                    }
                    Err(reason) => {
                        Err(
                            Box::new(
                                DictionaryDatabaseError::QueryRequest(QueryRequestError {
                                    queries: queries
                                        .to_vec()
                                        .into_iter()
                                        .map(|item_to_wrap| QueryRequestMatchType::GenericQueryRequest(
                                            item_to_wrap,
                                        ))
                                        .collect(),
                                    reason,
                                }),
                            ),
                        )
                    }
                }
            }
        }
        pub fn split_optional_string_field(field: Option<String>) -> Vec<String> {
            field
                .map(|s| {
                    s.split(' ')
                        .map(String::from)
                        .filter(|part| !part.is_empty())
                        .collect()
                })
                .unwrap_or_default()
        }
        pub fn split_string_field(field: String) -> Vec<String> {
            field.split(' ').map(String::from).filter(|part| !part.is_empty()).collect()
        }
    }
    pub mod dictionary_importer {
        use crate::backend::Backend;
        use crate::database::dictionary_database::{
            DatabaseDictData, DatabaseKanjiEntry, DatabaseKanjiMeta,
            DatabaseMetaFrequency, DatabaseMetaMatchType, DatabaseMetaPhonetic,
            DatabaseMetaPitch, DatabaseTermEntry, KanjiEntry,
            MediaDataArrayBufferContent, TermEntry, DB_MODELS,
        };
        use crate::dictionary::{self, KanjiDictionaryEntry};
        use crate::dictionary_data::{
            self, dictionary_data_util, DictionaryDataTag, Index, MetaDataMatchType,
            TermGlossary, TermGlossaryContent, TermGlossaryImage, TermMeta,
            TermMetaFreqDataMatchType, TermMetaFrequency, TermMetaModeType,
            TermMetaPitchData, TermV3, TermV4,
        };
        use crate::settings::{
            self, DictionaryDefinitionsCollapsible, DictionaryOptions, Options, Profile,
        };
        use crate::structured_content::{
            ContentMatchType, Element, LinkElement, StructuredContent, TermEntryItem,
        };
        use crate::errors::{DBError, DictionaryFileError, ImportError, ImportZipError};
        use crate::structured_content::EntryItemMatchType;
        use crate::Yomichan;
        use color_eyre::owo_colors::OwoColorize;
        use indexmap::IndexMap;
        use native_db::transaction::RwTransaction;
        use native_db::ToInput;
        use native_db::{
            native_db, transaction::query::PrimaryScan, Builder as DBBuilder, ToKey,
        };
        use native_model::{native_model, Model};
        use chrono::prelude::*;
        use serde::{Deserialize, Deserializer, Serialize};
        use serde_json::Deserializer as JsonDeserializer;
        use serde_untagged::UntaggedEnumVisitor;
        use rayon::prelude::*;
        use tempfile::tempdir;
        use uuid::Uuid;
        use std::collections::VecDeque;
        use std::ffi::OsString;
        use std::io::BufReader;
        use std::path::{Path, PathBuf};
        use std::rc::Rc;
        use std::sync::{
            atomic::{AtomicUsize, Ordering},
            Arc,
        };
        use std::time::Instant;
        use std::{fs, io, mem};
        use super::dictionary_database::{
            DatabaseTag, DatabaseTermMeta, DictionaryDatabase,
        };
        impl Yomichan<'_> {
            pub fn import_dictionaries<P: AsRef<Path> + Send + Sync>(
                &mut self,
                zip_paths: &[P],
            ) -> Result<(), ImportError> {
                self.backend.import_dictionaries_internal(zip_paths);
                Ok(())
            }
        }
        impl Backend<'_> {
            pub fn import_dictionaries_internal<P: AsRef<Path> + Send + Sync>(
                &mut self,
                zip_paths: &[P],
            ) -> Result<(), ImportError> {
                let settings = self.options.get_options_mut();
                let db = &self.db;
                ImportZipError::check_zip_paths(zip_paths)?;
                let options: Vec<DictionaryOptions> = zip_paths
                    .par_iter()
                    .map(|path| import_dictionary(path, settings, db))
                    .collect::<Result<Vec<DictionaryOptions>, ImportError>>()?;
                let mut options: IndexMap<String, DictionaryOptions> = options
                    .into_iter()
                    .map(|opt| (opt.name.clone(), opt))
                    .collect();
                let current_profile = settings.get_current_profile_mut();
                let mut main_dictionary = &mut current_profile
                    .options
                    .general
                    .main_dictionary;
                if main_dictionary.is_empty() {
                    *main_dictionary = options[0].name.clone();
                }
                current_profile.options.dictionaries.extend(options);
                let rwtx = db.rw_transaction()?;
                db_rwriter(
                    &rwtx,
                    <[_]>::into_vec(::alloc::boxed::box_new([settings.to_owned()])),
                );
                rwtx.commit()?;
                Ok(())
            }
        }
        pub enum ImportSteps {
            Uninitialized,
            ValidateIndex,
            ValidateSchema,
            FormatDictionary,
            ImportMedia,
            ImportData,
            Completed,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ImportSteps {
            #[inline]
            fn clone(&self) -> ImportSteps {
                match self {
                    ImportSteps::Uninitialized => ImportSteps::Uninitialized,
                    ImportSteps::ValidateIndex => ImportSteps::ValidateIndex,
                    ImportSteps::ValidateSchema => ImportSteps::ValidateSchema,
                    ImportSteps::FormatDictionary => ImportSteps::FormatDictionary,
                    ImportSteps::ImportMedia => ImportSteps::ImportMedia,
                    ImportSteps::ImportData => ImportSteps::ImportData,
                    ImportSteps::Completed => ImportSteps::Completed,
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ImportSteps {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        ImportSteps::Uninitialized => "Uninitialized",
                        ImportSteps::ValidateIndex => "ValidateIndex",
                        ImportSteps::ValidateSchema => "ValidateSchema",
                        ImportSteps::FormatDictionary => "FormatDictionary",
                        ImportSteps::ImportMedia => "ImportMedia",
                        ImportSteps::ImportData => "ImportData",
                        ImportSteps::Completed => "Completed",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for ImportSteps {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for ImportSteps {
            #[inline]
            fn eq(&self, other: &ImportSteps) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for ImportSteps {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for ImportSteps {
            #[inline]
            fn partial_cmp(
                &self,
                other: &ImportSteps,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                ::core::cmp::PartialOrd::partial_cmp(&__self_discr, &__arg1_discr)
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for ImportSteps {
            #[inline]
            fn cmp(&self, other: &ImportSteps) -> ::core::cmp::Ordering {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                ::core::cmp::Ord::cmp(&__self_discr, &__arg1_discr)
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ImportSteps {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        ImportSteps::Uninitialized => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "ImportSteps",
                                0u32,
                                "Uninitialized",
                            )
                        }
                        ImportSteps::ValidateIndex => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "ImportSteps",
                                1u32,
                                "ValidateIndex",
                            )
                        }
                        ImportSteps::ValidateSchema => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "ImportSteps",
                                2u32,
                                "ValidateSchema",
                            )
                        }
                        ImportSteps::FormatDictionary => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "ImportSteps",
                                3u32,
                                "FormatDictionary",
                            )
                        }
                        ImportSteps::ImportMedia => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "ImportSteps",
                                4u32,
                                "ImportMedia",
                            )
                        }
                        ImportSteps::ImportData => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "ImportSteps",
                                5u32,
                                "ImportData",
                            )
                        }
                        ImportSteps::Completed => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "ImportSteps",
                                6u32,
                                "Completed",
                            )
                        }
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ImportSteps {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __field6,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                6u64 => _serde::__private::Ok(__Field::__field6),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 7",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "Uninitialized" => _serde::__private::Ok(__Field::__field0),
                                "ValidateIndex" => _serde::__private::Ok(__Field::__field1),
                                "ValidateSchema" => _serde::__private::Ok(__Field::__field2),
                                "FormatDictionary" => {
                                    _serde::__private::Ok(__Field::__field3)
                                }
                                "ImportMedia" => _serde::__private::Ok(__Field::__field4),
                                "ImportData" => _serde::__private::Ok(__Field::__field5),
                                "Completed" => _serde::__private::Ok(__Field::__field6),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"Uninitialized" => _serde::__private::Ok(__Field::__field0),
                                b"ValidateIndex" => _serde::__private::Ok(__Field::__field1),
                                b"ValidateSchema" => {
                                    _serde::__private::Ok(__Field::__field2)
                                }
                                b"FormatDictionary" => {
                                    _serde::__private::Ok(__Field::__field3)
                                }
                                b"ImportMedia" => _serde::__private::Ok(__Field::__field4),
                                b"ImportData" => _serde::__private::Ok(__Field::__field5),
                                b"Completed" => _serde::__private::Ok(__Field::__field6),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ImportSteps>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ImportSteps;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum ImportSteps",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(ImportSteps::Uninitialized)
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(ImportSteps::ValidateIndex)
                                }
                                (__Field::__field2, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(ImportSteps::ValidateSchema)
                                }
                                (__Field::__field3, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(ImportSteps::FormatDictionary)
                                }
                                (__Field::__field4, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(ImportSteps::ImportMedia)
                                }
                                (__Field::__field5, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(ImportSteps::ImportData)
                                }
                                (__Field::__field6, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(ImportSteps::Completed)
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &[
                        "Uninitialized",
                        "ValidateIndex",
                        "ValidateSchema",
                        "FormatDictionary",
                        "ImportMedia",
                        "ImportData",
                        "Completed",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "ImportSteps",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<ImportSteps>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[allow(clippy::enum_variant_names)]
        pub enum CompiledSchemaNames {
            TermBank,
            /// Metadata & information for terms.
            ///
            /// This currently includes `frequency data` and `pitch accent` data.
            TermMetaBank,
            KanjiBank,
            KanjiMetaBank,
            /// Data file containing tag information for terms and kanji.
            TagBank,
        }
        #[automatically_derived]
        #[allow(clippy::enum_variant_names)]
        impl ::core::clone::Clone for CompiledSchemaNames {
            #[inline]
            fn clone(&self) -> CompiledSchemaNames {
                *self
            }
        }
        #[automatically_derived]
        #[allow(clippy::enum_variant_names)]
        impl ::core::marker::Copy for CompiledSchemaNames {}
        #[automatically_derived]
        #[allow(clippy::enum_variant_names)]
        impl ::core::fmt::Debug for CompiledSchemaNames {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        CompiledSchemaNames::TermBank => "TermBank",
                        CompiledSchemaNames::TermMetaBank => "TermMetaBank",
                        CompiledSchemaNames::KanjiBank => "KanjiBank",
                        CompiledSchemaNames::KanjiMetaBank => "KanjiMetaBank",
                        CompiledSchemaNames::TagBank => "TagBank",
                    },
                )
            }
        }
        #[automatically_derived]
        #[allow(clippy::enum_variant_names)]
        impl ::core::marker::StructuralPartialEq for CompiledSchemaNames {}
        #[automatically_derived]
        #[allow(clippy::enum_variant_names)]
        impl ::core::cmp::PartialEq for CompiledSchemaNames {
            #[inline]
            fn eq(&self, other: &CompiledSchemaNames) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        #[allow(clippy::enum_variant_names)]
        impl ::core::cmp::Eq for CompiledSchemaNames {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        #[allow(clippy::enum_variant_names)]
        impl ::core::cmp::PartialOrd for CompiledSchemaNames {
            #[inline]
            fn partial_cmp(
                &self,
                other: &CompiledSchemaNames,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                ::core::cmp::PartialOrd::partial_cmp(&__self_discr, &__arg1_discr)
            }
        }
        #[automatically_derived]
        #[allow(clippy::enum_variant_names)]
        impl ::core::cmp::Ord for CompiledSchemaNames {
            #[inline]
            fn cmp(&self, other: &CompiledSchemaNames) -> ::core::cmp::Ordering {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                ::core::cmp::Ord::cmp(&__self_discr, &__arg1_discr)
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for CompiledSchemaNames {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        CompiledSchemaNames::TermBank => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "CompiledSchemaNames",
                                0u32,
                                "TermBank",
                            )
                        }
                        CompiledSchemaNames::TermMetaBank => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "CompiledSchemaNames",
                                1u32,
                                "TermMetaBank",
                            )
                        }
                        CompiledSchemaNames::KanjiBank => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "CompiledSchemaNames",
                                2u32,
                                "KanjiBank",
                            )
                        }
                        CompiledSchemaNames::KanjiMetaBank => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "CompiledSchemaNames",
                                3u32,
                                "KanjiMetaBank",
                            )
                        }
                        CompiledSchemaNames::TagBank => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "CompiledSchemaNames",
                                4u32,
                                "TagBank",
                            )
                        }
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for CompiledSchemaNames {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 5",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "TermBank" => _serde::__private::Ok(__Field::__field0),
                                "TermMetaBank" => _serde::__private::Ok(__Field::__field1),
                                "KanjiBank" => _serde::__private::Ok(__Field::__field2),
                                "KanjiMetaBank" => _serde::__private::Ok(__Field::__field3),
                                "TagBank" => _serde::__private::Ok(__Field::__field4),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"TermBank" => _serde::__private::Ok(__Field::__field0),
                                b"TermMetaBank" => _serde::__private::Ok(__Field::__field1),
                                b"KanjiBank" => _serde::__private::Ok(__Field::__field2),
                                b"KanjiMetaBank" => _serde::__private::Ok(__Field::__field3),
                                b"TagBank" => _serde::__private::Ok(__Field::__field4),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<CompiledSchemaNames>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = CompiledSchemaNames;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum CompiledSchemaNames",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(CompiledSchemaNames::TermBank)
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(CompiledSchemaNames::TermMetaBank)
                                }
                                (__Field::__field2, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(CompiledSchemaNames::KanjiBank)
                                }
                                (__Field::__field3, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(CompiledSchemaNames::KanjiMetaBank)
                                }
                                (__Field::__field4, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(CompiledSchemaNames::TagBank)
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &[
                        "TermBank",
                        "TermMetaBank",
                        "KanjiBank",
                        "KanjiMetaBank",
                        "TagBank",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "CompiledSchemaNames",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                CompiledSchemaNames,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        pub struct ImportResult {
            result: Option<DictionarySummary>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ImportResult {
            #[inline]
            fn clone(&self) -> ImportResult {
                ImportResult {
                    result: ::core::clone::Clone::clone(&self.result),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ImportResult {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "ImportResult",
                    "result",
                    &&self.result,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for ImportResult {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for ImportResult {
            #[inline]
            fn eq(&self, other: &ImportResult) -> bool {
                self.result == other.result
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ImportResult {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "ImportResult",
                        false as usize + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "result",
                        &self.result,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ImportResult {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "result" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"result" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ImportResult>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ImportResult;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct ImportResult",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                Option<DictionarySummary>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct ImportResult with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(ImportResult { result: __field0 })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                Option<DictionarySummary>,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("result"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<DictionarySummary>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("result")?
                                }
                            };
                            _serde::__private::Ok(ImportResult { result: __field0 })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["result"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "ImportResult",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<ImportResult>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        pub struct ImportDetails {
            prefix_wildcards_supported: bool,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ImportDetails {
            #[inline]
            fn clone(&self) -> ImportDetails {
                let _: ::core::clone::AssertParamIsClone<bool>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ImportDetails {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "ImportDetails",
                    "prefix_wildcards_supported",
                    &&self.prefix_wildcards_supported,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for ImportDetails {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for ImportDetails {
            #[inline]
            fn eq(&self, other: &ImportDetails) -> bool {
                self.prefix_wildcards_supported == other.prefix_wildcards_supported
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for ImportDetails {}
        #[automatically_derived]
        impl ::core::cmp::Eq for ImportDetails {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<bool>;
            }
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for ImportDetails {
            #[inline]
            fn partial_cmp(
                &self,
                other: &ImportDetails,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(
                    &self.prefix_wildcards_supported,
                    &other.prefix_wildcards_supported,
                )
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for ImportDetails {
            #[inline]
            fn cmp(&self, other: &ImportDetails) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(
                    &self.prefix_wildcards_supported,
                    &other.prefix_wildcards_supported,
                )
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ImportDetails {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "ImportDetails",
                        false as usize + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "prefix_wildcards_supported",
                        &self.prefix_wildcards_supported,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ImportDetails {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "prefix_wildcards_supported" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"prefix_wildcards_supported" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ImportDetails>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ImportDetails;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct ImportDetails",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                bool,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct ImportDetails with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(ImportDetails {
                                prefix_wildcards_supported: __field0,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<bool> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "prefix_wildcards_supported",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field(
                                        "prefix_wildcards_supported",
                                    )?
                                }
                            };
                            _serde::__private::Ok(ImportDetails {
                                prefix_wildcards_supported: __field0,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "prefix_wildcards_supported",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "ImportDetails",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<ImportDetails>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        pub enum FrequencyMode {
            #[serde(rename = "occurrence-based")]
            OccurrenceBased,
            #[serde(rename = "rank-based")]
            RankBased,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for FrequencyMode {
            #[inline]
            fn clone(&self) -> FrequencyMode {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for FrequencyMode {}
        #[automatically_derived]
        impl ::core::fmt::Debug for FrequencyMode {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        FrequencyMode::OccurrenceBased => "OccurrenceBased",
                        FrequencyMode::RankBased => "RankBased",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for FrequencyMode {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for FrequencyMode {
            #[inline]
            fn eq(&self, other: &FrequencyMode) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for FrequencyMode {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for FrequencyMode {
            #[inline]
            fn partial_cmp(
                &self,
                other: &FrequencyMode,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                ::core::cmp::PartialOrd::partial_cmp(&__self_discr, &__arg1_discr)
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for FrequencyMode {
            #[inline]
            fn cmp(&self, other: &FrequencyMode) -> ::core::cmp::Ordering {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                ::core::cmp::Ord::cmp(&__self_discr, &__arg1_discr)
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for FrequencyMode {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_discr, state)
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for FrequencyMode {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        FrequencyMode::OccurrenceBased => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "FrequencyMode",
                                0u32,
                                "occurrence-based",
                            )
                        }
                        FrequencyMode::RankBased => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "FrequencyMode",
                                1u32,
                                "rank-based",
                            )
                        }
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for FrequencyMode {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 2",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "occurrence-based" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                "rank-based" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"occurrence-based" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                b"rank-based" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<FrequencyMode>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = FrequencyMode;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum FrequencyMode",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(FrequencyMode::OccurrenceBased)
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(FrequencyMode::RankBased)
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &[
                        "occurrence-based",
                        "rank-based",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "FrequencyMode",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<FrequencyMode>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        pub struct DictionarySummary {
            /// Name of the dictionary.
            #[primary_key]
            pub title: String,
            /// Revision of the dictionary.
            /// This value is only used for displaying information.
            pub revision: String,
            /// Whether or not this dictionary contains sequencing information for related terms.
            pub sequenced: Option<bool>,
            /// The minimum Yomitan version necessary for the dictionary to function
            pub minimum_yomitan_version: Option<String>,
            /// Format of data found in the JSON data files.
            pub version: Option<u8>,
            /// Date the dictionary was added to the db.
            pub import_date: DateTime<Local>,
            /// Whether or not wildcards can be used for the search query.
            ///
            /// Rather than searching for the source text exactly,
            /// the text will only be required to be a prefix of an existing term.
            /// For example, scanning `` will effectively search for `*`
            /// which may bring up additional results such as ``.
            pub prefix_wildcards_supported: bool,
            pub counts: SummaryCounts,
            /// Creator of the dictionary.
            pub styles: String,
            pub is_updatable: bool,
            pub index_url: Option<String>,
            pub download_url: Option<String>,
            pub author: Option<String>,
            /// URL for the source of the dictionary.
            pub url: Option<String>,
            /// Description of the dictionary data.
            pub description: Option<String>,
            /// Attribution information for the dictionary data.
            pub attribution: Option<String>,
            /// Language of the terms in the dictionary.
            #[secondary_key]
            pub source_language: Option<String>,
            /// Main language of the definitions in the dictionary.
            #[secondary_key]
            pub target_language: Option<String>,
            /// (See: [FrequencyMode])
            pub frequency_mode: Option<FrequencyMode>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for DictionarySummary {
            #[inline]
            fn clone(&self) -> DictionarySummary {
                DictionarySummary {
                    title: ::core::clone::Clone::clone(&self.title),
                    revision: ::core::clone::Clone::clone(&self.revision),
                    sequenced: ::core::clone::Clone::clone(&self.sequenced),
                    minimum_yomitan_version: ::core::clone::Clone::clone(
                        &self.minimum_yomitan_version,
                    ),
                    version: ::core::clone::Clone::clone(&self.version),
                    import_date: ::core::clone::Clone::clone(&self.import_date),
                    prefix_wildcards_supported: ::core::clone::Clone::clone(
                        &self.prefix_wildcards_supported,
                    ),
                    counts: ::core::clone::Clone::clone(&self.counts),
                    styles: ::core::clone::Clone::clone(&self.styles),
                    is_updatable: ::core::clone::Clone::clone(&self.is_updatable),
                    index_url: ::core::clone::Clone::clone(&self.index_url),
                    download_url: ::core::clone::Clone::clone(&self.download_url),
                    author: ::core::clone::Clone::clone(&self.author),
                    url: ::core::clone::Clone::clone(&self.url),
                    description: ::core::clone::Clone::clone(&self.description),
                    attribution: ::core::clone::Clone::clone(&self.attribution),
                    source_language: ::core::clone::Clone::clone(&self.source_language),
                    target_language: ::core::clone::Clone::clone(&self.target_language),
                    frequency_mode: ::core::clone::Clone::clone(&self.frequency_mode),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for DictionarySummary {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "title",
                    "revision",
                    "sequenced",
                    "minimum_yomitan_version",
                    "version",
                    "import_date",
                    "prefix_wildcards_supported",
                    "counts",
                    "styles",
                    "is_updatable",
                    "index_url",
                    "download_url",
                    "author",
                    "url",
                    "description",
                    "attribution",
                    "source_language",
                    "target_language",
                    "frequency_mode",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.title,
                    &self.revision,
                    &self.sequenced,
                    &self.minimum_yomitan_version,
                    &self.version,
                    &self.import_date,
                    &self.prefix_wildcards_supported,
                    &self.counts,
                    &self.styles,
                    &self.is_updatable,
                    &self.index_url,
                    &self.download_url,
                    &self.author,
                    &self.url,
                    &self.description,
                    &self.attribution,
                    &self.source_language,
                    &self.target_language,
                    &&self.frequency_mode,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "DictionarySummary",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for DictionarySummary {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for DictionarySummary {
            #[inline]
            fn eq(&self, other: &DictionarySummary) -> bool {
                self.title == other.title && self.revision == other.revision
                    && self.sequenced == other.sequenced
                    && self.minimum_yomitan_version == other.minimum_yomitan_version
                    && self.version == other.version
                    && self.import_date == other.import_date
                    && self.prefix_wildcards_supported
                        == other.prefix_wildcards_supported
                    && self.counts == other.counts && self.styles == other.styles
                    && self.is_updatable == other.is_updatable
                    && self.index_url == other.index_url
                    && self.download_url == other.download_url
                    && self.author == other.author && self.url == other.url
                    && self.description == other.description
                    && self.attribution == other.attribution
                    && self.source_language == other.source_language
                    && self.target_language == other.target_language
                    && self.frequency_mode == other.frequency_mode
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for DictionarySummary {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "DictionarySummary",
                        false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1
                            + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "title",
                        &self.title,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "revision",
                        &self.revision,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "sequenced",
                        &self.sequenced,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "minimum_yomitan_version",
                        &self.minimum_yomitan_version,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "version",
                        &self.version,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "import_date",
                        &self.import_date,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "prefix_wildcards_supported",
                        &self.prefix_wildcards_supported,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "counts",
                        &self.counts,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "styles",
                        &self.styles,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "is_updatable",
                        &self.is_updatable,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "index_url",
                        &self.index_url,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "download_url",
                        &self.download_url,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "author",
                        &self.author,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "url",
                        &self.url,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description",
                        &self.description,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "attribution",
                        &self.attribution,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "source_language",
                        &self.source_language,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "target_language",
                        &self.target_language,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "frequency_mode",
                        &self.frequency_mode,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DictionarySummary {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __field6,
                        __field7,
                        __field8,
                        __field9,
                        __field10,
                        __field11,
                        __field12,
                        __field13,
                        __field14,
                        __field15,
                        __field16,
                        __field17,
                        __field18,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                6u64 => _serde::__private::Ok(__Field::__field6),
                                7u64 => _serde::__private::Ok(__Field::__field7),
                                8u64 => _serde::__private::Ok(__Field::__field8),
                                9u64 => _serde::__private::Ok(__Field::__field9),
                                10u64 => _serde::__private::Ok(__Field::__field10),
                                11u64 => _serde::__private::Ok(__Field::__field11),
                                12u64 => _serde::__private::Ok(__Field::__field12),
                                13u64 => _serde::__private::Ok(__Field::__field13),
                                14u64 => _serde::__private::Ok(__Field::__field14),
                                15u64 => _serde::__private::Ok(__Field::__field15),
                                16u64 => _serde::__private::Ok(__Field::__field16),
                                17u64 => _serde::__private::Ok(__Field::__field17),
                                18u64 => _serde::__private::Ok(__Field::__field18),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "title" => _serde::__private::Ok(__Field::__field0),
                                "revision" => _serde::__private::Ok(__Field::__field1),
                                "sequenced" => _serde::__private::Ok(__Field::__field2),
                                "minimum_yomitan_version" => {
                                    _serde::__private::Ok(__Field::__field3)
                                }
                                "version" => _serde::__private::Ok(__Field::__field4),
                                "import_date" => _serde::__private::Ok(__Field::__field5),
                                "prefix_wildcards_supported" => {
                                    _serde::__private::Ok(__Field::__field6)
                                }
                                "counts" => _serde::__private::Ok(__Field::__field7),
                                "styles" => _serde::__private::Ok(__Field::__field8),
                                "is_updatable" => _serde::__private::Ok(__Field::__field9),
                                "index_url" => _serde::__private::Ok(__Field::__field10),
                                "download_url" => _serde::__private::Ok(__Field::__field11),
                                "author" => _serde::__private::Ok(__Field::__field12),
                                "url" => _serde::__private::Ok(__Field::__field13),
                                "description" => _serde::__private::Ok(__Field::__field14),
                                "attribution" => _serde::__private::Ok(__Field::__field15),
                                "source_language" => {
                                    _serde::__private::Ok(__Field::__field16)
                                }
                                "target_language" => {
                                    _serde::__private::Ok(__Field::__field17)
                                }
                                "frequency_mode" => {
                                    _serde::__private::Ok(__Field::__field18)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"title" => _serde::__private::Ok(__Field::__field0),
                                b"revision" => _serde::__private::Ok(__Field::__field1),
                                b"sequenced" => _serde::__private::Ok(__Field::__field2),
                                b"minimum_yomitan_version" => {
                                    _serde::__private::Ok(__Field::__field3)
                                }
                                b"version" => _serde::__private::Ok(__Field::__field4),
                                b"import_date" => _serde::__private::Ok(__Field::__field5),
                                b"prefix_wildcards_supported" => {
                                    _serde::__private::Ok(__Field::__field6)
                                }
                                b"counts" => _serde::__private::Ok(__Field::__field7),
                                b"styles" => _serde::__private::Ok(__Field::__field8),
                                b"is_updatable" => _serde::__private::Ok(__Field::__field9),
                                b"index_url" => _serde::__private::Ok(__Field::__field10),
                                b"download_url" => _serde::__private::Ok(__Field::__field11),
                                b"author" => _serde::__private::Ok(__Field::__field12),
                                b"url" => _serde::__private::Ok(__Field::__field13),
                                b"description" => _serde::__private::Ok(__Field::__field14),
                                b"attribution" => _serde::__private::Ok(__Field::__field15),
                                b"source_language" => {
                                    _serde::__private::Ok(__Field::__field16)
                                }
                                b"target_language" => {
                                    _serde::__private::Ok(__Field::__field17)
                                }
                                b"frequency_mode" => {
                                    _serde::__private::Ok(__Field::__field18)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DictionarySummary>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DictionarySummary;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DictionarySummary",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DictionarySummary with 19 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct DictionarySummary with 19 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                Option<bool>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct DictionarySummary with 19 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct DictionarySummary with 19 elements",
                                        ),
                                    );
                                }
                            };
                            let __field4 = match _serde::de::SeqAccess::next_element::<
                                Option<u8>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            4usize,
                                            &"struct DictionarySummary with 19 elements",
                                        ),
                                    );
                                }
                            };
                            let __field5 = match _serde::de::SeqAccess::next_element::<
                                DateTime<Local>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            5usize,
                                            &"struct DictionarySummary with 19 elements",
                                        ),
                                    );
                                }
                            };
                            let __field6 = match _serde::de::SeqAccess::next_element::<
                                bool,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            6usize,
                                            &"struct DictionarySummary with 19 elements",
                                        ),
                                    );
                                }
                            };
                            let __field7 = match _serde::de::SeqAccess::next_element::<
                                SummaryCounts,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            7usize,
                                            &"struct DictionarySummary with 19 elements",
                                        ),
                                    );
                                }
                            };
                            let __field8 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            8usize,
                                            &"struct DictionarySummary with 19 elements",
                                        ),
                                    );
                                }
                            };
                            let __field9 = match _serde::de::SeqAccess::next_element::<
                                bool,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            9usize,
                                            &"struct DictionarySummary with 19 elements",
                                        ),
                                    );
                                }
                            };
                            let __field10 = match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            10usize,
                                            &"struct DictionarySummary with 19 elements",
                                        ),
                                    );
                                }
                            };
                            let __field11 = match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            11usize,
                                            &"struct DictionarySummary with 19 elements",
                                        ),
                                    );
                                }
                            };
                            let __field12 = match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            12usize,
                                            &"struct DictionarySummary with 19 elements",
                                        ),
                                    );
                                }
                            };
                            let __field13 = match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            13usize,
                                            &"struct DictionarySummary with 19 elements",
                                        ),
                                    );
                                }
                            };
                            let __field14 = match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            14usize,
                                            &"struct DictionarySummary with 19 elements",
                                        ),
                                    );
                                }
                            };
                            let __field15 = match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            15usize,
                                            &"struct DictionarySummary with 19 elements",
                                        ),
                                    );
                                }
                            };
                            let __field16 = match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            16usize,
                                            &"struct DictionarySummary with 19 elements",
                                        ),
                                    );
                                }
                            };
                            let __field17 = match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            17usize,
                                            &"struct DictionarySummary with 19 elements",
                                        ),
                                    );
                                }
                            };
                            let __field18 = match _serde::de::SeqAccess::next_element::<
                                Option<FrequencyMode>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            18usize,
                                            &"struct DictionarySummary with 19 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DictionarySummary {
                                title: __field0,
                                revision: __field1,
                                sequenced: __field2,
                                minimum_yomitan_version: __field3,
                                version: __field4,
                                import_date: __field5,
                                prefix_wildcards_supported: __field6,
                                counts: __field7,
                                styles: __field8,
                                is_updatable: __field9,
                                index_url: __field10,
                                download_url: __field11,
                                author: __field12,
                                url: __field13,
                                description: __field14,
                                attribution: __field15,
                                source_language: __field16,
                                target_language: __field17,
                                frequency_mode: __field18,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<Option<bool>> = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<
                                Option<String>,
                            > = _serde::__private::None;
                            let mut __field4: _serde::__private::Option<Option<u8>> = _serde::__private::None;
                            let mut __field5: _serde::__private::Option<
                                DateTime<Local>,
                            > = _serde::__private::None;
                            let mut __field6: _serde::__private::Option<bool> = _serde::__private::None;
                            let mut __field7: _serde::__private::Option<SummaryCounts> = _serde::__private::None;
                            let mut __field8: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field9: _serde::__private::Option<bool> = _serde::__private::None;
                            let mut __field10: _serde::__private::Option<
                                Option<String>,
                            > = _serde::__private::None;
                            let mut __field11: _serde::__private::Option<
                                Option<String>,
                            > = _serde::__private::None;
                            let mut __field12: _serde::__private::Option<
                                Option<String>,
                            > = _serde::__private::None;
                            let mut __field13: _serde::__private::Option<
                                Option<String>,
                            > = _serde::__private::None;
                            let mut __field14: _serde::__private::Option<
                                Option<String>,
                            > = _serde::__private::None;
                            let mut __field15: _serde::__private::Option<
                                Option<String>,
                            > = _serde::__private::None;
                            let mut __field16: _serde::__private::Option<
                                Option<String>,
                            > = _serde::__private::None;
                            let mut __field17: _serde::__private::Option<
                                Option<String>,
                            > = _serde::__private::None;
                            let mut __field18: _serde::__private::Option<
                                Option<FrequencyMode>,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("title"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "revision",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "sequenced",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<bool>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "minimum_yomitan_version",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<String>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field4 => {
                                        if _serde::__private::Option::is_some(&__field4) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "version",
                                                ),
                                            );
                                        }
                                        __field4 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Option<u8>>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field5 => {
                                        if _serde::__private::Option::is_some(&__field5) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "import_date",
                                                ),
                                            );
                                        }
                                        __field5 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                DateTime<Local>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field6 => {
                                        if _serde::__private::Option::is_some(&__field6) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "prefix_wildcards_supported",
                                                ),
                                            );
                                        }
                                        __field6 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field7 => {
                                        if _serde::__private::Option::is_some(&__field7) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("counts"),
                                            );
                                        }
                                        __field7 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                SummaryCounts,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field8 => {
                                        if _serde::__private::Option::is_some(&__field8) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("styles"),
                                            );
                                        }
                                        __field8 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field9 => {
                                        if _serde::__private::Option::is_some(&__field9) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "is_updatable",
                                                ),
                                            );
                                        }
                                        __field9 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field10 => {
                                        if _serde::__private::Option::is_some(&__field10) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "index_url",
                                                ),
                                            );
                                        }
                                        __field10 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<String>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field11 => {
                                        if _serde::__private::Option::is_some(&__field11) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "download_url",
                                                ),
                                            );
                                        }
                                        __field11 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<String>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field12 => {
                                        if _serde::__private::Option::is_some(&__field12) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("author"),
                                            );
                                        }
                                        __field12 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<String>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field13 => {
                                        if _serde::__private::Option::is_some(&__field13) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("url"),
                                            );
                                        }
                                        __field13 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<String>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field14 => {
                                        if _serde::__private::Option::is_some(&__field14) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "description",
                                                ),
                                            );
                                        }
                                        __field14 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<String>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field15 => {
                                        if _serde::__private::Option::is_some(&__field15) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "attribution",
                                                ),
                                            );
                                        }
                                        __field15 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<String>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field16 => {
                                        if _serde::__private::Option::is_some(&__field16) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "source_language",
                                                ),
                                            );
                                        }
                                        __field16 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<String>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field17 => {
                                        if _serde::__private::Option::is_some(&__field17) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "target_language",
                                                ),
                                            );
                                        }
                                        __field17 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<String>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field18 => {
                                        if _serde::__private::Option::is_some(&__field18) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "frequency_mode",
                                                ),
                                            );
                                        }
                                        __field18 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<FrequencyMode>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("title")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("revision")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("sequenced")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field(
                                        "minimum_yomitan_version",
                                    )?
                                }
                            };
                            let __field4 = match __field4 {
                                _serde::__private::Some(__field4) => __field4,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("version")?
                                }
                            };
                            let __field5 = match __field5 {
                                _serde::__private::Some(__field5) => __field5,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("import_date")?
                                }
                            };
                            let __field6 = match __field6 {
                                _serde::__private::Some(__field6) => __field6,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field(
                                        "prefix_wildcards_supported",
                                    )?
                                }
                            };
                            let __field7 = match __field7 {
                                _serde::__private::Some(__field7) => __field7,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("counts")?
                                }
                            };
                            let __field8 = match __field8 {
                                _serde::__private::Some(__field8) => __field8,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("styles")?
                                }
                            };
                            let __field9 = match __field9 {
                                _serde::__private::Some(__field9) => __field9,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("is_updatable")?
                                }
                            };
                            let __field10 = match __field10 {
                                _serde::__private::Some(__field10) => __field10,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("index_url")?
                                }
                            };
                            let __field11 = match __field11 {
                                _serde::__private::Some(__field11) => __field11,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("download_url")?
                                }
                            };
                            let __field12 = match __field12 {
                                _serde::__private::Some(__field12) => __field12,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("author")?
                                }
                            };
                            let __field13 = match __field13 {
                                _serde::__private::Some(__field13) => __field13,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("url")?
                                }
                            };
                            let __field14 = match __field14 {
                                _serde::__private::Some(__field14) => __field14,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("description")?
                                }
                            };
                            let __field15 = match __field15 {
                                _serde::__private::Some(__field15) => __field15,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("attribution")?
                                }
                            };
                            let __field16 = match __field16 {
                                _serde::__private::Some(__field16) => __field16,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("source_language")?
                                }
                            };
                            let __field17 = match __field17 {
                                _serde::__private::Some(__field17) => __field17,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("target_language")?
                                }
                            };
                            let __field18 = match __field18 {
                                _serde::__private::Some(__field18) => __field18,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("frequency_mode")?
                                }
                            };
                            _serde::__private::Ok(DictionarySummary {
                                title: __field0,
                                revision: __field1,
                                sequenced: __field2,
                                minimum_yomitan_version: __field3,
                                version: __field4,
                                import_date: __field5,
                                prefix_wildcards_supported: __field6,
                                counts: __field7,
                                styles: __field8,
                                is_updatable: __field9,
                                index_url: __field10,
                                download_url: __field11,
                                author: __field12,
                                url: __field13,
                                description: __field14,
                                attribution: __field15,
                                source_language: __field16,
                                target_language: __field17,
                                frequency_mode: __field18,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "title",
                        "revision",
                        "sequenced",
                        "minimum_yomitan_version",
                        "version",
                        "import_date",
                        "prefix_wildcards_supported",
                        "counts",
                        "styles",
                        "is_updatable",
                        "index_url",
                        "download_url",
                        "author",
                        "url",
                        "description",
                        "attribution",
                        "source_language",
                        "target_language",
                        "frequency_mode",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DictionarySummary",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DictionarySummary>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        impl native_model::Model for DictionarySummary {
            fn native_model_id() -> u32 {
                1
            }
            fn native_model_id_str() -> &'static str {
                "1"
            }
            fn native_model_version() -> u32 {
                1
            }
            fn native_model_version_str() -> &'static str {
                "1"
            }
            fn native_model_encode_body(
                &self,
            ) -> std::result::Result<Vec<u8>, native_model::EncodeBodyError> {
                use native_model::Encode;
                native_model::bincode_1_3::Bincode::encode(self)
                    .map_err(|e| native_model::EncodeBodyError {
                        msg: ::alloc::__export::must_use({
                            let res = ::alloc::fmt::format(format_args!("{0}", e));
                            res
                        }),
                        source: e.into(),
                    })
            }
            fn native_model_encode_downgrade_body(
                self,
                version: u32,
            ) -> native_model::Result<Vec<u8>> {
                if version == Self::native_model_version() {
                    let result = self.native_model_encode_body()?;
                    Ok(result)
                } else if version < Self::native_model_version() {
                    Err(native_model::Error::DowngradeNotSupported {
                        from: version,
                        to: Self::native_model_version(),
                    })
                } else {
                    Err(native_model::Error::DowngradeNotSupported {
                        from: version,
                        to: Self::native_model_version(),
                    })
                }
            }
            fn native_model_decode_body(
                data: Vec<u8>,
                id: u32,
            ) -> std::result::Result<Self, native_model::DecodeBodyError> {
                if id != 1 {
                    return Err(native_model::DecodeBodyError::MismatchedModelId);
                }
                use native_model::Decode;
                native_model::bincode_1_3::Bincode::decode(data)
                    .map_err(|e| native_model::DecodeBodyError::DecodeError {
                        msg: ::alloc::__export::must_use({
                            let res = ::alloc::fmt::format(format_args!("{0}", e));
                            res
                        }),
                        source: e.into(),
                    })
            }
            fn native_model_decode_upgrade_body(
                data: Vec<u8>,
                id: u32,
                version: u32,
            ) -> native_model::Result<Self> {
                if version == Self::native_model_version() {
                    let result = Self::native_model_decode_body(data, id)?;
                    Ok(result)
                } else if version < Self::native_model_version() {
                    Err(native_model::Error::UpgradeNotSupported {
                        from: version,
                        to: Self::native_model_version(),
                    })
                } else {
                    Err(native_model::Error::UpgradeNotSupported {
                        from: version,
                        to: Self::native_model_version(),
                    })
                }
            }
        }
        impl native_db::db_type::ToInput for DictionarySummary {
            fn native_db_bincode_encode_to_vec(
                &self,
            ) -> native_db::db_type::Result<Vec<u8>> {
                native_db::bincode_encode_to_vec(self)
            }
            fn native_db_bincode_decode_from_slice(
                slice: &[u8],
            ) -> native_db::db_type::Result<Self> {
                Ok(native_db::bincode_decode_from_slice(slice)?.0)
            }
            fn native_db_model() -> native_db::Model {
                let mut secondary_tables_name = std::collections::HashSet::new();
                secondary_tables_name
                    .insert(
                        native_db::db_type::KeyDefinition::new(
                            DictionarySummary::native_model_id(),
                            DictionarySummary::native_model_version(),
                            "target_language",
                            <Option<String>>::key_names(),
                            native_db::db_type::KeyOptions {
                                unique: false,
                                optional: false,
                            },
                        ),
                    );
                secondary_tables_name
                    .insert(
                        native_db::db_type::KeyDefinition::new(
                            DictionarySummary::native_model_id(),
                            DictionarySummary::native_model_version(),
                            "source_language",
                            <Option<String>>::key_names(),
                            native_db::db_type::KeyOptions {
                                unique: false,
                                optional: false,
                            },
                        ),
                    );
                native_db::Model {
                    primary_key: native_db::db_type::KeyDefinition::new(
                        DictionarySummary::native_model_id(),
                        DictionarySummary::native_model_version(),
                        "title",
                        <String>::key_names(),
                        (),
                    ),
                    secondary_keys: secondary_tables_name,
                }
            }
            fn native_db_primary_key(&self) -> native_db::db_type::Key {
                (&self.title).to_key()
            }
            fn native_db_secondary_keys(
                &self,
            ) -> std::collections::HashMap<
                native_db::db_type::KeyDefinition<native_db::db_type::KeyOptions>,
                native_db::db_type::KeyEntry,
            > {
                let mut secondary_tables_name = std::collections::HashMap::new();
                let value: native_db::db_type::Key = (&self.target_language).to_key();
                let value = native_db::db_type::KeyEntry::Default(value);
                secondary_tables_name
                    .insert(
                        native_db::db_type::KeyDefinition::new(
                            DictionarySummary::native_model_id(),
                            DictionarySummary::native_model_version(),
                            "target_language",
                            <Option<String>>::key_names(),
                            native_db::db_type::KeyOptions {
                                unique: false,
                                optional: false,
                            },
                        ),
                        value,
                    );
                let value: native_db::db_type::Key = (&self.source_language).to_key();
                let value = native_db::db_type::KeyEntry::Default(value);
                secondary_tables_name
                    .insert(
                        native_db::db_type::KeyDefinition::new(
                            DictionarySummary::native_model_id(),
                            DictionarySummary::native_model_version(),
                            "source_language",
                            <Option<String>>::key_names(),
                            native_db::db_type::KeyOptions {
                                unique: false,
                                optional: false,
                            },
                        ),
                        value,
                    );
                secondary_tables_name
            }
        }
        #[allow(non_camel_case_types)]
        pub(crate) enum DictionarySummaryKey {
            #[allow(non_camel_case_types, dead_code)]
            target_language,
            #[allow(non_camel_case_types, dead_code)]
            source_language,
        }
        impl native_db::db_type::ToKeyDefinition<native_db::db_type::KeyOptions>
        for DictionarySummaryKey {
            fn key_definition(
                &self,
            ) -> native_db::db_type::KeyDefinition<native_db::db_type::KeyOptions> {
                match self {
                    DictionarySummaryKey::target_language => {
                        native_db::db_type::KeyDefinition::new(
                            DictionarySummary::native_model_id(),
                            DictionarySummary::native_model_version(),
                            "target_language",
                            <Option<String>>::key_names(),
                            native_db::db_type::KeyOptions {
                                unique: false,
                                optional: false,
                            },
                        )
                    }
                    DictionarySummaryKey::source_language => {
                        native_db::db_type::KeyDefinition::new(
                            DictionarySummary::native_model_id(),
                            DictionarySummary::native_model_version(),
                            "source_language",
                            <Option<String>>::key_names(),
                            native_db::db_type::KeyOptions {
                                unique: false,
                                optional: false,
                            },
                        )
                    }
                    _ => {
                        ::std::rt::begin_panic("Unknown key");
                    }
                }
            }
        }
        pub enum DictionarySummaryError {
            #[error(
                "dictionary is incompatible with current version of Yomitan: (${yomitan_version}; minimum required: ${minimum_required_yomitan_version}); dictionary: {dictionary}"
            )]
            IncompatibleYomitanVersion {
                yomitan_version: String,
                minimum_required_yomitan_version: String,
                dictionary: String,
            },
            #[error("invalid index data: `is_updatable` exists but is false")]
            InvalidIndexIsNotUpdatabale,
            #[error("index url: {url} is not a valid url\nreason: {err}")]
            InvalidIndexUrl { url: String, err: url::ParseError },
        }
        #[allow(unused_qualifications)]
        #[automatically_derived]
        impl ::thiserror::__private::Error for DictionarySummaryError {}
        #[allow(unused_qualifications)]
        #[automatically_derived]
        impl ::core::fmt::Display for DictionarySummaryError {
            fn fmt(
                &self,
                __formatter: &mut ::core::fmt::Formatter,
            ) -> ::core::fmt::Result {
                use ::thiserror::__private::AsDisplay as _;
                #[allow(unused_variables, deprecated, clippy::used_underscore_binding)]
                match self {
                    DictionarySummaryError::IncompatibleYomitanVersion {
                        yomitan_version,
                        minimum_required_yomitan_version,
                        dictionary,
                    } => {
                        match (
                            yomitan_version.as_display(),
                            minimum_required_yomitan_version.as_display(),
                            dictionary.as_display(),
                        ) {
                            (
                                __display_yomitan_version,
                                __display_minimum_required_yomitan_version,
                                __display_dictionary,
                            ) => {
                                __formatter
                                    .write_fmt(
                                        format_args!(
                                            "dictionary is incompatible with current version of Yomitan: (${0}; minimum required: ${1}); dictionary: {2}",
                                            __display_yomitan_version,
                                            __display_minimum_required_yomitan_version,
                                            __display_dictionary,
                                        ),
                                    )
                            }
                        }
                    }
                    DictionarySummaryError::InvalidIndexIsNotUpdatabale {} => {
                        __formatter
                            .write_str(
                                "invalid index data: `is_updatable` exists but is false",
                            )
                    }
                    DictionarySummaryError::InvalidIndexUrl { url, err } => {
                        match (url.as_display(), err.as_display()) {
                            (__display_url, __display_err) => {
                                __formatter
                                    .write_fmt(
                                        format_args!(
                                            "index url: {0} is not a valid url\nreason: {1}",
                                            __display_url,
                                            __display_err,
                                        ),
                                    )
                            }
                        }
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for DictionarySummaryError {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    DictionarySummaryError::IncompatibleYomitanVersion {
                        yomitan_version: __self_0,
                        minimum_required_yomitan_version: __self_1,
                        dictionary: __self_2,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field3_finish(
                            f,
                            "IncompatibleYomitanVersion",
                            "yomitan_version",
                            __self_0,
                            "minimum_required_yomitan_version",
                            __self_1,
                            "dictionary",
                            &__self_2,
                        )
                    }
                    DictionarySummaryError::InvalidIndexIsNotUpdatabale => {
                        ::core::fmt::Formatter::write_str(
                            f,
                            "InvalidIndexIsNotUpdatabale",
                        )
                    }
                    DictionarySummaryError::InvalidIndexUrl {
                        url: __self_0,
                        err: __self_1,
                    } => {
                        ::core::fmt::Formatter::debug_struct_field2_finish(
                            f,
                            "InvalidIndexUrl",
                            "url",
                            __self_0,
                            "err",
                            &__self_1,
                        )
                    }
                }
            }
        }
        impl DictionarySummary {
            fn new(
                index: Index,
                prefix_wildcards_supported: bool,
                details: SummaryDetails,
            ) -> Result<Self, DictionarySummaryError> {
                let import_date: DateTime<Local> = Local::now();
                let SummaryDetails {
                    prefix_wildcard_supported,
                    counts,
                    styles,
                    yomitan_version,
                } = details;
                let Index {
                    title,
                    revision,
                    sequenced,
                    format,
                    version,
                    minimum_yomitan_version,
                    is_updatable,
                    index_url,
                    download_url,
                    author,
                    url,
                    description,
                    attribution,
                    source_language,
                    target_language,
                    frequency_mode,
                    tag_meta,
                } = index;
                if yomitan_version == "0.0.0.0"
                {} else if let Some(minimum_yomitan_version) = &minimum_yomitan_version {
                    if dictionary_data_util::compare_revisions(
                        &yomitan_version,
                        minimum_yomitan_version,
                    ) {
                        return Err(DictionarySummaryError::IncompatibleYomitanVersion {
                            yomitan_version,
                            minimum_required_yomitan_version: minimum_yomitan_version
                                .clone(),
                            dictionary: title,
                        });
                    }
                }
                if let Some(is_updatable) = is_updatable {
                    if !is_updatable {
                        return Err(DictionarySummaryError::InvalidIndexIsNotUpdatabale);
                    }
                    if let Some(index_url) = &index_url {
                        if let Err(err) = dictionary_data_util::validate_url(index_url) {
                            return Err(DictionarySummaryError::InvalidIndexUrl {
                                url: index_url.clone(),
                                err,
                            });
                        }
                    }
                    if let Some(download_url) = &download_url {
                        if let Err(err) = dictionary_data_util::validate_url(
                            download_url,
                        ) {
                            return Err(DictionarySummaryError::InvalidIndexUrl {
                                url: download_url.clone(),
                                err,
                            });
                        }
                    }
                }
                let res = Self {
                    title,
                    revision,
                    sequenced,
                    minimum_yomitan_version,
                    version,
                    import_date,
                    prefix_wildcards_supported,
                    counts,
                    styles,
                    is_updatable: is_updatable.unwrap_or_default(),
                    index_url,
                    download_url,
                    author,
                    url,
                    description,
                    attribution,
                    source_language,
                    target_language,
                    frequency_mode,
                };
                Ok(res)
            }
        }
        pub struct SummaryDetails {
            pub prefix_wildcard_supported: bool,
            pub counts: SummaryCounts,
            pub styles: String,
            pub yomitan_version: String,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for SummaryDetails {
            #[inline]
            fn clone(&self) -> SummaryDetails {
                SummaryDetails {
                    prefix_wildcard_supported: ::core::clone::Clone::clone(
                        &self.prefix_wildcard_supported,
                    ),
                    counts: ::core::clone::Clone::clone(&self.counts),
                    styles: ::core::clone::Clone::clone(&self.styles),
                    yomitan_version: ::core::clone::Clone::clone(&self.yomitan_version),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for SummaryDetails {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "SummaryDetails",
                    "prefix_wildcard_supported",
                    &self.prefix_wildcard_supported,
                    "counts",
                    &self.counts,
                    "styles",
                    &self.styles,
                    "yomitan_version",
                    &&self.yomitan_version,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for SummaryDetails {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for SummaryDetails {
            #[inline]
            fn eq(&self, other: &SummaryDetails) -> bool {
                self.prefix_wildcard_supported == other.prefix_wildcard_supported
                    && self.counts == other.counts && self.styles == other.styles
                    && self.yomitan_version == other.yomitan_version
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for SummaryDetails {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<bool>;
                let _: ::core::cmp::AssertParamIsEq<SummaryCounts>;
                let _: ::core::cmp::AssertParamIsEq<String>;
            }
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for SummaryDetails {
            #[inline]
            fn partial_cmp(
                &self,
                other: &SummaryDetails,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                match ::core::cmp::PartialOrd::partial_cmp(
                    &self.prefix_wildcard_supported,
                    &other.prefix_wildcard_supported,
                ) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        match ::core::cmp::PartialOrd::partial_cmp(
                            &self.counts,
                            &other.counts,
                        ) {
                            ::core::option::Option::Some(
                                ::core::cmp::Ordering::Equal,
                            ) => {
                                match ::core::cmp::PartialOrd::partial_cmp(
                                    &self.styles,
                                    &other.styles,
                                ) {
                                    ::core::option::Option::Some(
                                        ::core::cmp::Ordering::Equal,
                                    ) => {
                                        ::core::cmp::PartialOrd::partial_cmp(
                                            &self.yomitan_version,
                                            &other.yomitan_version,
                                        )
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for SummaryDetails {
            #[inline]
            fn cmp(&self, other: &SummaryDetails) -> ::core::cmp::Ordering {
                match ::core::cmp::Ord::cmp(
                    &self.prefix_wildcard_supported,
                    &other.prefix_wildcard_supported,
                ) {
                    ::core::cmp::Ordering::Equal => {
                        match ::core::cmp::Ord::cmp(&self.counts, &other.counts) {
                            ::core::cmp::Ordering::Equal => {
                                match ::core::cmp::Ord::cmp(&self.styles, &other.styles) {
                                    ::core::cmp::Ordering::Equal => {
                                        ::core::cmp::Ord::cmp(
                                            &self.yomitan_version,
                                            &other.yomitan_version,
                                        )
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for SummaryDetails {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "SummaryDetails",
                        false as usize + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "prefix_wildcard_supported",
                        &self.prefix_wildcard_supported,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "counts",
                        &self.counts,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "styles",
                        &self.styles,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "yomitan_version",
                        &self.yomitan_version,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for SummaryDetails {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "prefix_wildcard_supported" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                "counts" => _serde::__private::Ok(__Field::__field1),
                                "styles" => _serde::__private::Ok(__Field::__field2),
                                "yomitan_version" => {
                                    _serde::__private::Ok(__Field::__field3)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"prefix_wildcard_supported" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                b"counts" => _serde::__private::Ok(__Field::__field1),
                                b"styles" => _serde::__private::Ok(__Field::__field2),
                                b"yomitan_version" => {
                                    _serde::__private::Ok(__Field::__field3)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<SummaryDetails>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = SummaryDetails;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct SummaryDetails",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                bool,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct SummaryDetails with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                SummaryCounts,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct SummaryDetails with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct SummaryDetails with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct SummaryDetails with 4 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(SummaryDetails {
                                prefix_wildcard_supported: __field0,
                                counts: __field1,
                                styles: __field2,
                                yomitan_version: __field3,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<bool> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<SummaryCounts> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<String> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "prefix_wildcard_supported",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("counts"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                SummaryCounts,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("styles"),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "yomitan_version",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field(
                                        "prefix_wildcard_supported",
                                    )?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("counts")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("styles")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("yomitan_version")?
                                }
                            };
                            _serde::__private::Ok(SummaryDetails {
                                prefix_wildcard_supported: __field0,
                                counts: __field1,
                                styles: __field2,
                                yomitan_version: __field3,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "prefix_wildcard_supported",
                        "counts",
                        "styles",
                        "yomitan_version",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "SummaryDetails",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<SummaryDetails>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        pub struct SummaryCounts {
            pub terms: SummaryItemCount,
            pub term_meta: SummaryMetaCount,
            pub kanji: SummaryItemCount,
            pub kanji_meta: SummaryMetaCount,
            pub tag_meta: SummaryItemCount,
            pub media: SummaryItemCount,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for SummaryCounts {
            #[inline]
            fn clone(&self) -> SummaryCounts {
                let _: ::core::clone::AssertParamIsClone<SummaryItemCount>;
                let _: ::core::clone::AssertParamIsClone<SummaryMetaCount>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for SummaryCounts {}
        #[automatically_derived]
        impl ::core::fmt::Debug for SummaryCounts {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "terms",
                    "term_meta",
                    "kanji",
                    "kanji_meta",
                    "tag_meta",
                    "media",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.terms,
                    &self.term_meta,
                    &self.kanji,
                    &self.kanji_meta,
                    &self.tag_meta,
                    &&self.media,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "SummaryCounts",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for SummaryCounts {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for SummaryCounts {
            #[inline]
            fn eq(&self, other: &SummaryCounts) -> bool {
                self.terms == other.terms && self.term_meta == other.term_meta
                    && self.kanji == other.kanji && self.kanji_meta == other.kanji_meta
                    && self.tag_meta == other.tag_meta && self.media == other.media
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for SummaryCounts {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<SummaryItemCount>;
                let _: ::core::cmp::AssertParamIsEq<SummaryMetaCount>;
            }
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for SummaryCounts {
            #[inline]
            fn partial_cmp(
                &self,
                other: &SummaryCounts,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                match ::core::cmp::PartialOrd::partial_cmp(&self.terms, &other.terms) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        match ::core::cmp::PartialOrd::partial_cmp(
                            &self.term_meta,
                            &other.term_meta,
                        ) {
                            ::core::option::Option::Some(
                                ::core::cmp::Ordering::Equal,
                            ) => {
                                match ::core::cmp::PartialOrd::partial_cmp(
                                    &self.kanji,
                                    &other.kanji,
                                ) {
                                    ::core::option::Option::Some(
                                        ::core::cmp::Ordering::Equal,
                                    ) => {
                                        match ::core::cmp::PartialOrd::partial_cmp(
                                            &self.kanji_meta,
                                            &other.kanji_meta,
                                        ) {
                                            ::core::option::Option::Some(
                                                ::core::cmp::Ordering::Equal,
                                            ) => {
                                                match ::core::cmp::PartialOrd::partial_cmp(
                                                    &self.tag_meta,
                                                    &other.tag_meta,
                                                ) {
                                                    ::core::option::Option::Some(
                                                        ::core::cmp::Ordering::Equal,
                                                    ) => {
                                                        ::core::cmp::PartialOrd::partial_cmp(
                                                            &self.media,
                                                            &other.media,
                                                        )
                                                    }
                                                    cmp => cmp,
                                                }
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for SummaryCounts {
            #[inline]
            fn cmp(&self, other: &SummaryCounts) -> ::core::cmp::Ordering {
                match ::core::cmp::Ord::cmp(&self.terms, &other.terms) {
                    ::core::cmp::Ordering::Equal => {
                        match ::core::cmp::Ord::cmp(&self.term_meta, &other.term_meta) {
                            ::core::cmp::Ordering::Equal => {
                                match ::core::cmp::Ord::cmp(&self.kanji, &other.kanji) {
                                    ::core::cmp::Ordering::Equal => {
                                        match ::core::cmp::Ord::cmp(
                                            &self.kanji_meta,
                                            &other.kanji_meta,
                                        ) {
                                            ::core::cmp::Ordering::Equal => {
                                                match ::core::cmp::Ord::cmp(
                                                    &self.tag_meta,
                                                    &other.tag_meta,
                                                ) {
                                                    ::core::cmp::Ordering::Equal => {
                                                        ::core::cmp::Ord::cmp(&self.media, &other.media)
                                                    }
                                                    cmp => cmp,
                                                }
                                            }
                                            cmp => cmp,
                                        }
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for SummaryCounts {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "SummaryCounts",
                        false as usize + 1 + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "terms",
                        &self.terms,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "term_meta",
                        &self.term_meta,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "kanji",
                        &self.kanji,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "kanji_meta",
                        &self.kanji_meta,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "tag_meta",
                        &self.tag_meta,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "media",
                        &self.media,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for SummaryCounts {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "terms" => _serde::__private::Ok(__Field::__field0),
                                "term_meta" => _serde::__private::Ok(__Field::__field1),
                                "kanji" => _serde::__private::Ok(__Field::__field2),
                                "kanji_meta" => _serde::__private::Ok(__Field::__field3),
                                "tag_meta" => _serde::__private::Ok(__Field::__field4),
                                "media" => _serde::__private::Ok(__Field::__field5),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"terms" => _serde::__private::Ok(__Field::__field0),
                                b"term_meta" => _serde::__private::Ok(__Field::__field1),
                                b"kanji" => _serde::__private::Ok(__Field::__field2),
                                b"kanji_meta" => _serde::__private::Ok(__Field::__field3),
                                b"tag_meta" => _serde::__private::Ok(__Field::__field4),
                                b"media" => _serde::__private::Ok(__Field::__field5),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<SummaryCounts>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = SummaryCounts;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct SummaryCounts",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                SummaryItemCount,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct SummaryCounts with 6 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                SummaryMetaCount,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct SummaryCounts with 6 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                SummaryItemCount,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct SummaryCounts with 6 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match _serde::de::SeqAccess::next_element::<
                                SummaryMetaCount,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct SummaryCounts with 6 elements",
                                        ),
                                    );
                                }
                            };
                            let __field4 = match _serde::de::SeqAccess::next_element::<
                                SummaryItemCount,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            4usize,
                                            &"struct SummaryCounts with 6 elements",
                                        ),
                                    );
                                }
                            };
                            let __field5 = match _serde::de::SeqAccess::next_element::<
                                SummaryItemCount,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            5usize,
                                            &"struct SummaryCounts with 6 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(SummaryCounts {
                                terms: __field0,
                                term_meta: __field1,
                                kanji: __field2,
                                kanji_meta: __field3,
                                tag_meta: __field4,
                                media: __field5,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                SummaryItemCount,
                            > = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<
                                SummaryMetaCount,
                            > = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<
                                SummaryItemCount,
                            > = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<
                                SummaryMetaCount,
                            > = _serde::__private::None;
                            let mut __field4: _serde::__private::Option<
                                SummaryItemCount,
                            > = _serde::__private::None;
                            let mut __field5: _serde::__private::Option<
                                SummaryItemCount,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("terms"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                SummaryItemCount,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "term_meta",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                SummaryMetaCount,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("kanji"),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                SummaryItemCount,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "kanji_meta",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                SummaryMetaCount,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field4 => {
                                        if _serde::__private::Option::is_some(&__field4) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "tag_meta",
                                                ),
                                            );
                                        }
                                        __field4 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                SummaryItemCount,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field5 => {
                                        if _serde::__private::Option::is_some(&__field5) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("media"),
                                            );
                                        }
                                        __field5 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                SummaryItemCount,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("terms")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("term_meta")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("kanji")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("kanji_meta")?
                                }
                            };
                            let __field4 = match __field4 {
                                _serde::__private::Some(__field4) => __field4,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("tag_meta")?
                                }
                            };
                            let __field5 = match __field5 {
                                _serde::__private::Some(__field5) => __field5,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("media")?
                                }
                            };
                            _serde::__private::Ok(SummaryCounts {
                                terms: __field0,
                                term_meta: __field1,
                                kanji: __field2,
                                kanji_meta: __field3,
                                tag_meta: __field4,
                                media: __field5,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "terms",
                        "term_meta",
                        "kanji",
                        "kanji_meta",
                        "tag_meta",
                        "media",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "SummaryCounts",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<SummaryCounts>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        impl SummaryCounts {
            fn new(
                term_len: usize,
                term_meta_len: usize,
                tag_len: usize,
                kanji_len: usize,
                kanji_meta_len: usize,
                term_meta_counts: MetaCounts,
                kanji_meta_counts: MetaCounts,
            ) -> Self {
                Self {
                    terms: SummaryItemCount {
                        total: term_len as u16,
                    },
                    term_meta: SummaryMetaCount {
                        total: term_meta_len as u16,
                        meta: term_meta_counts,
                    },
                    tag_meta: SummaryItemCount {
                        total: tag_len as u16,
                    },
                    kanji_meta: SummaryMetaCount {
                        total: kanji_meta_len as u16,
                        meta: kanji_meta_counts,
                    },
                    kanji: SummaryItemCount {
                        total: kanji_len as u16,
                    },
                    media: SummaryItemCount { total: 0 },
                }
            }
        }
        pub struct SummaryItemCount {
            pub total: u16,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for SummaryItemCount {
            #[inline]
            fn clone(&self) -> SummaryItemCount {
                let _: ::core::clone::AssertParamIsClone<u16>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for SummaryItemCount {}
        #[automatically_derived]
        impl ::core::fmt::Debug for SummaryItemCount {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "SummaryItemCount",
                    "total",
                    &&self.total,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for SummaryItemCount {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for SummaryItemCount {
            #[inline]
            fn eq(&self, other: &SummaryItemCount) -> bool {
                self.total == other.total
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for SummaryItemCount {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<u16>;
            }
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for SummaryItemCount {
            #[inline]
            fn partial_cmp(
                &self,
                other: &SummaryItemCount,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.total, &other.total)
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for SummaryItemCount {
            #[inline]
            fn cmp(&self, other: &SummaryItemCount) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.total, &other.total)
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for SummaryItemCount {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "SummaryItemCount",
                        false as usize + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "total",
                        &self.total,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for SummaryItemCount {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "total" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"total" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<SummaryItemCount>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = SummaryItemCount;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct SummaryItemCount",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                u16,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct SummaryItemCount with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(SummaryItemCount {
                                total: __field0,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<u16> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("total"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<u16>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("total")?
                                }
                            };
                            _serde::__private::Ok(SummaryItemCount {
                                total: __field0,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["total"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "SummaryItemCount",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<SummaryItemCount>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        impl SummaryItemCount {}
        pub struct SummaryMetaCount {
            pub total: u16,
            pub meta: MetaCounts,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for SummaryMetaCount {
            #[inline]
            fn clone(&self) -> SummaryMetaCount {
                let _: ::core::clone::AssertParamIsClone<u16>;
                let _: ::core::clone::AssertParamIsClone<MetaCounts>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for SummaryMetaCount {}
        #[automatically_derived]
        impl ::core::fmt::Debug for SummaryMetaCount {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "SummaryMetaCount",
                    "total",
                    &self.total,
                    "meta",
                    &&self.meta,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for SummaryMetaCount {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for SummaryMetaCount {
            #[inline]
            fn eq(&self, other: &SummaryMetaCount) -> bool {
                self.total == other.total && self.meta == other.meta
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for SummaryMetaCount {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<u16>;
                let _: ::core::cmp::AssertParamIsEq<MetaCounts>;
            }
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for SummaryMetaCount {
            #[inline]
            fn partial_cmp(
                &self,
                other: &SummaryMetaCount,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                match ::core::cmp::PartialOrd::partial_cmp(&self.total, &other.total) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        ::core::cmp::PartialOrd::partial_cmp(&self.meta, &other.meta)
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for SummaryMetaCount {
            #[inline]
            fn cmp(&self, other: &SummaryMetaCount) -> ::core::cmp::Ordering {
                match ::core::cmp::Ord::cmp(&self.total, &other.total) {
                    ::core::cmp::Ordering::Equal => {
                        ::core::cmp::Ord::cmp(&self.meta, &other.meta)
                    }
                    cmp => cmp,
                }
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for SummaryMetaCount {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "SummaryMetaCount",
                        false as usize + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "total",
                        &self.total,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "meta",
                        &self.meta,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for SummaryMetaCount {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "total" => _serde::__private::Ok(__Field::__field0),
                                "meta" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"total" => _serde::__private::Ok(__Field::__field0),
                                b"meta" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<SummaryMetaCount>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = SummaryMetaCount;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct SummaryMetaCount",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                u16,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct SummaryMetaCount with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                MetaCounts,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct SummaryMetaCount with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(SummaryMetaCount {
                                total: __field0,
                                meta: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<u16> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<MetaCounts> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("total"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<u16>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("meta"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<MetaCounts>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("total")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("meta")?
                                }
                            };
                            _serde::__private::Ok(SummaryMetaCount {
                                total: __field0,
                                meta: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["total", "meta"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "SummaryMetaCount",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<SummaryMetaCount>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        pub struct MetaCounts {
            pub freq: u32,
            pub pitch: u32,
            pub ipa: u32,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for MetaCounts {
            #[inline]
            fn clone(&self) -> MetaCounts {
                let _: ::core::clone::AssertParamIsClone<u32>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for MetaCounts {}
        #[automatically_derived]
        impl ::core::fmt::Debug for MetaCounts {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "MetaCounts",
                    "freq",
                    &self.freq,
                    "pitch",
                    &self.pitch,
                    "ipa",
                    &&self.ipa,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for MetaCounts {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for MetaCounts {
            #[inline]
            fn eq(&self, other: &MetaCounts) -> bool {
                self.freq == other.freq && self.pitch == other.pitch
                    && self.ipa == other.ipa
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for MetaCounts {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<u32>;
            }
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for MetaCounts {
            #[inline]
            fn partial_cmp(
                &self,
                other: &MetaCounts,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                match ::core::cmp::PartialOrd::partial_cmp(&self.freq, &other.freq) {
                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                        match ::core::cmp::PartialOrd::partial_cmp(
                            &self.pitch,
                            &other.pitch,
                        ) {
                            ::core::option::Option::Some(
                                ::core::cmp::Ordering::Equal,
                            ) => {
                                ::core::cmp::PartialOrd::partial_cmp(&self.ipa, &other.ipa)
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for MetaCounts {
            #[inline]
            fn cmp(&self, other: &MetaCounts) -> ::core::cmp::Ordering {
                match ::core::cmp::Ord::cmp(&self.freq, &other.freq) {
                    ::core::cmp::Ordering::Equal => {
                        match ::core::cmp::Ord::cmp(&self.pitch, &other.pitch) {
                            ::core::cmp::Ordering::Equal => {
                                ::core::cmp::Ord::cmp(&self.ipa, &other.ipa)
                            }
                            cmp => cmp,
                        }
                    }
                    cmp => cmp,
                }
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for MetaCounts {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "MetaCounts",
                        false as usize + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "freq",
                        &self.freq,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "pitch",
                        &self.pitch,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "ipa",
                        &self.ipa,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for MetaCounts {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "freq" => _serde::__private::Ok(__Field::__field0),
                                "pitch" => _serde::__private::Ok(__Field::__field1),
                                "ipa" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"freq" => _serde::__private::Ok(__Field::__field0),
                                b"pitch" => _serde::__private::Ok(__Field::__field1),
                                b"ipa" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<MetaCounts>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = MetaCounts;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct MetaCounts",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                u32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct MetaCounts with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                u32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct MetaCounts with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                u32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct MetaCounts with 3 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(MetaCounts {
                                freq: __field0,
                                pitch: __field1,
                                ipa: __field2,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<u32> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<u32> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<u32> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("freq"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<u32>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("pitch"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<u32>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("ipa"),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<u32>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("freq")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("pitch")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("ipa")?
                                }
                            };
                            _serde::__private::Ok(MetaCounts {
                                freq: __field0,
                                pitch: __field1,
                                ipa: __field2,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["freq", "pitch", "ipa"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "MetaCounts",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<MetaCounts>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::default::Default for MetaCounts {
            #[inline]
            fn default() -> MetaCounts {
                MetaCounts {
                    freq: ::core::default::Default::default(),
                    pitch: ::core::default::Default::default(),
                    ipa: ::core::default::Default::default(),
                }
            }
        }
        impl MetaCounts {
            fn count_kanji_metas(kanji_metas: &[DatabaseMetaFrequency]) -> Self {
                MetaCounts {
                    freq: kanji_metas.len() as u32,
                    ..Default::default()
                }
            }
            fn count_term_metas(metas: &[DatabaseMetaMatchType]) -> Self {
                let mut meta_counts = MetaCounts::default();
                for database_meta_match_type in metas.iter() {
                    match database_meta_match_type {
                        DatabaseMetaMatchType::Frequency(_) => meta_counts.freq += 1,
                        DatabaseMetaMatchType::Pitch(_) => meta_counts.pitch += 1,
                        DatabaseMetaMatchType::Phonetic(_) => meta_counts.ipa += 1,
                    }
                }
                meta_counts
            }
        }
        pub enum ImageImportMatchType {
            Image,
            StructuredContentImage,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ImageImportMatchType {
            #[inline]
            fn clone(&self) -> ImageImportMatchType {
                match self {
                    ImageImportMatchType::Image => ImageImportMatchType::Image,
                    ImageImportMatchType::StructuredContentImage => {
                        ImageImportMatchType::StructuredContentImage
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ImageImportMatchType {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        ImageImportMatchType::Image => "Image",
                        ImageImportMatchType::StructuredContentImage => {
                            "StructuredContentImage"
                        }
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for ImageImportMatchType {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for ImageImportMatchType {
            #[inline]
            fn eq(&self, other: &ImageImportMatchType) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ImageImportMatchType {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        ImageImportMatchType::Image => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "ImageImportMatchType",
                                0u32,
                                "Image",
                            )
                        }
                        ImageImportMatchType::StructuredContentImage => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "ImageImportMatchType",
                                1u32,
                                "StructuredContentImage",
                            )
                        }
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ImageImportMatchType {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 2",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "Image" => _serde::__private::Ok(__Field::__field0),
                                "StructuredContentImage" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"Image" => _serde::__private::Ok(__Field::__field0),
                                b"StructuredContentImage" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ImageImportMatchType>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ImageImportMatchType;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum ImageImportMatchType",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(ImageImportMatchType::Image)
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(
                                        ImageImportMatchType::StructuredContentImage,
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &[
                        "Image",
                        "StructuredContentImage",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "ImageImportMatchType",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                ImageImportMatchType,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        pub struct ImageImportRequirement {
            /// This is of type [`ImageImportType::Image`]
            image_type: ImageImportMatchType,
            target: TermGlossaryImage,
            source: TermGlossaryImage,
            entry: DatabaseTermEntry,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ImageImportRequirement {
            #[inline]
            fn clone(&self) -> ImageImportRequirement {
                ImageImportRequirement {
                    image_type: ::core::clone::Clone::clone(&self.image_type),
                    target: ::core::clone::Clone::clone(&self.target),
                    source: ::core::clone::Clone::clone(&self.source),
                    entry: ::core::clone::Clone::clone(&self.entry),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ImageImportRequirement {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "ImageImportRequirement",
                    "image_type",
                    &self.image_type,
                    "target",
                    &self.target,
                    "source",
                    &self.source,
                    "entry",
                    &&self.entry,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for ImageImportRequirement {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for ImageImportRequirement {
            #[inline]
            fn eq(&self, other: &ImageImportRequirement) -> bool {
                self.image_type == other.image_type && self.target == other.target
                    && self.source == other.source && self.entry == other.entry
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ImageImportRequirement {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "ImageImportRequirement",
                        false as usize + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "image_type",
                        &self.image_type,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "target",
                        &self.target,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "source",
                        &self.source,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "entry",
                        &self.entry,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ImageImportRequirement {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "image_type" => _serde::__private::Ok(__Field::__field0),
                                "target" => _serde::__private::Ok(__Field::__field1),
                                "source" => _serde::__private::Ok(__Field::__field2),
                                "entry" => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"image_type" => _serde::__private::Ok(__Field::__field0),
                                b"target" => _serde::__private::Ok(__Field::__field1),
                                b"source" => _serde::__private::Ok(__Field::__field2),
                                b"entry" => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ImageImportRequirement>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ImageImportRequirement;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct ImageImportRequirement",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                ImageImportMatchType,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct ImageImportRequirement with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                TermGlossaryImage,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct ImageImportRequirement with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                TermGlossaryImage,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct ImageImportRequirement with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match _serde::de::SeqAccess::next_element::<
                                DatabaseTermEntry,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct ImageImportRequirement with 4 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(ImageImportRequirement {
                                image_type: __field0,
                                target: __field1,
                                source: __field2,
                                entry: __field3,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                ImageImportMatchType,
                            > = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<
                                TermGlossaryImage,
                            > = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<
                                TermGlossaryImage,
                            > = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<
                                DatabaseTermEntry,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "image_type",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                ImageImportMatchType,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("target"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                TermGlossaryImage,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("source"),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                TermGlossaryImage,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("entry"),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                DatabaseTermEntry,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("image_type")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("target")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("source")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("entry")?
                                }
                            };
                            _serde::__private::Ok(ImageImportRequirement {
                                image_type: __field0,
                                target: __field1,
                                source: __field2,
                                entry: __field3,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "image_type",
                        "target",
                        "source",
                        "entry",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "ImageImportRequirement",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                ImageImportRequirement,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        pub struct StructuredContentImageImportRequirement {
            /// This is of type [`ImageImportType::StructuredContentImage`]
            image_type: ImageImportMatchType,
            target: TermGlossaryImage,
            source: TermGlossaryImage,
            entry: DatabaseTermEntry,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for StructuredContentImageImportRequirement {
            #[inline]
            fn clone(&self) -> StructuredContentImageImportRequirement {
                StructuredContentImageImportRequirement {
                    image_type: ::core::clone::Clone::clone(&self.image_type),
                    target: ::core::clone::Clone::clone(&self.target),
                    source: ::core::clone::Clone::clone(&self.source),
                    entry: ::core::clone::Clone::clone(&self.entry),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for StructuredContentImageImportRequirement {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "StructuredContentImageImportRequirement",
                    "image_type",
                    &self.image_type,
                    "target",
                    &self.target,
                    "source",
                    &self.source,
                    "entry",
                    &&self.entry,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq
        for StructuredContentImageImportRequirement {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for StructuredContentImageImportRequirement {
            #[inline]
            fn eq(&self, other: &StructuredContentImageImportRequirement) -> bool {
                self.image_type == other.image_type && self.target == other.target
                    && self.source == other.source && self.entry == other.entry
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for StructuredContentImageImportRequirement {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "StructuredContentImageImportRequirement",
                        false as usize + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "image_type",
                        &self.image_type,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "target",
                        &self.target,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "source",
                        &self.source,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "entry",
                        &self.entry,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de>
            for StructuredContentImageImportRequirement {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "image_type" => _serde::__private::Ok(__Field::__field0),
                                "target" => _serde::__private::Ok(__Field::__field1),
                                "source" => _serde::__private::Ok(__Field::__field2),
                                "entry" => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"image_type" => _serde::__private::Ok(__Field::__field0),
                                b"target" => _serde::__private::Ok(__Field::__field1),
                                b"source" => _serde::__private::Ok(__Field::__field2),
                                b"entry" => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<
                            StructuredContentImageImportRequirement,
                        >,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = StructuredContentImageImportRequirement;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct StructuredContentImageImportRequirement",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                ImageImportMatchType,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct StructuredContentImageImportRequirement with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                TermGlossaryImage,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct StructuredContentImageImportRequirement with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                TermGlossaryImage,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct StructuredContentImageImportRequirement with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match _serde::de::SeqAccess::next_element::<
                                DatabaseTermEntry,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct StructuredContentImageImportRequirement with 4 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(StructuredContentImageImportRequirement {
                                image_type: __field0,
                                target: __field1,
                                source: __field2,
                                entry: __field3,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                ImageImportMatchType,
                            > = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<
                                TermGlossaryImage,
                            > = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<
                                TermGlossaryImage,
                            > = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<
                                DatabaseTermEntry,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "image_type",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                ImageImportMatchType,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("target"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                TermGlossaryImage,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("source"),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                TermGlossaryImage,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("entry"),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                DatabaseTermEntry,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("image_type")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("target")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("source")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("entry")?
                                }
                            };
                            _serde::__private::Ok(StructuredContentImageImportRequirement {
                                image_type: __field0,
                                target: __field1,
                                source: __field2,
                                entry: __field3,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "image_type",
                        "target",
                        "source",
                        "entry",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "StructuredContentImageImportRequirement",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                StructuredContentImageImportRequirement,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        pub struct ImportRequirementContext {
            media: IndexMap<String, MediaDataArrayBufferContent>,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for ImportRequirementContext {
            #[inline]
            fn clone(&self) -> ImportRequirementContext {
                ImportRequirementContext {
                    media: ::core::clone::Clone::clone(&self.media),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ImportRequirementContext {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "ImportRequirementContext",
                    "media",
                    &&self.media,
                )
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for ImportRequirementContext {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for ImportRequirementContext {
            #[inline]
            fn eq(&self, other: &ImportRequirementContext) -> bool {
                self.media == other.media
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ImportRequirementContext {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "ImportRequirementContext",
                        false as usize + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "media",
                        &self.media,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ImportRequirementContext {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "media" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"media" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ImportRequirementContext>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ImportRequirementContext;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct ImportRequirementContext",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                IndexMap<String, MediaDataArrayBufferContent>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct ImportRequirementContext with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(ImportRequirementContext {
                                media: __field0,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                IndexMap<String, MediaDataArrayBufferContent>,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("media"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                IndexMap<String, MediaDataArrayBufferContent>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("media")?
                                }
                            };
                            _serde::__private::Ok(ImportRequirementContext {
                                media: __field0,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["media"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "ImportRequirementContext",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                ImportRequirementContext,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        impl<'de> Deserialize<'de> for EntryItemMatchType {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: Deserializer<'de>,
            {
                UntaggedEnumVisitor::new()
                    .string(|single| Ok(EntryItemMatchType::String(single.to_string())))
                    .i128(|int| Ok(EntryItemMatchType::Integer(int)))
                    .seq(|seq| {
                        seq.deserialize().map(EntryItemMatchType::StructuredContentVec)
                    })
                    .deserialize(deserializer)
            }
        }
        /// Deserializable type mapping a `term_bank_$i.json` file.
        pub type TermBank = Vec<TermEntryItem>;
        pub type TermMetaBank = Vec<TermMeta>;
        pub type KanjiBank = Vec<DatabaseKanjiEntry>;
        fn extract_dict_zip<P: AsRef<std::path::Path>>(
            zip_path: P,
        ) -> Result<std::path::PathBuf, ImportZipError> {
            let temp_dir = tempdir()?;
            let temp_dir_path = temp_dir.path().to_owned();
            let temp_dir_path_clone = temp_dir_path.clone();
            {
                let file = fs::File::open(zip_path)?;
                let mut archive = zip::ZipArchive::new(file)?;
                let extract_handle = std::thread::spawn(move || {
                    archive.extract(temp_dir_path_clone)
                });
                extract_handle.join().unwrap().unwrap();
            }
            temp_dir.close()?;
            Ok(temp_dir_path)
        }
        pub fn import_dictionary<P: AsRef<Path>>(
            zip_path: P,
            settings: &Options,
            db: &DictionaryDatabase,
        ) -> Result<DictionaryOptions, ImportError> {
            let data: DatabaseDictData = prepare_dictionary(zip_path, settings)?;
            let rwtx = db.rw_transaction()?;
            db_rwriter(&rwtx, data.term_list)?;
            db_rwriter(&rwtx, data.kanji_list)?;
            db_rwriter(&rwtx, data.tag_list)?;
            db_rwriter(&rwtx, data.kanji_meta_list)?;
            {
                for item in data.term_meta_list {
                    match item {
                        DatabaseMetaMatchType::Frequency(freq) => rwtx.insert(freq)?,
                        DatabaseMetaMatchType::Pitch(pitch) => rwtx.insert(pitch)?,
                        DatabaseMetaMatchType::Phonetic(ipa) => rwtx.insert(ipa)?,
                    }
                }
            }
            db_rwriter(&rwtx, <[_]>::into_vec(::alloc::boxed::box_new([data.summary])))?;
            rwtx.commit()?;
            Ok(data.dictionary_options)
        }
        fn db_rwriter<L: ToInput>(
            rwtx: &RwTransaction,
            list: Vec<L>,
        ) -> Result<(), Box<native_db::db_type::Error>> {
            for item in list {
                rwtx.insert(item)?;
            }
            Ok(())
        }
        pub fn prepare_dictionary<P: AsRef<Path>>(
            zip_path: P,
            settings: &Options,
        ) -> Result<DatabaseDictData, ImportError> {
            let mut index_path = PathBuf::new();
            let mut tag_bank_paths: Vec<PathBuf> = Vec::new();
            let mut kanji_meta_bank_paths: Vec<PathBuf> = Vec::new();
            let mut kanji_bank_paths: Vec<PathBuf> = Vec::new();
            let mut term_meta_bank_paths: Vec<PathBuf> = Vec::new();
            let mut term_bank_paths: Vec<PathBuf> = Vec::new();
            read_dir_helper(
                zip_path,
                &mut index_path,
                &mut tag_bank_paths,
                &mut kanji_meta_bank_paths,
                &mut kanji_bank_paths,
                &mut term_meta_bank_paths,
                &mut term_bank_paths,
            );
            let index: Index = convert_index_file(index_path)?;
            let dict_name = index.title.clone();
            let tag_banks: Result<Vec<Vec<DatabaseTag>>, ImportError> = convert_tag_bank_files(
                tag_bank_paths,
                &dict_name,
            );
            let tag_list: Vec<DatabaseTag> = match tag_banks {
                Ok(kml) => kml.into_iter().flatten().collect(),
                Err(e) => {
                    return Err(
                        ImportError::Custom(
                            ::alloc::__export::must_use({
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to convert tag banks | {0}", e),
                                );
                                res
                            }),
                        ),
                    );
                }
            };
            let term_banks: Result<Vec<Vec<DatabaseTermEntry>>, DictionaryFileError> = term_bank_paths
                .into_par_iter()
                .map(|path| convert_term_bank_file(path, &dict_name))
                .collect::<Result<Vec<Vec<DatabaseTermEntry>>, DictionaryFileError>>();
            let term_list: Vec<DatabaseTermEntry> = match term_banks {
                Ok(tl) => tl.into_iter().flatten().collect(),
                Err(e) => {
                    return Err(
                        ImportError::Custom(
                            ::alloc::__export::must_use({
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to convert term banks | {0}", e),
                                );
                                res
                            }),
                        ),
                    );
                }
            };
            let kanji_meta_banks: Result<
                Vec<Vec<DatabaseMetaFrequency>>,
                DictionaryFileError,
            > = kanji_meta_bank_paths
                .into_par_iter()
                .map(|path| DatabaseMetaMatchType::convert_kanji_meta_file(
                    path,
                    dict_name.clone(),
                ))
                .collect::<
                    Result<Vec<Vec<DatabaseMetaFrequency>>, DictionaryFileError>,
                >();
            let kanji_meta_list: Vec<DatabaseMetaFrequency> = match kanji_meta_banks {
                Ok(kml) => kml.into_iter().flatten().collect(),
                Err(e) => {
                    return Err(
                        ImportError::Custom(
                            ::alloc::__export::must_use({
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to convert kanji_meta_banks | {0}", e),
                                );
                                res
                            }),
                        ),
                    );
                }
            };
            let term_meta_banks: Result<
                Vec<Vec<DatabaseMetaMatchType>>,
                DictionaryFileError,
            > = term_meta_bank_paths
                .into_par_iter()
                .map(|path| DatabaseMetaMatchType::convert_term_meta_file(
                    path,
                    dict_name.clone(),
                ))
                .collect::<
                    Result<Vec<Vec<DatabaseMetaMatchType>>, DictionaryFileError>,
                >();
            let term_meta_list: Vec<DatabaseMetaMatchType> = match term_meta_banks {
                Ok(tml) => tml.into_iter().flatten().collect(),
                Err(e) => {
                    return Err(
                        ImportError::Custom(
                            ::alloc::__export::must_use({
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to convert term_meta_banks | {0}", e),
                                );
                                res
                            }),
                        ),
                    );
                }
            };
            let kanji_banks: Result<Vec<Vec<DatabaseKanjiEntry>>, DictionaryFileError> = kanji_bank_paths
                .into_iter()
                .map(|path| convert_kanji_bank(path, &dict_name))
                .collect::<Result<Vec<Vec<DatabaseKanjiEntry>>, DictionaryFileError>>();
            let kanji_list: Vec<DatabaseKanjiEntry> = match kanji_banks {
                Ok(kl) => kl.into_iter().flatten().collect(),
                Err(e) => {
                    return Err(
                        ImportError::Custom(
                            ::alloc::__export::must_use({
                                let res = ::alloc::fmt::format(
                                    format_args!("Failed to convert kanji banks | {0}", e),
                                );
                                res
                            }),
                        ),
                    );
                }
            };
            let term_meta_counts = MetaCounts::count_term_metas(&term_meta_list);
            let kanji_meta_counts = MetaCounts::count_kanji_metas(&kanji_meta_list);
            let counts = SummaryCounts::new(
                term_list.len(),
                term_meta_list.len(),
                tag_list.len(),
                kanji_meta_list.len(),
                kanji_list.len(),
                term_meta_counts,
                kanji_meta_counts,
            );
            let yomitan_version = "0.1.0".to_string();
            let summary_details = SummaryDetails {
                prefix_wildcard_supported: settings
                    .global
                    .database
                    .prefix_wildcards_supported,
                counts,
                /// this is incorrect, it parses a 'styles.css' file
                /// need to do this later
                styles: "".to_string(),
                yomitan_version,
            };
            let summary = DictionarySummary::new(
                index,
                settings.global.database.prefix_wildcards_supported,
                summary_details,
            )?;
            let dictionary_options = DictionaryOptions::new(settings, dict_name);
            Ok(DatabaseDictData {
                tag_list,
                kanji_meta_list,
                kanji_list,
                term_meta_list,
                term_list,
                summary,
                dictionary_options,
            })
        }
        fn convert_index_file(outpath: PathBuf) -> Result<Index, ImportError> {
            let index_str = fs::read_to_string(&outpath)
                .map_err(|e| DictionaryFileError::File {
                    outpath,
                    reason: e.to_string(),
                })?;
            let index: Index = serde_json::from_str(&index_str)?;
            Ok(index)
        }
        fn convert_tag_bank_files(
            outpaths: Vec<PathBuf>,
            dictionary: &str,
        ) -> Result<Vec<Vec<DatabaseTag>>, ImportError> {
            outpaths
                .into_iter()
                .map(|p| {
                    let tag_str = fs::read_to_string(p)?;
                    let mut tag: Vec<DictionaryDataTag> = serde_json::from_str(
                        &tag_str,
                    )?;
                    let res = tag
                        .into_iter()
                        .map(|tag| {
                            let DictionaryDataTag {
                                name,
                                category,
                                order,
                                notes,
                                score,
                            } = tag;
                            DatabaseTag {
                                id: Uuid::now_v7().to_string(),
                                name,
                                category,
                                order,
                                notes,
                                score,
                                dictionary: dictionary.to_string(),
                            }
                        })
                        .collect();
                    Ok(res)
                })
                .collect()
        }
        fn convert_kanji_bank(
            outpath: PathBuf,
            dict_name: &str,
        ) -> Result<Vec<DatabaseKanjiEntry>, DictionaryFileError> {
            let file = fs::File::open(&outpath)
                .map_err(|reason| DictionaryFileError::FailedOpen {
                    outpath: outpath.clone(),
                    reason: reason.to_string(),
                })?;
            let reader = BufReader::new(file);
            let mut stream = JsonDeserializer::from_reader(reader)
                .into_iter::<KanjiBank>();
            let mut entries = match stream.next() {
                Some(Ok(entries)) => entries,
                Some(Err(reason)) => {
                    return Err(crate::errors::DictionaryFileError::File {
                        outpath,
                        reason: reason.to_string(),
                    });
                }
                None => return Err(DictionaryFileError::Empty(outpath)),
            };
            for item in &mut entries {
                item.dictionary = Some(dict_name.to_owned());
            }
            Ok(entries)
        }
        fn convert_term_bank_file(
            outpath: PathBuf,
            dict_name: &str,
        ) -> Result<Vec<DatabaseTermEntry>, DictionaryFileError> {
            let file = fs::File::open(&outpath)
                .map_err(|reason| DictionaryFileError::FailedOpen {
                    outpath: outpath.clone(),
                    reason: reason.to_string(),
                })?;
            let reader = BufReader::new(file);
            let mut stream = JsonDeserializer::from_reader(reader)
                .into_iter::<TermBank>();
            let mut entries = match stream.next() {
                Some(Ok(entries)) => entries,
                Some(Err(reason)) => {
                    return Err(crate::errors::DictionaryFileError::File {
                        outpath,
                        reason: reason.to_string(),
                    });
                }
                None => return Err(DictionaryFileError::Empty(outpath)),
            };
            let terms: Vec<DatabaseTermEntry> = entries
                .into_iter()
                .map(|mut entry| {
                    let id = uuid::Uuid::now_v7().to_string();
                    let expression = entry.expression;
                    let reading = entry.reading;
                    let expression_reverse = rev_str(&expression);
                    let reading_reverse = rev_str(&reading);
                    let mut db_term = DatabaseTermEntry {
                        id,
                        expression,
                        expression_reverse,
                        reading,
                        reading_reverse,
                        definition_tags: entry.def_tags,
                        rules: entry.rules,
                        score: entry.score,
                        sequence: Some(entry.sequence),
                        term_tags: Some(entry.term_tags),
                        file_path: outpath.clone().into_os_string(),
                        dictionary: dict_name.to_owned(),
                        ..Default::default()
                    };
                    let structured_content = entry.structured_content.swap_remove(0);
                    let defs = get_string_content(structured_content.content);
                    let gloss_content = TermGlossaryContent::new(
                        defs.concat(),
                        None,
                        None,
                        None,
                    );
                    let gloss = TermGlossary::Content(Box::new(gloss_content));
                    db_term.glossary = <[_]>::into_vec(::alloc::boxed::box_new([gloss]));
                    db_term
                })
                .collect();
            Ok(terms)
        }
        fn rev_str(expression: &str) -> String {
            expression.chars().rev().collect()
        }
        fn get_string_content(c_match_type: ContentMatchType) -> Vec<String> {
            match c_match_type {
                ContentMatchType::String(string) => {
                    <[_]>::into_vec(::alloc::boxed::box_new([string]))
                }
                ContentMatchType::Element(element) => {
                    handle_content_match_type(
                        <[_]>::into_vec(::alloc::boxed::box_new([*element])),
                    )
                }
                ContentMatchType::Content(vec) => handle_content_match_type(vec),
            }
        }
        fn handle_content_match_type(content: Vec<Element>) -> Vec<String> {
            let mut content_strings: Vec<String> = Vec::new();
            for e in content {
                match e {
                    Element::UnknownString(string) => content_strings.push(string),
                    Element::Link(mut element) => {
                        if let Some(content) = std::mem::take(&mut element.content) {
                            content_strings.extend(get_string_content(content));
                        }
                    }
                    Element::Styled(mut element) => {
                        if let Some(content) = std::mem::take(&mut element.content) {
                            content_strings.extend(get_string_content(content));
                        }
                    }
                    Element::Unstyled(mut element) => {
                        if let Some(content) = std::mem::take(&mut element.content) {
                            content_strings.extend(get_string_content(content));
                        }
                    }
                    Element::Table(mut element) => {
                        if let Some(content) = std::mem::take(&mut element.content) {
                            content_strings.extend(get_string_content(content));
                        }
                    }
                    Element::Image(_) => {}
                    Element::LineBreak(_) => {}
                    _ => {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "handle_content_match_type err: matched nothing! | line: {0}",
                                824u32,
                            ),
                        );
                    }
                }
            }
            content_strings
        }
        fn read_dir_helper<P: AsRef<Path>>(
            zip_path: P,
            index: &mut PathBuf,
            tag_banks: &mut Vec<PathBuf>,
            kanji_meta_banks: &mut Vec<PathBuf>,
            kanji_banks: &mut Vec<PathBuf>,
            term_meta_banks: &mut Vec<PathBuf>,
            term_banks: &mut Vec<PathBuf>,
        ) -> Result<(), io::Error> {
            fn contains(path: &[u8], substr: &[u8]) -> bool {
                path.windows(substr.len()).any(|w| w == substr)
            }
            fs::read_dir(&zip_path)?
                .try_for_each(|entry| -> Result<(), io::Error> {
                    let entry = entry?;
                    let outpath_buf = entry.path();
                    let outpath = outpath_buf.as_os_str().as_encoded_bytes();
                    if outpath.iter().last() != Some(&b'/') {
                        if contains(outpath, b"term_bank") {
                            term_banks.push(outpath_buf);
                        } else if contains(outpath, b"index.json") {
                            *index = outpath_buf;
                        } else if contains(outpath, b"term_meta_bank") {
                            term_meta_banks.push(outpath_buf);
                        } else if contains(outpath, b"kanji_meta_bank") {
                            kanji_meta_banks.push(outpath_buf);
                        } else if contains(outpath, b"kanji_bank") {
                            kanji_banks.push(outpath_buf);
                        } else if contains(outpath, b"tag_bank") {
                            tag_banks.push(outpath_buf);
                        }
                    }
                    Ok(())
                })
        }
    }
    pub mod handlers {}
}
mod dictionary {
    use crate::{
        database::dictionary_database::{Pronunciation, TermPronunciationMatchType},
        dictionary_data::TermGlossaryContent,
        translation_internal::TextProcessorRuleChainCandidate, translator::TermType,
    };
    use derive_more::derive::From;
    use getset::MutGetters;
    use indexmap::IndexMap;
    use language_transformer::transformer::{
        InflectionRuleChainCandidate, InflectionSource,
    };
    use serde::{Deserialize, Serialize};
    /// Dictionary InflectionRuleChainCandidate
    pub struct DictionaryInflectionRuleChainCandidate {
        pub source: InflectionSource,
        pub inflection_rules: Vec<String>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for DictionaryInflectionRuleChainCandidate {
        #[inline]
        fn clone(&self) -> DictionaryInflectionRuleChainCandidate {
            DictionaryInflectionRuleChainCandidate {
                source: ::core::clone::Clone::clone(&self.source),
                inflection_rules: ::core::clone::Clone::clone(&self.inflection_rules),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for DictionaryInflectionRuleChainCandidate {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "DictionaryInflectionRuleChainCandidate",
                "source",
                &self.source,
                "inflection_rules",
                &&self.inflection_rules,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for DictionaryInflectionRuleChainCandidate {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for DictionaryInflectionRuleChainCandidate {
        #[inline]
        fn eq(&self, other: &DictionaryInflectionRuleChainCandidate) -> bool {
            self.source == other.source
                && self.inflection_rules == other.inflection_rules
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for DictionaryInflectionRuleChainCandidate {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<InflectionSource>;
            let _: ::core::cmp::AssertParamIsEq<Vec<String>>;
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for DictionaryInflectionRuleChainCandidate {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.source, state);
            ::core::hash::Hash::hash(&self.inflection_rules, state)
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for DictionaryInflectionRuleChainCandidate {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "DictionaryInflectionRuleChainCandidate",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "source",
                    &self.source,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "inflection_rules",
                    &self.inflection_rules,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for DictionaryInflectionRuleChainCandidate {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "source" => _serde::__private::Ok(__Field::__field0),
                            "inflection_rules" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"source" => _serde::__private::Ok(__Field::__field0),
                            b"inflection_rules" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<
                        DictionaryInflectionRuleChainCandidate,
                    >,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = DictionaryInflectionRuleChainCandidate;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct DictionaryInflectionRuleChainCandidate",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            InflectionSource,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct DictionaryInflectionRuleChainCandidate with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            Vec<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct DictionaryInflectionRuleChainCandidate with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(DictionaryInflectionRuleChainCandidate {
                            source: __field0,
                            inflection_rules: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<InflectionSource> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Vec<String>> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("source"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            InflectionSource,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "inflection_rules",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("source")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("inflection_rules")?
                            }
                        };
                        _serde::__private::Ok(DictionaryInflectionRuleChainCandidate {
                            source: __field0,
                            inflection_rules: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["source", "inflection_rules"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "DictionaryInflectionRuleChainCandidate",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            DictionaryInflectionRuleChainCandidate,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    /// Dictionary InflectionRuleChainCandidateKey
    pub struct EntryInflectionRuleChainCandidatesKey {
        pub term: String,
        pub reading: String,
        pub inflection_rule_chain_candidates: Vec<
            DictionaryInflectionRuleChainCandidate,
        >,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for EntryInflectionRuleChainCandidatesKey {
        #[inline]
        fn clone(&self) -> EntryInflectionRuleChainCandidatesKey {
            EntryInflectionRuleChainCandidatesKey {
                term: ::core::clone::Clone::clone(&self.term),
                reading: ::core::clone::Clone::clone(&self.reading),
                inflection_rule_chain_candidates: ::core::clone::Clone::clone(
                    &self.inflection_rule_chain_candidates,
                ),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for EntryInflectionRuleChainCandidatesKey {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "EntryInflectionRuleChainCandidatesKey",
                "term",
                &self.term,
                "reading",
                &self.reading,
                "inflection_rule_chain_candidates",
                &&self.inflection_rule_chain_candidates,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for EntryInflectionRuleChainCandidatesKey {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for EntryInflectionRuleChainCandidatesKey {
        #[inline]
        fn eq(&self, other: &EntryInflectionRuleChainCandidatesKey) -> bool {
            self.term == other.term && self.reading == other.reading
                && self.inflection_rule_chain_candidates
                    == other.inflection_rule_chain_candidates
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for EntryInflectionRuleChainCandidatesKey {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<String>;
            let _: ::core::cmp::AssertParamIsEq<
                Vec<DictionaryInflectionRuleChainCandidate>,
            >;
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for EntryInflectionRuleChainCandidatesKey {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.term, state);
            ::core::hash::Hash::hash(&self.reading, state);
            ::core::hash::Hash::hash(&self.inflection_rule_chain_candidates, state)
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for EntryInflectionRuleChainCandidatesKey {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "EntryInflectionRuleChainCandidatesKey",
                    false as usize + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "term",
                    &self.term,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "reading",
                    &self.reading,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "inflection_rule_chain_candidates",
                    &self.inflection_rule_chain_candidates,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for EntryInflectionRuleChainCandidatesKey {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "term" => _serde::__private::Ok(__Field::__field0),
                            "reading" => _serde::__private::Ok(__Field::__field1),
                            "inflection_rule_chain_candidates" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"term" => _serde::__private::Ok(__Field::__field0),
                            b"reading" => _serde::__private::Ok(__Field::__field1),
                            b"inflection_rule_chain_candidates" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<
                        EntryInflectionRuleChainCandidatesKey,
                    >,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = EntryInflectionRuleChainCandidatesKey;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct EntryInflectionRuleChainCandidatesKey",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct EntryInflectionRuleChainCandidatesKey with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct EntryInflectionRuleChainCandidatesKey with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            Vec<DictionaryInflectionRuleChainCandidate>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct EntryInflectionRuleChainCandidatesKey with 3 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(EntryInflectionRuleChainCandidatesKey {
                            term: __field0,
                            reading: __field1,
                            inflection_rule_chain_candidates: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<
                            Vec<DictionaryInflectionRuleChainCandidate>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("term"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "reading",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "inflection_rule_chain_candidates",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<DictionaryInflectionRuleChainCandidate>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("term")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("reading")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "inflection_rule_chain_candidates",
                                )?
                            }
                        };
                        _serde::__private::Ok(EntryInflectionRuleChainCandidatesKey {
                            term: __field0,
                            reading: __field1,
                            inflection_rule_chain_candidates: __field2,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "term",
                    "reading",
                    "inflection_rule_chain_candidates",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "EntryInflectionRuleChainCandidatesKey",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            EntryInflectionRuleChainCandidatesKey,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    /// Helper enum to match expected schema types more accurately.
    pub enum NumOrStr {
        Num(i128),
        Str(String),
    }
    #[automatically_derived]
    impl ::core::clone::Clone for NumOrStr {
        #[inline]
        fn clone(&self) -> NumOrStr {
            match self {
                NumOrStr::Num(__self_0) => {
                    NumOrStr::Num(::core::clone::Clone::clone(__self_0))
                }
                NumOrStr::Str(__self_0) => {
                    NumOrStr::Str(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for NumOrStr {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                NumOrStr::Num(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Num",
                        &__self_0,
                    )
                }
                NumOrStr::Str(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Str",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for NumOrStr {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for NumOrStr {
        #[inline]
        fn eq(&self, other: &NumOrStr) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
                && match (self, other) {
                    (NumOrStr::Num(__self_0), NumOrStr::Num(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (NumOrStr::Str(__self_0), NumOrStr::Str(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for NumOrStr {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    NumOrStr::Num(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "NumOrStr",
                            0u32,
                            "Num",
                            __field0,
                        )
                    }
                    NumOrStr::Str(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "NumOrStr",
                            1u32,
                            "Str",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for NumOrStr {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 2",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Num" => _serde::__private::Ok(__Field::__field0),
                            "Str" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Num" => _serde::__private::Ok(__Field::__field0),
                            b"Str" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<NumOrStr>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = NumOrStr;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum NumOrStr",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        i128,
                                    >(__variant),
                                    NumOrStr::Num,
                                )
                            }
                            (__Field::__field1, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        String,
                                    >(__variant),
                                    NumOrStr::Str,
                                )
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["Num", "Str"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "NumOrStr",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<NumOrStr>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    /// Helper enum to match [TermMetaPitchAccent] data more accurately.
    pub enum VecNumOrNum {
        Vec(Vec<u8>),
        Num(u8),
    }
    #[automatically_derived]
    impl ::core::clone::Clone for VecNumOrNum {
        #[inline]
        fn clone(&self) -> VecNumOrNum {
            match self {
                VecNumOrNum::Vec(__self_0) => {
                    VecNumOrNum::Vec(::core::clone::Clone::clone(__self_0))
                }
                VecNumOrNum::Num(__self_0) => {
                    VecNumOrNum::Num(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for VecNumOrNum {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                VecNumOrNum::Vec(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Vec",
                        &__self_0,
                    )
                }
                VecNumOrNum::Num(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Num",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for VecNumOrNum {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for VecNumOrNum {
        #[inline]
        fn eq(&self, other: &VecNumOrNum) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
                && match (self, other) {
                    (VecNumOrNum::Vec(__self_0), VecNumOrNum::Vec(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (VecNumOrNum::Num(__self_0), VecNumOrNum::Num(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for VecNumOrNum {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<Vec<u8>>;
            let _: ::core::cmp::AssertParamIsEq<u8>;
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for VecNumOrNum {
        #[inline]
        fn partial_cmp(
            &self,
            other: &VecNumOrNum,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            match (self, other) {
                (VecNumOrNum::Vec(__self_0), VecNumOrNum::Vec(__arg1_0)) => {
                    ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                }
                (VecNumOrNum::Num(__self_0), VecNumOrNum::Num(__arg1_0)) => {
                    ::core::cmp::PartialOrd::partial_cmp(__self_0, __arg1_0)
                }
                _ => ::core::cmp::PartialOrd::partial_cmp(&__self_discr, &__arg1_discr),
            }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for VecNumOrNum {
        #[inline]
        fn cmp(&self, other: &VecNumOrNum) -> ::core::cmp::Ordering {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            match ::core::cmp::Ord::cmp(&__self_discr, &__arg1_discr) {
                ::core::cmp::Ordering::Equal => {
                    match (self, other) {
                        (VecNumOrNum::Vec(__self_0), VecNumOrNum::Vec(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        (VecNumOrNum::Num(__self_0), VecNumOrNum::Num(__arg1_0)) => {
                            ::core::cmp::Ord::cmp(__self_0, __arg1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() }
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for VecNumOrNum {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_discr, state);
            match self {
                VecNumOrNum::Vec(__self_0) => ::core::hash::Hash::hash(__self_0, state),
                VecNumOrNum::Num(__self_0) => ::core::hash::Hash::hash(__self_0, state),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for VecNumOrNum {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    VecNumOrNum::Vec(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "VecNumOrNum",
                            0u32,
                            "Vec",
                            __field0,
                        )
                    }
                    VecNumOrNum::Num(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "VecNumOrNum",
                            1u32,
                            "Num",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for VecNumOrNum {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 2",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Vec" => _serde::__private::Ok(__Field::__field0),
                            "Num" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Vec" => _serde::__private::Ok(__Field::__field0),
                            b"Num" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<VecNumOrNum>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = VecNumOrNum;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum VecNumOrNum",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        Vec<u8>,
                                    >(__variant),
                                    VecNumOrNum::Vec,
                                )
                            }
                            (__Field::__field1, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<u8>(__variant),
                                    VecNumOrNum::Num,
                                )
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["Vec", "Num"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "VecNumOrNum",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<VecNumOrNum>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    /// A tag represents some brief information about part of a dictionary entry.
    pub struct DictionaryTag {
        /// The name of the tag.
        pub name: String,
        /// The category of the tag.
        pub category: String,
        /// A number indicating the sorting order of the tag.
        pub order: usize,
        /// A score value for the tag.
        pub score: usize,
        /// An array of descriptions for the tag. If there are multiple entries,
        /// the values will typically have originated from different dictionaries.
        /// However, there is no correlation between the length of this array and
        /// the length of the `dictionaries` field, as duplicates are removed.
        pub content: Vec<String>,
        /// An array of dictionary names that contained a tag with this name and category.
        pub dictionaries: Vec<String>,
        /// Whether or not this tag is redundant with previous tags.
        pub redundant: bool,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for DictionaryTag {
        #[inline]
        fn clone(&self) -> DictionaryTag {
            DictionaryTag {
                name: ::core::clone::Clone::clone(&self.name),
                category: ::core::clone::Clone::clone(&self.category),
                order: ::core::clone::Clone::clone(&self.order),
                score: ::core::clone::Clone::clone(&self.score),
                content: ::core::clone::Clone::clone(&self.content),
                dictionaries: ::core::clone::Clone::clone(&self.dictionaries),
                redundant: ::core::clone::Clone::clone(&self.redundant),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for DictionaryTag {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "name",
                "category",
                "order",
                "score",
                "content",
                "dictionaries",
                "redundant",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.name,
                &self.category,
                &self.order,
                &self.score,
                &self.content,
                &self.dictionaries,
                &&self.redundant,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "DictionaryTag",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for DictionaryTag {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for DictionaryTag {
        #[inline]
        fn eq(&self, other: &DictionaryTag) -> bool {
            self.name == other.name && self.category == other.category
                && self.order == other.order && self.score == other.score
                && self.content == other.content
                && self.dictionaries == other.dictionaries
                && self.redundant == other.redundant
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for DictionaryTag {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<String>;
            let _: ::core::cmp::AssertParamIsEq<usize>;
            let _: ::core::cmp::AssertParamIsEq<Vec<String>>;
            let _: ::core::cmp::AssertParamIsEq<Vec<String>>;
            let _: ::core::cmp::AssertParamIsEq<bool>;
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for DictionaryTag {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.name, state);
            ::core::hash::Hash::hash(&self.category, state);
            ::core::hash::Hash::hash(&self.order, state);
            ::core::hash::Hash::hash(&self.score, state);
            ::core::hash::Hash::hash(&self.content, state);
            ::core::hash::Hash::hash(&self.dictionaries, state);
            ::core::hash::Hash::hash(&self.redundant, state)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for DictionaryTag {
        #[inline]
        fn partial_cmp(
            &self,
            other: &DictionaryTag,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(&self.name, &other.name) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.category,
                        &other.category,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match ::core::cmp::PartialOrd::partial_cmp(
                                &self.order,
                                &other.order,
                            ) {
                                ::core::option::Option::Some(
                                    ::core::cmp::Ordering::Equal,
                                ) => {
                                    match ::core::cmp::PartialOrd::partial_cmp(
                                        &self.score,
                                        &other.score,
                                    ) {
                                        ::core::option::Option::Some(
                                            ::core::cmp::Ordering::Equal,
                                        ) => {
                                            match ::core::cmp::PartialOrd::partial_cmp(
                                                &self.content,
                                                &other.content,
                                            ) {
                                                ::core::option::Option::Some(
                                                    ::core::cmp::Ordering::Equal,
                                                ) => {
                                                    match ::core::cmp::PartialOrd::partial_cmp(
                                                        &self.dictionaries,
                                                        &other.dictionaries,
                                                    ) {
                                                        ::core::option::Option::Some(
                                                            ::core::cmp::Ordering::Equal,
                                                        ) => {
                                                            ::core::cmp::PartialOrd::partial_cmp(
                                                                &self.redundant,
                                                                &other.redundant,
                                                            )
                                                        }
                                                        cmp => cmp,
                                                    }
                                                }
                                                cmp => cmp,
                                            }
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for DictionaryTag {
        #[inline]
        fn cmp(&self, other: &DictionaryTag) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.name, &other.name) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(&self.category, &other.category) {
                        ::core::cmp::Ordering::Equal => {
                            match ::core::cmp::Ord::cmp(&self.order, &other.order) {
                                ::core::cmp::Ordering::Equal => {
                                    match ::core::cmp::Ord::cmp(&self.score, &other.score) {
                                        ::core::cmp::Ordering::Equal => {
                                            match ::core::cmp::Ord::cmp(&self.content, &other.content) {
                                                ::core::cmp::Ordering::Equal => {
                                                    match ::core::cmp::Ord::cmp(
                                                        &self.dictionaries,
                                                        &other.dictionaries,
                                                    ) {
                                                        ::core::cmp::Ordering::Equal => {
                                                            ::core::cmp::Ord::cmp(&self.redundant, &other.redundant)
                                                        }
                                                        cmp => cmp,
                                                    }
                                                }
                                                cmp => cmp,
                                            }
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for DictionaryTag {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "DictionaryTag",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "name",
                    &self.name,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "category",
                    &self.category,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "order",
                    &self.order,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "score",
                    &self.score,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "content",
                    &self.content,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "dictionaries",
                    &self.dictionaries,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "redundant",
                    &self.redundant,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for DictionaryTag {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "name" => _serde::__private::Ok(__Field::__field0),
                            "category" => _serde::__private::Ok(__Field::__field1),
                            "order" => _serde::__private::Ok(__Field::__field2),
                            "score" => _serde::__private::Ok(__Field::__field3),
                            "content" => _serde::__private::Ok(__Field::__field4),
                            "dictionaries" => _serde::__private::Ok(__Field::__field5),
                            "redundant" => _serde::__private::Ok(__Field::__field6),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"name" => _serde::__private::Ok(__Field::__field0),
                            b"category" => _serde::__private::Ok(__Field::__field1),
                            b"order" => _serde::__private::Ok(__Field::__field2),
                            b"score" => _serde::__private::Ok(__Field::__field3),
                            b"content" => _serde::__private::Ok(__Field::__field4),
                            b"dictionaries" => _serde::__private::Ok(__Field::__field5),
                            b"redundant" => _serde::__private::Ok(__Field::__field6),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<DictionaryTag>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = DictionaryTag;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct DictionaryTag",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct DictionaryTag with 7 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct DictionaryTag with 7 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            usize,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct DictionaryTag with 7 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            usize,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct DictionaryTag with 7 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            Vec<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct DictionaryTag with 7 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            Vec<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct DictionaryTag with 7 elements",
                                    ),
                                );
                            }
                        };
                        let __field6 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        6usize,
                                        &"struct DictionaryTag with 7 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(DictionaryTag {
                            name: __field0,
                            category: __field1,
                            order: __field2,
                            score: __field3,
                            content: __field4,
                            dictionaries: __field5,
                            redundant: __field6,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<usize> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<usize> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<Vec<String>> = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<Vec<String>> = _serde::__private::None;
                        let mut __field6: _serde::__private::Option<bool> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "category",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("order"),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<usize>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("score"),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<usize>(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "content",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "dictionaries",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "redundant",
                                            ),
                                        );
                                    }
                                    __field6 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("name")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("category")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("order")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("score")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("content")?
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("dictionaries")?
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("redundant")?
                            }
                        };
                        _serde::__private::Ok(DictionaryTag {
                            name: __field0,
                            category: __field1,
                            order: __field2,
                            score: __field3,
                            content: __field4,
                            dictionaries: __field5,
                            redundant: __field6,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "name",
                    "category",
                    "order",
                    "score",
                    "content",
                    "dictionaries",
                    "redundant",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "DictionaryTag",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<DictionaryTag>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    impl DictionaryTag {
        /// sets the category to "default"
        pub fn new_default(name: String, dictionary: String) -> Self {
            Self {
                name,
                category: "default".to_string(),
                order: 0,
                score: 0,
                content: ::alloc::vec::Vec::new(),
                dictionaries: <[_]>::into_vec(::alloc::boxed::box_new([dictionary])),
                redundant: false,
            }
        }
    }
    pub enum DictionaryEntry {
        KanjiDictEntry(KanjiDictionaryEntry),
        TermDictEntry(TermDictionaryEntry),
    }
    #[automatically_derived]
    impl ::core::clone::Clone for DictionaryEntry {
        #[inline]
        fn clone(&self) -> DictionaryEntry {
            match self {
                DictionaryEntry::KanjiDictEntry(__self_0) => {
                    DictionaryEntry::KanjiDictEntry(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                DictionaryEntry::TermDictEntry(__self_0) => {
                    DictionaryEntry::TermDictEntry(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for DictionaryEntry {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                DictionaryEntry::KanjiDictEntry(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "KanjiDictEntry",
                        &__self_0,
                    )
                }
                DictionaryEntry::TermDictEntry(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "TermDictEntry",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for DictionaryEntry {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for DictionaryEntry {
        #[inline]
        fn eq(&self, other: &DictionaryEntry) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
                && match (self, other) {
                    (
                        DictionaryEntry::KanjiDictEntry(__self_0),
                        DictionaryEntry::KanjiDictEntry(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        DictionaryEntry::TermDictEntry(__self_0),
                        DictionaryEntry::TermDictEntry(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for DictionaryEntry {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    DictionaryEntry::KanjiDictEntry(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "DictionaryEntry",
                            0u32,
                            "KanjiDictEntry",
                            __field0,
                        )
                    }
                    DictionaryEntry::TermDictEntry(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "DictionaryEntry",
                            1u32,
                            "TermDictEntry",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for DictionaryEntry {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 2",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "KanjiDictEntry" => _serde::__private::Ok(__Field::__field0),
                            "TermDictEntry" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"KanjiDictEntry" => _serde::__private::Ok(__Field::__field0),
                            b"TermDictEntry" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<DictionaryEntry>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = DictionaryEntry;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum DictionaryEntry",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        KanjiDictionaryEntry,
                                    >(__variant),
                                    DictionaryEntry::KanjiDictEntry,
                                )
                            }
                            (__Field::__field1, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        TermDictionaryEntry,
                                    >(__variant),
                                    DictionaryEntry::TermDictEntry,
                                )
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "KanjiDictEntry",
                    "TermDictEntry",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "DictionaryEntry",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<DictionaryEntry>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[serde(rename_all = "lowercase")]
    pub enum DictionaryEntryType {
        Kanji,
        Term,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for DictionaryEntryType {
        #[inline]
        fn clone(&self) -> DictionaryEntryType {
            match self {
                DictionaryEntryType::Kanji => DictionaryEntryType::Kanji,
                DictionaryEntryType::Term => DictionaryEntryType::Term,
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for DictionaryEntryType {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    DictionaryEntryType::Kanji => "Kanji",
                    DictionaryEntryType::Term => "Term",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for DictionaryEntryType {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for DictionaryEntryType {
        #[inline]
        fn eq(&self, other: &DictionaryEntryType) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for DictionaryEntryType {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    DictionaryEntryType::Kanji => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "DictionaryEntryType",
                            0u32,
                            "kanji",
                        )
                    }
                    DictionaryEntryType::Term => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "DictionaryEntryType",
                            1u32,
                            "term",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for DictionaryEntryType {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 2",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "kanji" => _serde::__private::Ok(__Field::__field0),
                            "term" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"kanji" => _serde::__private::Ok(__Field::__field0),
                            b"term" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<DictionaryEntryType>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = DictionaryEntryType;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum DictionaryEntryType",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(DictionaryEntryType::Kanji)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(DictionaryEntryType::Term)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["kanji", "term"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "DictionaryEntryType",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<DictionaryEntryType>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    /// A stat represents a generic piece of information about a kanji character.
    pub struct KanjiStat {
        /// The name of the stat.
        name: String,
        /// The category of the stat.
        category: String,
        /// A description of the stat.
        content: String,
        /// A number indicating the sorting order of the stat.
        order: u16,
        /// A score value for the stat.
        score: u64,
        /// The name of the dictionary that the stat originated from.
        dictionary: String,
        /// A value for the stat.
        value: NumOrStr,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for KanjiStat {
        #[inline]
        fn clone(&self) -> KanjiStat {
            KanjiStat {
                name: ::core::clone::Clone::clone(&self.name),
                category: ::core::clone::Clone::clone(&self.category),
                content: ::core::clone::Clone::clone(&self.content),
                order: ::core::clone::Clone::clone(&self.order),
                score: ::core::clone::Clone::clone(&self.score),
                dictionary: ::core::clone::Clone::clone(&self.dictionary),
                value: ::core::clone::Clone::clone(&self.value),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for KanjiStat {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "name",
                "category",
                "content",
                "order",
                "score",
                "dictionary",
                "value",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.name,
                &self.category,
                &self.content,
                &self.order,
                &self.score,
                &self.dictionary,
                &&self.value,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "KanjiStat",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for KanjiStat {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for KanjiStat {
        #[inline]
        fn eq(&self, other: &KanjiStat) -> bool {
            self.name == other.name && self.category == other.category
                && self.content == other.content && self.order == other.order
                && self.score == other.score && self.dictionary == other.dictionary
                && self.value == other.value
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for KanjiStat {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "KanjiStat",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "name",
                    &self.name,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "category",
                    &self.category,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "content",
                    &self.content,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "order",
                    &self.order,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "score",
                    &self.score,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "dictionary",
                    &self.dictionary,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "value",
                    &self.value,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for KanjiStat {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "name" => _serde::__private::Ok(__Field::__field0),
                            "category" => _serde::__private::Ok(__Field::__field1),
                            "content" => _serde::__private::Ok(__Field::__field2),
                            "order" => _serde::__private::Ok(__Field::__field3),
                            "score" => _serde::__private::Ok(__Field::__field4),
                            "dictionary" => _serde::__private::Ok(__Field::__field5),
                            "value" => _serde::__private::Ok(__Field::__field6),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"name" => _serde::__private::Ok(__Field::__field0),
                            b"category" => _serde::__private::Ok(__Field::__field1),
                            b"content" => _serde::__private::Ok(__Field::__field2),
                            b"order" => _serde::__private::Ok(__Field::__field3),
                            b"score" => _serde::__private::Ok(__Field::__field4),
                            b"dictionary" => _serde::__private::Ok(__Field::__field5),
                            b"value" => _serde::__private::Ok(__Field::__field6),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<KanjiStat>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = KanjiStat;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct KanjiStat",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct KanjiStat with 7 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct KanjiStat with 7 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct KanjiStat with 7 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            u16,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct KanjiStat with 7 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            u64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct KanjiStat with 7 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct KanjiStat with 7 elements",
                                    ),
                                );
                            }
                        };
                        let __field6 = match _serde::de::SeqAccess::next_element::<
                            NumOrStr,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        6usize,
                                        &"struct KanjiStat with 7 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(KanjiStat {
                            name: __field0,
                            category: __field1,
                            content: __field2,
                            order: __field3,
                            score: __field4,
                            dictionary: __field5,
                            value: __field6,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<u16> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<u64> = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field6: _serde::__private::Option<NumOrStr> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "category",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "content",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("order"),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u16>(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("score"),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "dictionary",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("value"),
                                        );
                                    }
                                    __field6 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<NumOrStr>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("name")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("category")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("content")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("order")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("score")?
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("dictionary")?
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("value")?
                            }
                        };
                        _serde::__private::Ok(KanjiStat {
                            name: __field0,
                            category: __field1,
                            content: __field2,
                            order: __field3,
                            score: __field4,
                            dictionary: __field5,
                            value: __field6,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "name",
                    "category",
                    "content",
                    "order",
                    "score",
                    "dictionary",
                    "value",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "KanjiStat",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<KanjiStat>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    pub struct KanjiFrequency {
        index: u64,
        dictionary: String,
        dictionary_index: u16,
        dictionary_priority: u16,
        character: String,
        frequency: NumOrStr,
        display_value: Option<String>,
        display_value_parsed: bool,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for KanjiFrequency {
        #[inline]
        fn clone(&self) -> KanjiFrequency {
            KanjiFrequency {
                index: ::core::clone::Clone::clone(&self.index),
                dictionary: ::core::clone::Clone::clone(&self.dictionary),
                dictionary_index: ::core::clone::Clone::clone(&self.dictionary_index),
                dictionary_priority: ::core::clone::Clone::clone(
                    &self.dictionary_priority,
                ),
                character: ::core::clone::Clone::clone(&self.character),
                frequency: ::core::clone::Clone::clone(&self.frequency),
                display_value: ::core::clone::Clone::clone(&self.display_value),
                display_value_parsed: ::core::clone::Clone::clone(
                    &self.display_value_parsed,
                ),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for KanjiFrequency {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "index",
                "dictionary",
                "dictionary_index",
                "dictionary_priority",
                "character",
                "frequency",
                "display_value",
                "display_value_parsed",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.index,
                &self.dictionary,
                &self.dictionary_index,
                &self.dictionary_priority,
                &self.character,
                &self.frequency,
                &self.display_value,
                &&self.display_value_parsed,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "KanjiFrequency",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for KanjiFrequency {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for KanjiFrequency {
        #[inline]
        fn eq(&self, other: &KanjiFrequency) -> bool {
            self.index == other.index && self.dictionary == other.dictionary
                && self.dictionary_index == other.dictionary_index
                && self.dictionary_priority == other.dictionary_priority
                && self.character == other.character && self.frequency == other.frequency
                && self.display_value == other.display_value
                && self.display_value_parsed == other.display_value_parsed
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for KanjiFrequency {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "KanjiFrequency",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "index",
                    &self.index,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "dictionary",
                    &self.dictionary,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "dictionary_index",
                    &self.dictionary_index,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "dictionary_priority",
                    &self.dictionary_priority,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "character",
                    &self.character,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "frequency",
                    &self.frequency,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "display_value",
                    &self.display_value,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "display_value_parsed",
                    &self.display_value_parsed,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for KanjiFrequency {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "index" => _serde::__private::Ok(__Field::__field0),
                            "dictionary" => _serde::__private::Ok(__Field::__field1),
                            "dictionary_index" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            "dictionary_priority" => {
                                _serde::__private::Ok(__Field::__field3)
                            }
                            "character" => _serde::__private::Ok(__Field::__field4),
                            "frequency" => _serde::__private::Ok(__Field::__field5),
                            "display_value" => _serde::__private::Ok(__Field::__field6),
                            "display_value_parsed" => {
                                _serde::__private::Ok(__Field::__field7)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"index" => _serde::__private::Ok(__Field::__field0),
                            b"dictionary" => _serde::__private::Ok(__Field::__field1),
                            b"dictionary_index" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            b"dictionary_priority" => {
                                _serde::__private::Ok(__Field::__field3)
                            }
                            b"character" => _serde::__private::Ok(__Field::__field4),
                            b"frequency" => _serde::__private::Ok(__Field::__field5),
                            b"display_value" => _serde::__private::Ok(__Field::__field6),
                            b"display_value_parsed" => {
                                _serde::__private::Ok(__Field::__field7)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<KanjiFrequency>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = KanjiFrequency;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct KanjiFrequency",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            u64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct KanjiFrequency with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct KanjiFrequency with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            u16,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct KanjiFrequency with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            u16,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct KanjiFrequency with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct KanjiFrequency with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            NumOrStr,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct KanjiFrequency with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field6 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        6usize,
                                        &"struct KanjiFrequency with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field7 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        7usize,
                                        &"struct KanjiFrequency with 8 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(KanjiFrequency {
                            index: __field0,
                            dictionary: __field1,
                            dictionary_index: __field2,
                            dictionary_priority: __field3,
                            character: __field4,
                            frequency: __field5,
                            display_value: __field6,
                            display_value_parsed: __field7,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<u64> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<u16> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<u16> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<NumOrStr> = _serde::__private::None;
                        let mut __field6: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field7: _serde::__private::Option<bool> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("index"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "dictionary",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "dictionary_index",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u16>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "dictionary_priority",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u16>(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "character",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "frequency",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<NumOrStr>(&mut __map)?,
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "display_value",
                                            ),
                                        );
                                    }
                                    __field6 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field7 => {
                                    if _serde::__private::Option::is_some(&__field7) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "display_value_parsed",
                                            ),
                                        );
                                    }
                                    __field7 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("index")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("dictionary")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("dictionary_index")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("dictionary_priority")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("character")?
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("frequency")?
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("display_value")?
                            }
                        };
                        let __field7 = match __field7 {
                            _serde::__private::Some(__field7) => __field7,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "display_value_parsed",
                                )?
                            }
                        };
                        _serde::__private::Ok(KanjiFrequency {
                            index: __field0,
                            dictionary: __field1,
                            dictionary_index: __field2,
                            dictionary_priority: __field3,
                            character: __field4,
                            frequency: __field5,
                            display_value: __field6,
                            display_value_parsed: __field7,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "index",
                    "dictionary",
                    "dictionary_index",
                    "dictionary_priority",
                    "character",
                    "frequency",
                    "display_value",
                    "display_value_parsed",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "KanjiFrequency",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<KanjiFrequency>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    /// An object with groups of stats about a kanji character.
    pub type KanjiStatGroups = IndexMap<String, Vec<KanjiStat>>;
    /// A dictionary entry for a kanji character.
    pub struct KanjiDictionaryEntry {
        /// The type of the entry.
        /// Should be `"kanji"` in the json.
        entry_type: DictionaryEntryType,
        /// The kanji character that was looked up.
        character: String,
        /// The name of the dictionary that the information originated from.
        dictionary: String,
        /// Onyomi readings for the kanji character.
        onyomi: Vec<String>,
        /// Kunyomi readings for the kanji character.
        kunyomi: Vec<String>,
        /// Tags for the kanji character.
        tags: Vec<DictionaryTag>,
        /// An object containing stats about the kanji character.
        stats: KanjiStatGroups,
        /// Definitions for the kanji character.
        definitions: Vec<String>,
        /// Frequency information for the kanji character.
        frequencies: Vec<KanjiFrequency>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for KanjiDictionaryEntry {
        #[inline]
        fn clone(&self) -> KanjiDictionaryEntry {
            KanjiDictionaryEntry {
                entry_type: ::core::clone::Clone::clone(&self.entry_type),
                character: ::core::clone::Clone::clone(&self.character),
                dictionary: ::core::clone::Clone::clone(&self.dictionary),
                onyomi: ::core::clone::Clone::clone(&self.onyomi),
                kunyomi: ::core::clone::Clone::clone(&self.kunyomi),
                tags: ::core::clone::Clone::clone(&self.tags),
                stats: ::core::clone::Clone::clone(&self.stats),
                definitions: ::core::clone::Clone::clone(&self.definitions),
                frequencies: ::core::clone::Clone::clone(&self.frequencies),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for KanjiDictionaryEntry {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "entry_type",
                "character",
                "dictionary",
                "onyomi",
                "kunyomi",
                "tags",
                "stats",
                "definitions",
                "frequencies",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.entry_type,
                &self.character,
                &self.dictionary,
                &self.onyomi,
                &self.kunyomi,
                &self.tags,
                &self.stats,
                &self.definitions,
                &&self.frequencies,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "KanjiDictionaryEntry",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for KanjiDictionaryEntry {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for KanjiDictionaryEntry {
        #[inline]
        fn eq(&self, other: &KanjiDictionaryEntry) -> bool {
            self.entry_type == other.entry_type && self.character == other.character
                && self.dictionary == other.dictionary && self.onyomi == other.onyomi
                && self.kunyomi == other.kunyomi && self.tags == other.tags
                && self.stats == other.stats && self.definitions == other.definitions
                && self.frequencies == other.frequencies
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for KanjiDictionaryEntry {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "KanjiDictionaryEntry",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "entry_type",
                    &self.entry_type,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "character",
                    &self.character,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "dictionary",
                    &self.dictionary,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "onyomi",
                    &self.onyomi,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "kunyomi",
                    &self.kunyomi,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "tags",
                    &self.tags,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "stats",
                    &self.stats,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "definitions",
                    &self.definitions,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "frequencies",
                    &self.frequencies,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for KanjiDictionaryEntry {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __field8,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            8u64 => _serde::__private::Ok(__Field::__field8),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "entry_type" => _serde::__private::Ok(__Field::__field0),
                            "character" => _serde::__private::Ok(__Field::__field1),
                            "dictionary" => _serde::__private::Ok(__Field::__field2),
                            "onyomi" => _serde::__private::Ok(__Field::__field3),
                            "kunyomi" => _serde::__private::Ok(__Field::__field4),
                            "tags" => _serde::__private::Ok(__Field::__field5),
                            "stats" => _serde::__private::Ok(__Field::__field6),
                            "definitions" => _serde::__private::Ok(__Field::__field7),
                            "frequencies" => _serde::__private::Ok(__Field::__field8),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"entry_type" => _serde::__private::Ok(__Field::__field0),
                            b"character" => _serde::__private::Ok(__Field::__field1),
                            b"dictionary" => _serde::__private::Ok(__Field::__field2),
                            b"onyomi" => _serde::__private::Ok(__Field::__field3),
                            b"kunyomi" => _serde::__private::Ok(__Field::__field4),
                            b"tags" => _serde::__private::Ok(__Field::__field5),
                            b"stats" => _serde::__private::Ok(__Field::__field6),
                            b"definitions" => _serde::__private::Ok(__Field::__field7),
                            b"frequencies" => _serde::__private::Ok(__Field::__field8),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<KanjiDictionaryEntry>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = KanjiDictionaryEntry;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct KanjiDictionaryEntry",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            DictionaryEntryType,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct KanjiDictionaryEntry with 9 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct KanjiDictionaryEntry with 9 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct KanjiDictionaryEntry with 9 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            Vec<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct KanjiDictionaryEntry with 9 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            Vec<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct KanjiDictionaryEntry with 9 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            Vec<DictionaryTag>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct KanjiDictionaryEntry with 9 elements",
                                    ),
                                );
                            }
                        };
                        let __field6 = match _serde::de::SeqAccess::next_element::<
                            KanjiStatGroups,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        6usize,
                                        &"struct KanjiDictionaryEntry with 9 elements",
                                    ),
                                );
                            }
                        };
                        let __field7 = match _serde::de::SeqAccess::next_element::<
                            Vec<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        7usize,
                                        &"struct KanjiDictionaryEntry with 9 elements",
                                    ),
                                );
                            }
                        };
                        let __field8 = match _serde::de::SeqAccess::next_element::<
                            Vec<KanjiFrequency>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        8usize,
                                        &"struct KanjiDictionaryEntry with 9 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(KanjiDictionaryEntry {
                            entry_type: __field0,
                            character: __field1,
                            dictionary: __field2,
                            onyomi: __field3,
                            kunyomi: __field4,
                            tags: __field5,
                            stats: __field6,
                            definitions: __field7,
                            frequencies: __field8,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            DictionaryEntryType,
                        > = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<Vec<String>> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<Vec<String>> = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<
                            Vec<DictionaryTag>,
                        > = _serde::__private::None;
                        let mut __field6: _serde::__private::Option<KanjiStatGroups> = _serde::__private::None;
                        let mut __field7: _serde::__private::Option<Vec<String>> = _serde::__private::None;
                        let mut __field8: _serde::__private::Option<
                            Vec<KanjiFrequency>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "entry_type",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            DictionaryEntryType,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "character",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "dictionary",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("onyomi"),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "kunyomi",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("tags"),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<DictionaryTag>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("stats"),
                                        );
                                    }
                                    __field6 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            KanjiStatGroups,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field7 => {
                                    if _serde::__private::Option::is_some(&__field7) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "definitions",
                                            ),
                                        );
                                    }
                                    __field7 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field8 => {
                                    if _serde::__private::Option::is_some(&__field8) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "frequencies",
                                            ),
                                        );
                                    }
                                    __field8 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<KanjiFrequency>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("entry_type")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("character")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("dictionary")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("onyomi")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("kunyomi")?
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("tags")?
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("stats")?
                            }
                        };
                        let __field7 = match __field7 {
                            _serde::__private::Some(__field7) => __field7,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("definitions")?
                            }
                        };
                        let __field8 = match __field8 {
                            _serde::__private::Some(__field8) => __field8,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("frequencies")?
                            }
                        };
                        _serde::__private::Ok(KanjiDictionaryEntry {
                            entry_type: __field0,
                            character: __field1,
                            dictionary: __field2,
                            onyomi: __field3,
                            kunyomi: __field4,
                            tags: __field5,
                            stats: __field6,
                            definitions: __field7,
                            frequencies: __field8,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "entry_type",
                    "character",
                    "dictionary",
                    "onyomi",
                    "kunyomi",
                    "tags",
                    "stats",
                    "definitions",
                    "frequencies",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "KanjiDictionaryEntry",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<KanjiDictionaryEntry>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    pub struct DictionaryOrder {
        index: u16,
        priority: u16,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for DictionaryOrder {
        #[inline]
        fn clone(&self) -> DictionaryOrder {
            DictionaryOrder {
                index: ::core::clone::Clone::clone(&self.index),
                priority: ::core::clone::Clone::clone(&self.priority),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for DictionaryOrder {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "DictionaryOrder",
                "index",
                &self.index,
                "priority",
                &&self.priority,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for DictionaryOrder {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for DictionaryOrder {
        #[inline]
        fn eq(&self, other: &DictionaryOrder) -> bool {
            self.index == other.index && self.priority == other.priority
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for DictionaryOrder {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "DictionaryOrder",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "index",
                    &self.index,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "priority",
                    &self.priority,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for DictionaryOrder {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "index" => _serde::__private::Ok(__Field::__field0),
                            "priority" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"index" => _serde::__private::Ok(__Field::__field0),
                            b"priority" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<DictionaryOrder>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = DictionaryOrder;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct DictionaryOrder",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            u16,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct DictionaryOrder with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            u16,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct DictionaryOrder with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(DictionaryOrder {
                            index: __field0,
                            priority: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<u16> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<u16> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("index"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u16>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "priority",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u16>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("index")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("priority")?
                            }
                        };
                        _serde::__private::Ok(DictionaryOrder {
                            index: __field0,
                            priority: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["index", "priority"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "DictionaryOrder",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<DictionaryOrder>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    /// Enum representing what database field was used to match the source term.
    #[serde(rename_all = "lowercase")]
    pub enum TermSourceMatchSource {
        Term,
        Reading,
        Sequence,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TermSourceMatchSource {
        #[inline]
        fn clone(&self) -> TermSourceMatchSource {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for TermSourceMatchSource {}
    #[automatically_derived]
    impl ::core::fmt::Debug for TermSourceMatchSource {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    TermSourceMatchSource::Term => "Term",
                    TermSourceMatchSource::Reading => "Reading",
                    TermSourceMatchSource::Sequence => "Sequence",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TermSourceMatchSource {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TermSourceMatchSource {
        #[inline]
        fn eq(&self, other: &TermSourceMatchSource) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for TermSourceMatchSource {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for TermSourceMatchSource {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_discr, state)
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TermSourceMatchSource {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    TermSourceMatchSource::Term => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "TermSourceMatchSource",
                            0u32,
                            "term",
                        )
                    }
                    TermSourceMatchSource::Reading => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "TermSourceMatchSource",
                            1u32,
                            "reading",
                        )
                    }
                    TermSourceMatchSource::Sequence => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "TermSourceMatchSource",
                            2u32,
                            "sequence",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TermSourceMatchSource {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 3",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "term" => _serde::__private::Ok(__Field::__field0),
                            "reading" => _serde::__private::Ok(__Field::__field1),
                            "sequence" => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"term" => _serde::__private::Ok(__Field::__field0),
                            b"reading" => _serde::__private::Ok(__Field::__field1),
                            b"sequence" => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<TermSourceMatchSource>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TermSourceMatchSource;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum TermSourceMatchSource",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(TermSourceMatchSource::Term)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(TermSourceMatchSource::Reading)
                            }
                            (__Field::__field2, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(TermSourceMatchSource::Sequence)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "term",
                    "reading",
                    "sequence",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "TermSourceMatchSource",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<TermSourceMatchSource>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    /// Enum representing how the search term relates to the final term.
    #[serde(rename_all = "lowercase")]
    pub enum TermSourceMatchType {
        Exact,
        Prefix,
        Suffix,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TermSourceMatchType {
        #[inline]
        fn clone(&self) -> TermSourceMatchType {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for TermSourceMatchType {}
    #[automatically_derived]
    impl ::core::fmt::Debug for TermSourceMatchType {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    TermSourceMatchType::Exact => "Exact",
                    TermSourceMatchType::Prefix => "Prefix",
                    TermSourceMatchType::Suffix => "Suffix",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TermSourceMatchType {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TermSourceMatchType {
        #[inline]
        fn eq(&self, other: &TermSourceMatchType) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for TermSourceMatchType {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for TermSourceMatchType {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_discr, state)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for TermSourceMatchType {
        #[inline]
        fn partial_cmp(
            &self,
            other: &TermSourceMatchType,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            ::core::cmp::PartialOrd::partial_cmp(&__self_discr, &__arg1_discr)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for TermSourceMatchType {
        #[inline]
        fn cmp(&self, other: &TermSourceMatchType) -> ::core::cmp::Ordering {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            ::core::cmp::Ord::cmp(&__self_discr, &__arg1_discr)
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TermSourceMatchType {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    TermSourceMatchType::Exact => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "TermSourceMatchType",
                            0u32,
                            "exact",
                        )
                    }
                    TermSourceMatchType::Prefix => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "TermSourceMatchType",
                            1u32,
                            "prefix",
                        )
                    }
                    TermSourceMatchType::Suffix => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "TermSourceMatchType",
                            2u32,
                            "suffix",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TermSourceMatchType {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 3",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "exact" => _serde::__private::Ok(__Field::__field0),
                            "prefix" => _serde::__private::Ok(__Field::__field1),
                            "suffix" => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"exact" => _serde::__private::Ok(__Field::__field0),
                            b"prefix" => _serde::__private::Ok(__Field::__field1),
                            b"suffix" => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<TermSourceMatchType>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TermSourceMatchType;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum TermSourceMatchType",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(TermSourceMatchType::Exact)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(TermSourceMatchType::Prefix)
                            }
                            (__Field::__field2, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(TermSourceMatchType::Suffix)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["exact", "prefix", "suffix"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "TermSourceMatchType",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<TermSourceMatchType>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    /// Frequency information corresponds to how frequently a term appears in a corpus,
    /// which can be a number of occurrences or an overall rank.
    pub struct TermFrequency {
        /// The original order of the frequency, which is usually used for sorting.
        pub index: usize,
        /// Which headword this frequency corresponds to.
        pub headword_index: usize,
        /// The name of the dictionary that the frequency information originated from.
        pub dictionary: String,
        /// The index of the dictionary in the original list of dictionaries used for the lookup.
        pub dictionary_index: usize,
        /// The alias for the dictionary
        pub dictionary_alias: String,
        /// Whether or not the frequency had an explicit reading specified.
        pub has_reading: bool,
        /// The frequency for the term, as a number of occurrences or an overall rank.
        pub frequency: i128,
        /// A display value to show to the user.
        pub display_value: Option<String>,
        /// Whether or not the displayValue string was parsed to determine the frequency value.
        pub display_value_parsed: bool,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TermFrequency {
        #[inline]
        fn clone(&self) -> TermFrequency {
            TermFrequency {
                index: ::core::clone::Clone::clone(&self.index),
                headword_index: ::core::clone::Clone::clone(&self.headword_index),
                dictionary: ::core::clone::Clone::clone(&self.dictionary),
                dictionary_index: ::core::clone::Clone::clone(&self.dictionary_index),
                dictionary_alias: ::core::clone::Clone::clone(&self.dictionary_alias),
                has_reading: ::core::clone::Clone::clone(&self.has_reading),
                frequency: ::core::clone::Clone::clone(&self.frequency),
                display_value: ::core::clone::Clone::clone(&self.display_value),
                display_value_parsed: ::core::clone::Clone::clone(
                    &self.display_value_parsed,
                ),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TermFrequency {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "index",
                "headword_index",
                "dictionary",
                "dictionary_index",
                "dictionary_alias",
                "has_reading",
                "frequency",
                "display_value",
                "display_value_parsed",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.index,
                &self.headword_index,
                &self.dictionary,
                &self.dictionary_index,
                &self.dictionary_alias,
                &self.has_reading,
                &self.frequency,
                &self.display_value,
                &&self.display_value_parsed,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "TermFrequency",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TermFrequency {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TermFrequency {
        #[inline]
        fn eq(&self, other: &TermFrequency) -> bool {
            self.index == other.index && self.headword_index == other.headword_index
                && self.dictionary == other.dictionary
                && self.dictionary_index == other.dictionary_index
                && self.dictionary_alias == other.dictionary_alias
                && self.has_reading == other.has_reading
                && self.frequency == other.frequency
                && self.display_value == other.display_value
                && self.display_value_parsed == other.display_value_parsed
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for TermFrequency {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<usize>;
            let _: ::core::cmp::AssertParamIsEq<String>;
            let _: ::core::cmp::AssertParamIsEq<bool>;
            let _: ::core::cmp::AssertParamIsEq<i128>;
            let _: ::core::cmp::AssertParamIsEq<Option<String>>;
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for TermFrequency {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.index, state);
            ::core::hash::Hash::hash(&self.headword_index, state);
            ::core::hash::Hash::hash(&self.dictionary, state);
            ::core::hash::Hash::hash(&self.dictionary_index, state);
            ::core::hash::Hash::hash(&self.dictionary_alias, state);
            ::core::hash::Hash::hash(&self.has_reading, state);
            ::core::hash::Hash::hash(&self.frequency, state);
            ::core::hash::Hash::hash(&self.display_value, state);
            ::core::hash::Hash::hash(&self.display_value_parsed, state)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for TermFrequency {
        #[inline]
        fn partial_cmp(
            &self,
            other: &TermFrequency,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(&self.index, &other.index) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.headword_index,
                        &other.headword_index,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match ::core::cmp::PartialOrd::partial_cmp(
                                &self.dictionary,
                                &other.dictionary,
                            ) {
                                ::core::option::Option::Some(
                                    ::core::cmp::Ordering::Equal,
                                ) => {
                                    match ::core::cmp::PartialOrd::partial_cmp(
                                        &self.dictionary_index,
                                        &other.dictionary_index,
                                    ) {
                                        ::core::option::Option::Some(
                                            ::core::cmp::Ordering::Equal,
                                        ) => {
                                            match ::core::cmp::PartialOrd::partial_cmp(
                                                &self.dictionary_alias,
                                                &other.dictionary_alias,
                                            ) {
                                                ::core::option::Option::Some(
                                                    ::core::cmp::Ordering::Equal,
                                                ) => {
                                                    match ::core::cmp::PartialOrd::partial_cmp(
                                                        &self.has_reading,
                                                        &other.has_reading,
                                                    ) {
                                                        ::core::option::Option::Some(
                                                            ::core::cmp::Ordering::Equal,
                                                        ) => {
                                                            match ::core::cmp::PartialOrd::partial_cmp(
                                                                &self.frequency,
                                                                &other.frequency,
                                                            ) {
                                                                ::core::option::Option::Some(
                                                                    ::core::cmp::Ordering::Equal,
                                                                ) => {
                                                                    match ::core::cmp::PartialOrd::partial_cmp(
                                                                        &self.display_value,
                                                                        &other.display_value,
                                                                    ) {
                                                                        ::core::option::Option::Some(
                                                                            ::core::cmp::Ordering::Equal,
                                                                        ) => {
                                                                            ::core::cmp::PartialOrd::partial_cmp(
                                                                                &self.display_value_parsed,
                                                                                &other.display_value_parsed,
                                                                            )
                                                                        }
                                                                        cmp => cmp,
                                                                    }
                                                                }
                                                                cmp => cmp,
                                                            }
                                                        }
                                                        cmp => cmp,
                                                    }
                                                }
                                                cmp => cmp,
                                            }
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for TermFrequency {
        #[inline]
        fn cmp(&self, other: &TermFrequency) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.index, &other.index) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(
                        &self.headword_index,
                        &other.headword_index,
                    ) {
                        ::core::cmp::Ordering::Equal => {
                            match ::core::cmp::Ord::cmp(
                                &self.dictionary,
                                &other.dictionary,
                            ) {
                                ::core::cmp::Ordering::Equal => {
                                    match ::core::cmp::Ord::cmp(
                                        &self.dictionary_index,
                                        &other.dictionary_index,
                                    ) {
                                        ::core::cmp::Ordering::Equal => {
                                            match ::core::cmp::Ord::cmp(
                                                &self.dictionary_alias,
                                                &other.dictionary_alias,
                                            ) {
                                                ::core::cmp::Ordering::Equal => {
                                                    match ::core::cmp::Ord::cmp(
                                                        &self.has_reading,
                                                        &other.has_reading,
                                                    ) {
                                                        ::core::cmp::Ordering::Equal => {
                                                            match ::core::cmp::Ord::cmp(
                                                                &self.frequency,
                                                                &other.frequency,
                                                            ) {
                                                                ::core::cmp::Ordering::Equal => {
                                                                    match ::core::cmp::Ord::cmp(
                                                                        &self.display_value,
                                                                        &other.display_value,
                                                                    ) {
                                                                        ::core::cmp::Ordering::Equal => {
                                                                            ::core::cmp::Ord::cmp(
                                                                                &self.display_value_parsed,
                                                                                &other.display_value_parsed,
                                                                            )
                                                                        }
                                                                        cmp => cmp,
                                                                    }
                                                                }
                                                                cmp => cmp,
                                                            }
                                                        }
                                                        cmp => cmp,
                                                    }
                                                }
                                                cmp => cmp,
                                            }
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TermFrequency {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "TermFrequency",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "index",
                    &self.index,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "headword_index",
                    &self.headword_index,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "dictionary",
                    &self.dictionary,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "dictionary_index",
                    &self.dictionary_index,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "dictionary_alias",
                    &self.dictionary_alias,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "has_reading",
                    &self.has_reading,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "frequency",
                    &self.frequency,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "display_value",
                    &self.display_value,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "display_value_parsed",
                    &self.display_value_parsed,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TermFrequency {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __field8,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            8u64 => _serde::__private::Ok(__Field::__field8),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "index" => _serde::__private::Ok(__Field::__field0),
                            "headword_index" => _serde::__private::Ok(__Field::__field1),
                            "dictionary" => _serde::__private::Ok(__Field::__field2),
                            "dictionary_index" => {
                                _serde::__private::Ok(__Field::__field3)
                            }
                            "dictionary_alias" => {
                                _serde::__private::Ok(__Field::__field4)
                            }
                            "has_reading" => _serde::__private::Ok(__Field::__field5),
                            "frequency" => _serde::__private::Ok(__Field::__field6),
                            "display_value" => _serde::__private::Ok(__Field::__field7),
                            "display_value_parsed" => {
                                _serde::__private::Ok(__Field::__field8)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"index" => _serde::__private::Ok(__Field::__field0),
                            b"headword_index" => _serde::__private::Ok(__Field::__field1),
                            b"dictionary" => _serde::__private::Ok(__Field::__field2),
                            b"dictionary_index" => {
                                _serde::__private::Ok(__Field::__field3)
                            }
                            b"dictionary_alias" => {
                                _serde::__private::Ok(__Field::__field4)
                            }
                            b"has_reading" => _serde::__private::Ok(__Field::__field5),
                            b"frequency" => _serde::__private::Ok(__Field::__field6),
                            b"display_value" => _serde::__private::Ok(__Field::__field7),
                            b"display_value_parsed" => {
                                _serde::__private::Ok(__Field::__field8)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<TermFrequency>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TermFrequency;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct TermFrequency",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            usize,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct TermFrequency with 9 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            usize,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct TermFrequency with 9 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct TermFrequency with 9 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            usize,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct TermFrequency with 9 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct TermFrequency with 9 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct TermFrequency with 9 elements",
                                    ),
                                );
                            }
                        };
                        let __field6 = match _serde::de::SeqAccess::next_element::<
                            i128,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        6usize,
                                        &"struct TermFrequency with 9 elements",
                                    ),
                                );
                            }
                        };
                        let __field7 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        7usize,
                                        &"struct TermFrequency with 9 elements",
                                    ),
                                );
                            }
                        };
                        let __field8 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        8usize,
                                        &"struct TermFrequency with 9 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(TermFrequency {
                            index: __field0,
                            headword_index: __field1,
                            dictionary: __field2,
                            dictionary_index: __field3,
                            dictionary_alias: __field4,
                            has_reading: __field5,
                            frequency: __field6,
                            display_value: __field7,
                            display_value_parsed: __field8,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<usize> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<usize> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<usize> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field6: _serde::__private::Option<i128> = _serde::__private::None;
                        let mut __field7: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field8: _serde::__private::Option<bool> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("index"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<usize>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "headword_index",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<usize>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "dictionary",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "dictionary_index",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<usize>(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "dictionary_alias",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "has_reading",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "frequency",
                                            ),
                                        );
                                    }
                                    __field6 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i128>(&mut __map)?,
                                    );
                                }
                                __Field::__field7 => {
                                    if _serde::__private::Option::is_some(&__field7) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "display_value",
                                            ),
                                        );
                                    }
                                    __field7 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field8 => {
                                    if _serde::__private::Option::is_some(&__field8) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "display_value_parsed",
                                            ),
                                        );
                                    }
                                    __field8 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("index")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("headword_index")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("dictionary")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("dictionary_index")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("dictionary_alias")?
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("has_reading")?
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("frequency")?
                            }
                        };
                        let __field7 = match __field7 {
                            _serde::__private::Some(__field7) => __field7,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("display_value")?
                            }
                        };
                        let __field8 = match __field8 {
                            _serde::__private::Some(__field8) => __field8,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "display_value_parsed",
                                )?
                            }
                        };
                        _serde::__private::Ok(TermFrequency {
                            index: __field0,
                            headword_index: __field1,
                            dictionary: __field2,
                            dictionary_index: __field3,
                            dictionary_alias: __field4,
                            has_reading: __field5,
                            frequency: __field6,
                            display_value: __field7,
                            display_value_parsed: __field8,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "index",
                    "headword_index",
                    "dictionary",
                    "dictionary_index",
                    "dictionary_alias",
                    "has_reading",
                    "frequency",
                    "display_value",
                    "display_value_parsed",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "TermFrequency",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<TermFrequency>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    /// A term headword is a combination of a term, reading, and auxiliary information.
    pub struct TermHeadword {
        /// The original order of the headword, which is usually used for sorting.
        pub index: usize,
        /// The text for the term.
        pub term: String,
        /// The reading of the term.
        pub reading: String,
        /// The sources of the term.
        pub sources: Vec<TermSource>,
        /// Tags for the headword.
        pub tags: Vec<DictionaryTag>,
        /// List of word classes (part of speech) for the headword.
        pub word_classes: Vec<String>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TermHeadword {
        #[inline]
        fn clone(&self) -> TermHeadword {
            TermHeadword {
                index: ::core::clone::Clone::clone(&self.index),
                term: ::core::clone::Clone::clone(&self.term),
                reading: ::core::clone::Clone::clone(&self.reading),
                sources: ::core::clone::Clone::clone(&self.sources),
                tags: ::core::clone::Clone::clone(&self.tags),
                word_classes: ::core::clone::Clone::clone(&self.word_classes),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TermHeadword {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "index",
                "term",
                "reading",
                "sources",
                "tags",
                "word_classes",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.index,
                &self.term,
                &self.reading,
                &self.sources,
                &self.tags,
                &&self.word_classes,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "TermHeadword",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TermHeadword {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TermHeadword {
        #[inline]
        fn eq(&self, other: &TermHeadword) -> bool {
            self.index == other.index && self.term == other.term
                && self.reading == other.reading && self.sources == other.sources
                && self.tags == other.tags && self.word_classes == other.word_classes
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for TermHeadword {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<usize>;
            let _: ::core::cmp::AssertParamIsEq<String>;
            let _: ::core::cmp::AssertParamIsEq<Vec<TermSource>>;
            let _: ::core::cmp::AssertParamIsEq<Vec<DictionaryTag>>;
            let _: ::core::cmp::AssertParamIsEq<Vec<String>>;
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for TermHeadword {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.index, state);
            ::core::hash::Hash::hash(&self.term, state);
            ::core::hash::Hash::hash(&self.reading, state);
            ::core::hash::Hash::hash(&self.sources, state);
            ::core::hash::Hash::hash(&self.tags, state);
            ::core::hash::Hash::hash(&self.word_classes, state)
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TermHeadword {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "TermHeadword",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "index",
                    &self.index,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "term",
                    &self.term,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "reading",
                    &self.reading,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "sources",
                    &self.sources,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "tags",
                    &self.tags,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "word_classes",
                    &self.word_classes,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TermHeadword {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "index" => _serde::__private::Ok(__Field::__field0),
                            "term" => _serde::__private::Ok(__Field::__field1),
                            "reading" => _serde::__private::Ok(__Field::__field2),
                            "sources" => _serde::__private::Ok(__Field::__field3),
                            "tags" => _serde::__private::Ok(__Field::__field4),
                            "word_classes" => _serde::__private::Ok(__Field::__field5),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"index" => _serde::__private::Ok(__Field::__field0),
                            b"term" => _serde::__private::Ok(__Field::__field1),
                            b"reading" => _serde::__private::Ok(__Field::__field2),
                            b"sources" => _serde::__private::Ok(__Field::__field3),
                            b"tags" => _serde::__private::Ok(__Field::__field4),
                            b"word_classes" => _serde::__private::Ok(__Field::__field5),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<TermHeadword>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TermHeadword;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct TermHeadword",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            usize,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct TermHeadword with 6 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct TermHeadword with 6 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct TermHeadword with 6 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            Vec<TermSource>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct TermHeadword with 6 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            Vec<DictionaryTag>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct TermHeadword with 6 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            Vec<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct TermHeadword with 6 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(TermHeadword {
                            index: __field0,
                            term: __field1,
                            reading: __field2,
                            sources: __field3,
                            tags: __field4,
                            word_classes: __field5,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<usize> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<Vec<TermSource>> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<
                            Vec<DictionaryTag>,
                        > = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<Vec<String>> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("index"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<usize>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("term"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "reading",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "sources",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<TermSource>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("tags"),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<DictionaryTag>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "word_classes",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("index")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("term")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("reading")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("sources")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("tags")?
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("word_classes")?
                            }
                        };
                        _serde::__private::Ok(TermHeadword {
                            index: __field0,
                            term: __field1,
                            reading: __field2,
                            sources: __field3,
                            tags: __field4,
                            word_classes: __field5,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "index",
                    "term",
                    "reading",
                    "sources",
                    "tags",
                    "word_classes",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "TermHeadword",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<TermHeadword>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    /// A dictionary entry for a term or group of terms.
    pub struct TermDefinition {
        /// Database ID for the definition.
        pub id: String,
        /// The original order of the definition, which is usually used for sorting.
        pub index: usize,
        /// A list of headwords that this definition corresponds to.
        pub headword_indices: Vec<usize>,
        /// The name of the dictionary that the definition information originated from.
        pub dictionary: String,
        /// The index of the dictionary in the original list of dictionaries used for the lookup.
        pub dictionary_index: usize,
        pub dictionary_alias: String,
        /// A score for the definition.
        pub score: i128,
        /// The sorting value based on the determined term frequency.
        pub frequency_order: i128,
        /// A list of database sequence numbers for the term.
        /// A value of `-1` corresponds to no sequence.
        /// The list can have multiple values if multiple definitions with
        /// different sequences have been merged.
        /// The list should always have at least one item.
        pub sequences: Vec<i128>,
        /// Whether or not any of the sources is a primary source. Primary sources are derived from the
        /// original search text, while non-primary sources originate from related terms.
        pub is_primary: bool,
        pub tags: Vec<DictionaryTag>,
        /// The definition entries.
        pub entries: Vec<TermGlossaryContent>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TermDefinition {
        #[inline]
        fn clone(&self) -> TermDefinition {
            TermDefinition {
                id: ::core::clone::Clone::clone(&self.id),
                index: ::core::clone::Clone::clone(&self.index),
                headword_indices: ::core::clone::Clone::clone(&self.headword_indices),
                dictionary: ::core::clone::Clone::clone(&self.dictionary),
                dictionary_index: ::core::clone::Clone::clone(&self.dictionary_index),
                dictionary_alias: ::core::clone::Clone::clone(&self.dictionary_alias),
                score: ::core::clone::Clone::clone(&self.score),
                frequency_order: ::core::clone::Clone::clone(&self.frequency_order),
                sequences: ::core::clone::Clone::clone(&self.sequences),
                is_primary: ::core::clone::Clone::clone(&self.is_primary),
                tags: ::core::clone::Clone::clone(&self.tags),
                entries: ::core::clone::Clone::clone(&self.entries),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TermDefinition {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "id",
                "index",
                "headword_indices",
                "dictionary",
                "dictionary_index",
                "dictionary_alias",
                "score",
                "frequency_order",
                "sequences",
                "is_primary",
                "tags",
                "entries",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.id,
                &self.index,
                &self.headword_indices,
                &self.dictionary,
                &self.dictionary_index,
                &self.dictionary_alias,
                &self.score,
                &self.frequency_order,
                &self.sequences,
                &self.is_primary,
                &self.tags,
                &&self.entries,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "TermDefinition",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TermDefinition {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TermDefinition {
        #[inline]
        fn eq(&self, other: &TermDefinition) -> bool {
            self.id == other.id && self.index == other.index
                && self.headword_indices == other.headword_indices
                && self.dictionary == other.dictionary
                && self.dictionary_index == other.dictionary_index
                && self.dictionary_alias == other.dictionary_alias
                && self.score == other.score
                && self.frequency_order == other.frequency_order
                && self.sequences == other.sequences
                && self.is_primary == other.is_primary && self.tags == other.tags
                && self.entries == other.entries
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TermDefinition {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "TermDefinition",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "id",
                    &self.id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "index",
                    &self.index,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "headword_indices",
                    &self.headword_indices,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "dictionary",
                    &self.dictionary,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "dictionary_index",
                    &self.dictionary_index,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "dictionary_alias",
                    &self.dictionary_alias,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "score",
                    &self.score,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "frequency_order",
                    &self.frequency_order,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "sequences",
                    &self.sequences,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "is_primary",
                    &self.is_primary,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "tags",
                    &self.tags,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "entries",
                    &self.entries,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TermDefinition {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __field8,
                    __field9,
                    __field10,
                    __field11,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            8u64 => _serde::__private::Ok(__Field::__field8),
                            9u64 => _serde::__private::Ok(__Field::__field9),
                            10u64 => _serde::__private::Ok(__Field::__field10),
                            11u64 => _serde::__private::Ok(__Field::__field11),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "id" => _serde::__private::Ok(__Field::__field0),
                            "index" => _serde::__private::Ok(__Field::__field1),
                            "headword_indices" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            "dictionary" => _serde::__private::Ok(__Field::__field3),
                            "dictionary_index" => {
                                _serde::__private::Ok(__Field::__field4)
                            }
                            "dictionary_alias" => {
                                _serde::__private::Ok(__Field::__field5)
                            }
                            "score" => _serde::__private::Ok(__Field::__field6),
                            "frequency_order" => _serde::__private::Ok(__Field::__field7),
                            "sequences" => _serde::__private::Ok(__Field::__field8),
                            "is_primary" => _serde::__private::Ok(__Field::__field9),
                            "tags" => _serde::__private::Ok(__Field::__field10),
                            "entries" => _serde::__private::Ok(__Field::__field11),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"id" => _serde::__private::Ok(__Field::__field0),
                            b"index" => _serde::__private::Ok(__Field::__field1),
                            b"headword_indices" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            b"dictionary" => _serde::__private::Ok(__Field::__field3),
                            b"dictionary_index" => {
                                _serde::__private::Ok(__Field::__field4)
                            }
                            b"dictionary_alias" => {
                                _serde::__private::Ok(__Field::__field5)
                            }
                            b"score" => _serde::__private::Ok(__Field::__field6),
                            b"frequency_order" => {
                                _serde::__private::Ok(__Field::__field7)
                            }
                            b"sequences" => _serde::__private::Ok(__Field::__field8),
                            b"is_primary" => _serde::__private::Ok(__Field::__field9),
                            b"tags" => _serde::__private::Ok(__Field::__field10),
                            b"entries" => _serde::__private::Ok(__Field::__field11),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<TermDefinition>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TermDefinition;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct TermDefinition",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct TermDefinition with 12 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            usize,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct TermDefinition with 12 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            Vec<usize>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct TermDefinition with 12 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct TermDefinition with 12 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            usize,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct TermDefinition with 12 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct TermDefinition with 12 elements",
                                    ),
                                );
                            }
                        };
                        let __field6 = match _serde::de::SeqAccess::next_element::<
                            i128,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        6usize,
                                        &"struct TermDefinition with 12 elements",
                                    ),
                                );
                            }
                        };
                        let __field7 = match _serde::de::SeqAccess::next_element::<
                            i128,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        7usize,
                                        &"struct TermDefinition with 12 elements",
                                    ),
                                );
                            }
                        };
                        let __field8 = match _serde::de::SeqAccess::next_element::<
                            Vec<i128>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        8usize,
                                        &"struct TermDefinition with 12 elements",
                                    ),
                                );
                            }
                        };
                        let __field9 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        9usize,
                                        &"struct TermDefinition with 12 elements",
                                    ),
                                );
                            }
                        };
                        let __field10 = match _serde::de::SeqAccess::next_element::<
                            Vec<DictionaryTag>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        10usize,
                                        &"struct TermDefinition with 12 elements",
                                    ),
                                );
                            }
                        };
                        let __field11 = match _serde::de::SeqAccess::next_element::<
                            Vec<TermGlossaryContent>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        11usize,
                                        &"struct TermDefinition with 12 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(TermDefinition {
                            id: __field0,
                            index: __field1,
                            headword_indices: __field2,
                            dictionary: __field3,
                            dictionary_index: __field4,
                            dictionary_alias: __field5,
                            score: __field6,
                            frequency_order: __field7,
                            sequences: __field8,
                            is_primary: __field9,
                            tags: __field10,
                            entries: __field11,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<usize> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<Vec<usize>> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<usize> = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field6: _serde::__private::Option<i128> = _serde::__private::None;
                        let mut __field7: _serde::__private::Option<i128> = _serde::__private::None;
                        let mut __field8: _serde::__private::Option<Vec<i128>> = _serde::__private::None;
                        let mut __field9: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field10: _serde::__private::Option<
                            Vec<DictionaryTag>,
                        > = _serde::__private::None;
                        let mut __field11: _serde::__private::Option<
                            Vec<TermGlossaryContent>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("index"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<usize>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "headword_indices",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Vec<usize>>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "dictionary",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "dictionary_index",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<usize>(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "dictionary_alias",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("score"),
                                        );
                                    }
                                    __field6 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i128>(&mut __map)?,
                                    );
                                }
                                __Field::__field7 => {
                                    if _serde::__private::Option::is_some(&__field7) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "frequency_order",
                                            ),
                                        );
                                    }
                                    __field7 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i128>(&mut __map)?,
                                    );
                                }
                                __Field::__field8 => {
                                    if _serde::__private::Option::is_some(&__field8) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "sequences",
                                            ),
                                        );
                                    }
                                    __field8 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Vec<i128>>(&mut __map)?,
                                    );
                                }
                                __Field::__field9 => {
                                    if _serde::__private::Option::is_some(&__field9) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "is_primary",
                                            ),
                                        );
                                    }
                                    __field9 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field10 => {
                                    if _serde::__private::Option::is_some(&__field10) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("tags"),
                                        );
                                    }
                                    __field10 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<DictionaryTag>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field11 => {
                                    if _serde::__private::Option::is_some(&__field11) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "entries",
                                            ),
                                        );
                                    }
                                    __field11 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<TermGlossaryContent>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("id")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("index")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("headword_indices")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("dictionary")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("dictionary_index")?
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("dictionary_alias")?
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("score")?
                            }
                        };
                        let __field7 = match __field7 {
                            _serde::__private::Some(__field7) => __field7,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("frequency_order")?
                            }
                        };
                        let __field8 = match __field8 {
                            _serde::__private::Some(__field8) => __field8,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("sequences")?
                            }
                        };
                        let __field9 = match __field9 {
                            _serde::__private::Some(__field9) => __field9,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("is_primary")?
                            }
                        };
                        let __field10 = match __field10 {
                            _serde::__private::Some(__field10) => __field10,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("tags")?
                            }
                        };
                        let __field11 = match __field11 {
                            _serde::__private::Some(__field11) => __field11,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("entries")?
                            }
                        };
                        _serde::__private::Ok(TermDefinition {
                            id: __field0,
                            index: __field1,
                            headword_indices: __field2,
                            dictionary: __field3,
                            dictionary_index: __field4,
                            dictionary_alias: __field5,
                            score: __field6,
                            frequency_order: __field7,
                            sequences: __field8,
                            is_primary: __field9,
                            tags: __field10,
                            entries: __field11,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "id",
                    "index",
                    "headword_indices",
                    "dictionary",
                    "dictionary_index",
                    "dictionary_alias",
                    "score",
                    "frequency_order",
                    "sequences",
                    "is_primary",
                    "tags",
                    "entries",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "TermDefinition",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<TermDefinition>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    /// A term pronunciation represents different ways to pronounce one of the headwords.
    pub struct TermPronunciation {
        /// The original order of the pronunciation, which is usually used for sorting.
        pub index: usize,
        /// Which headword this pronunciation corresponds to.
        pub headword_index: usize,
        /// The name of the dictionary that the pronunciation information originated from.
        pub dictionary: String,
        /// The index of the dictionary in the original list of dictionaries used for the lookup.
        pub dictionary_index: usize,
        /// The alias of the dictionary
        pub dictionary_alias: String,
        /// The pronunciations for the term.
        pub pronunciations: Vec<Pronunciation>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TermPronunciation {
        #[inline]
        fn clone(&self) -> TermPronunciation {
            TermPronunciation {
                index: ::core::clone::Clone::clone(&self.index),
                headword_index: ::core::clone::Clone::clone(&self.headword_index),
                dictionary: ::core::clone::Clone::clone(&self.dictionary),
                dictionary_index: ::core::clone::Clone::clone(&self.dictionary_index),
                dictionary_alias: ::core::clone::Clone::clone(&self.dictionary_alias),
                pronunciations: ::core::clone::Clone::clone(&self.pronunciations),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TermPronunciation {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "index",
                "headword_index",
                "dictionary",
                "dictionary_index",
                "dictionary_alias",
                "pronunciations",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.index,
                &self.headword_index,
                &self.dictionary,
                &self.dictionary_index,
                &self.dictionary_alias,
                &&self.pronunciations,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "TermPronunciation",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TermPronunciation {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TermPronunciation {
        #[inline]
        fn eq(&self, other: &TermPronunciation) -> bool {
            self.index == other.index && self.headword_index == other.headword_index
                && self.dictionary == other.dictionary
                && self.dictionary_index == other.dictionary_index
                && self.dictionary_alias == other.dictionary_alias
                && self.pronunciations == other.pronunciations
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for TermPronunciation {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<usize>;
            let _: ::core::cmp::AssertParamIsEq<String>;
            let _: ::core::cmp::AssertParamIsEq<Vec<Pronunciation>>;
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for TermPronunciation {
        #[inline]
        fn partial_cmp(
            &self,
            other: &TermPronunciation,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(&self.index, &other.index) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.headword_index,
                        &other.headword_index,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match ::core::cmp::PartialOrd::partial_cmp(
                                &self.dictionary,
                                &other.dictionary,
                            ) {
                                ::core::option::Option::Some(
                                    ::core::cmp::Ordering::Equal,
                                ) => {
                                    match ::core::cmp::PartialOrd::partial_cmp(
                                        &self.dictionary_index,
                                        &other.dictionary_index,
                                    ) {
                                        ::core::option::Option::Some(
                                            ::core::cmp::Ordering::Equal,
                                        ) => {
                                            match ::core::cmp::PartialOrd::partial_cmp(
                                                &self.dictionary_alias,
                                                &other.dictionary_alias,
                                            ) {
                                                ::core::option::Option::Some(
                                                    ::core::cmp::Ordering::Equal,
                                                ) => {
                                                    ::core::cmp::PartialOrd::partial_cmp(
                                                        &self.pronunciations,
                                                        &other.pronunciations,
                                                    )
                                                }
                                                cmp => cmp,
                                            }
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for TermPronunciation {
        #[inline]
        fn cmp(&self, other: &TermPronunciation) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.index, &other.index) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(
                        &self.headword_index,
                        &other.headword_index,
                    ) {
                        ::core::cmp::Ordering::Equal => {
                            match ::core::cmp::Ord::cmp(
                                &self.dictionary,
                                &other.dictionary,
                            ) {
                                ::core::cmp::Ordering::Equal => {
                                    match ::core::cmp::Ord::cmp(
                                        &self.dictionary_index,
                                        &other.dictionary_index,
                                    ) {
                                        ::core::cmp::Ordering::Equal => {
                                            match ::core::cmp::Ord::cmp(
                                                &self.dictionary_alias,
                                                &other.dictionary_alias,
                                            ) {
                                                ::core::cmp::Ordering::Equal => {
                                                    ::core::cmp::Ord::cmp(
                                                        &self.pronunciations,
                                                        &other.pronunciations,
                                                    )
                                                }
                                                cmp => cmp,
                                            }
                                        }
                                        cmp => cmp,
                                    }
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for TermPronunciation {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.index, state);
            ::core::hash::Hash::hash(&self.headword_index, state);
            ::core::hash::Hash::hash(&self.dictionary, state);
            ::core::hash::Hash::hash(&self.dictionary_index, state);
            ::core::hash::Hash::hash(&self.dictionary_alias, state);
            ::core::hash::Hash::hash(&self.pronunciations, state)
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TermPronunciation {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "TermPronunciation",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "index",
                    &self.index,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "headword_index",
                    &self.headword_index,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "dictionary",
                    &self.dictionary,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "dictionary_index",
                    &self.dictionary_index,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "dictionary_alias",
                    &self.dictionary_alias,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "pronunciations",
                    &self.pronunciations,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TermPronunciation {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "index" => _serde::__private::Ok(__Field::__field0),
                            "headword_index" => _serde::__private::Ok(__Field::__field1),
                            "dictionary" => _serde::__private::Ok(__Field::__field2),
                            "dictionary_index" => {
                                _serde::__private::Ok(__Field::__field3)
                            }
                            "dictionary_alias" => {
                                _serde::__private::Ok(__Field::__field4)
                            }
                            "pronunciations" => _serde::__private::Ok(__Field::__field5),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"index" => _serde::__private::Ok(__Field::__field0),
                            b"headword_index" => _serde::__private::Ok(__Field::__field1),
                            b"dictionary" => _serde::__private::Ok(__Field::__field2),
                            b"dictionary_index" => {
                                _serde::__private::Ok(__Field::__field3)
                            }
                            b"dictionary_alias" => {
                                _serde::__private::Ok(__Field::__field4)
                            }
                            b"pronunciations" => _serde::__private::Ok(__Field::__field5),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<TermPronunciation>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TermPronunciation;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct TermPronunciation",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            usize,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct TermPronunciation with 6 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            usize,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct TermPronunciation with 6 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct TermPronunciation with 6 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            usize,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct TermPronunciation with 6 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct TermPronunciation with 6 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            Vec<Pronunciation>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct TermPronunciation with 6 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(TermPronunciation {
                            index: __field0,
                            headword_index: __field1,
                            dictionary: __field2,
                            dictionary_index: __field3,
                            dictionary_alias: __field4,
                            pronunciations: __field5,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<usize> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<usize> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<usize> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<
                            Vec<Pronunciation>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("index"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<usize>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "headword_index",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<usize>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "dictionary",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "dictionary_index",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<usize>(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "dictionary_alias",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "pronunciations",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<Pronunciation>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("index")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("headword_index")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("dictionary")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("dictionary_index")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("dictionary_alias")?
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("pronunciations")?
                            }
                        };
                        _serde::__private::Ok(TermPronunciation {
                            index: __field0,
                            headword_index: __field1,
                            dictionary: __field2,
                            dictionary_index: __field3,
                            dictionary_alias: __field4,
                            pronunciations: __field5,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "index",
                    "headword_index",
                    "dictionary",
                    "dictionary_index",
                    "dictionary_alias",
                    "pronunciations",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "TermPronunciation",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<TermPronunciation>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    /// Source information represents how the original text was transformed to get to the final term.
    pub struct TermSource {
        /// The original text that was searched.
        pub original_text: String,
        /// The original text after being transformed, but before applying deinflections.
        pub transformed_text: String,
        /// The final text after applying deinflections.
        pub deinflected_text: String,
        /// How the deinflected text matches the value from the database.
        pub match_type: TermSourceMatchType,
        /// Which field was used to match the database entry.
        pub match_source: TermSourceMatchSource,
        /// Whether or not this source is a primary source. Primary sources are derived from the
        /// original search text, while non-primary sources originate from related terms.
        pub is_primary: bool,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TermSource {
        #[inline]
        fn clone(&self) -> TermSource {
            TermSource {
                original_text: ::core::clone::Clone::clone(&self.original_text),
                transformed_text: ::core::clone::Clone::clone(&self.transformed_text),
                deinflected_text: ::core::clone::Clone::clone(&self.deinflected_text),
                match_type: ::core::clone::Clone::clone(&self.match_type),
                match_source: ::core::clone::Clone::clone(&self.match_source),
                is_primary: ::core::clone::Clone::clone(&self.is_primary),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TermSource {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "original_text",
                "transformed_text",
                "deinflected_text",
                "match_type",
                "match_source",
                "is_primary",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.original_text,
                &self.transformed_text,
                &self.deinflected_text,
                &self.match_type,
                &self.match_source,
                &&self.is_primary,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "TermSource",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TermSource {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TermSource {
        #[inline]
        fn eq(&self, other: &TermSource) -> bool {
            self.original_text == other.original_text
                && self.transformed_text == other.transformed_text
                && self.deinflected_text == other.deinflected_text
                && self.match_type == other.match_type
                && self.match_source == other.match_source
                && self.is_primary == other.is_primary
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for TermSource {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<String>;
            let _: ::core::cmp::AssertParamIsEq<TermSourceMatchType>;
            let _: ::core::cmp::AssertParamIsEq<TermSourceMatchSource>;
            let _: ::core::cmp::AssertParamIsEq<bool>;
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for TermSource {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.original_text, state);
            ::core::hash::Hash::hash(&self.transformed_text, state);
            ::core::hash::Hash::hash(&self.deinflected_text, state);
            ::core::hash::Hash::hash(&self.match_type, state);
            ::core::hash::Hash::hash(&self.match_source, state);
            ::core::hash::Hash::hash(&self.is_primary, state)
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TermSource {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "TermSource",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "original_text",
                    &self.original_text,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "transformed_text",
                    &self.transformed_text,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "deinflected_text",
                    &self.deinflected_text,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "match_type",
                    &self.match_type,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "match_source",
                    &self.match_source,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "is_primary",
                    &self.is_primary,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TermSource {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "original_text" => _serde::__private::Ok(__Field::__field0),
                            "transformed_text" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            "deinflected_text" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            "match_type" => _serde::__private::Ok(__Field::__field3),
                            "match_source" => _serde::__private::Ok(__Field::__field4),
                            "is_primary" => _serde::__private::Ok(__Field::__field5),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"original_text" => _serde::__private::Ok(__Field::__field0),
                            b"transformed_text" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            b"deinflected_text" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            b"match_type" => _serde::__private::Ok(__Field::__field3),
                            b"match_source" => _serde::__private::Ok(__Field::__field4),
                            b"is_primary" => _serde::__private::Ok(__Field::__field5),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<TermSource>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TermSource;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct TermSource",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct TermSource with 6 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct TermSource with 6 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct TermSource with 6 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            TermSourceMatchType,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct TermSource with 6 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            TermSourceMatchSource,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct TermSource with 6 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct TermSource with 6 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(TermSource {
                            original_text: __field0,
                            transformed_text: __field1,
                            deinflected_text: __field2,
                            match_type: __field3,
                            match_source: __field4,
                            is_primary: __field5,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<
                            TermSourceMatchType,
                        > = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<
                            TermSourceMatchSource,
                        > = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<bool> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "original_text",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "transformed_text",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "deinflected_text",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "match_type",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            TermSourceMatchType,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "match_source",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            TermSourceMatchSource,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "is_primary",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("original_text")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("transformed_text")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("deinflected_text")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("match_type")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("match_source")?
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("is_primary")?
                            }
                        };
                        _serde::__private::Ok(TermSource {
                            original_text: __field0,
                            transformed_text: __field1,
                            deinflected_text: __field2,
                            match_type: __field3,
                            match_source: __field4,
                            is_primary: __field5,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "original_text",
                    "transformed_text",
                    "deinflected_text",
                    "match_type",
                    "match_source",
                    "is_primary",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "TermSource",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<TermSource>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    /// A dictionary entry for a term or group of terms.
    pub struct TermDictionaryEntry {
        /// This should always be [TermSourceMatchSource::Term]
        pub entry_type: TermSourceMatchSource,
        /// Whether or not any of the sources is a primary source. Primary sources are derived from the
        /// original search text, while non-primary sources originate from related terms.
        pub is_primary: bool,
        /// Ways that a looked-up word might be an transformed into this term.
        pub text_processor_rule_chain_candidates: Vec<TextProcessorRuleChainCandidate>,
        /// Ways that a looked-up word might be an inflected form of this term.
        pub inflection_rule_chain_candidates: Vec<InflectionRuleChainCandidate>,
        /// A score for the dictionary entry.
        pub score: i128,
        /// The sorting value based on the determined term frequency.
        pub frequency_order: i128,
        /// The alias of the dictionary.
        pub dictionary_alias: String,
        /// The index of the dictionary in the original list of dictionaries used for the lookup.
        pub dictionary_index: usize,
        /// The number of primary sources that had an exact text match for the term.
        pub source_term_exact_match_count: usize,
        /// Whether the term reading matched the primary reading.
        pub match_primary_reading: bool,
        /// The maximum length of the original text for all primary sources.
        pub max_original_text_length: usize,
        /// Headwords for the entry.
        pub headwords: Vec<TermHeadword>,
        /// Definitions for the entry.
        pub definitions: Vec<TermDefinition>,
        /// Pronunciations for the entry.
        pub pronunciations: Vec<TermPronunciation>,
        /// Frequencies for the entry.
        pub frequencies: Vec<TermFrequency>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TermDictionaryEntry {
        #[inline]
        fn clone(&self) -> TermDictionaryEntry {
            TermDictionaryEntry {
                entry_type: ::core::clone::Clone::clone(&self.entry_type),
                is_primary: ::core::clone::Clone::clone(&self.is_primary),
                text_processor_rule_chain_candidates: ::core::clone::Clone::clone(
                    &self.text_processor_rule_chain_candidates,
                ),
                inflection_rule_chain_candidates: ::core::clone::Clone::clone(
                    &self.inflection_rule_chain_candidates,
                ),
                score: ::core::clone::Clone::clone(&self.score),
                frequency_order: ::core::clone::Clone::clone(&self.frequency_order),
                dictionary_alias: ::core::clone::Clone::clone(&self.dictionary_alias),
                dictionary_index: ::core::clone::Clone::clone(&self.dictionary_index),
                source_term_exact_match_count: ::core::clone::Clone::clone(
                    &self.source_term_exact_match_count,
                ),
                match_primary_reading: ::core::clone::Clone::clone(
                    &self.match_primary_reading,
                ),
                max_original_text_length: ::core::clone::Clone::clone(
                    &self.max_original_text_length,
                ),
                headwords: ::core::clone::Clone::clone(&self.headwords),
                definitions: ::core::clone::Clone::clone(&self.definitions),
                pronunciations: ::core::clone::Clone::clone(&self.pronunciations),
                frequencies: ::core::clone::Clone::clone(&self.frequencies),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TermDictionaryEntry {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "entry_type",
                "is_primary",
                "text_processor_rule_chain_candidates",
                "inflection_rule_chain_candidates",
                "score",
                "frequency_order",
                "dictionary_alias",
                "dictionary_index",
                "source_term_exact_match_count",
                "match_primary_reading",
                "max_original_text_length",
                "headwords",
                "definitions",
                "pronunciations",
                "frequencies",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.entry_type,
                &self.is_primary,
                &self.text_processor_rule_chain_candidates,
                &self.inflection_rule_chain_candidates,
                &self.score,
                &self.frequency_order,
                &self.dictionary_alias,
                &self.dictionary_index,
                &self.source_term_exact_match_count,
                &self.match_primary_reading,
                &self.max_original_text_length,
                &self.headwords,
                &self.definitions,
                &self.pronunciations,
                &&self.frequencies,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "TermDictionaryEntry",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TermDictionaryEntry {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TermDictionaryEntry {
        #[inline]
        fn eq(&self, other: &TermDictionaryEntry) -> bool {
            self.entry_type == other.entry_type && self.is_primary == other.is_primary
                && self.text_processor_rule_chain_candidates
                    == other.text_processor_rule_chain_candidates
                && self.inflection_rule_chain_candidates
                    == other.inflection_rule_chain_candidates
                && self.score == other.score
                && self.frequency_order == other.frequency_order
                && self.dictionary_alias == other.dictionary_alias
                && self.dictionary_index == other.dictionary_index
                && self.source_term_exact_match_count
                    == other.source_term_exact_match_count
                && self.match_primary_reading == other.match_primary_reading
                && self.max_original_text_length == other.max_original_text_length
                && self.headwords == other.headwords
                && self.definitions == other.definitions
                && self.pronunciations == other.pronunciations
                && self.frequencies == other.frequencies
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TermDictionaryEntry {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "TermDictionaryEntry",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1
                        + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "entry_type",
                    &self.entry_type,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "is_primary",
                    &self.is_primary,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "text_processor_rule_chain_candidates",
                    &self.text_processor_rule_chain_candidates,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "inflection_rule_chain_candidates",
                    &self.inflection_rule_chain_candidates,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "score",
                    &self.score,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "frequency_order",
                    &self.frequency_order,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "dictionary_alias",
                    &self.dictionary_alias,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "dictionary_index",
                    &self.dictionary_index,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "source_term_exact_match_count",
                    &self.source_term_exact_match_count,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "match_primary_reading",
                    &self.match_primary_reading,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "max_original_text_length",
                    &self.max_original_text_length,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "headwords",
                    &self.headwords,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "definitions",
                    &self.definitions,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "pronunciations",
                    &self.pronunciations,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "frequencies",
                    &self.frequencies,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TermDictionaryEntry {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __field8,
                    __field9,
                    __field10,
                    __field11,
                    __field12,
                    __field13,
                    __field14,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            8u64 => _serde::__private::Ok(__Field::__field8),
                            9u64 => _serde::__private::Ok(__Field::__field9),
                            10u64 => _serde::__private::Ok(__Field::__field10),
                            11u64 => _serde::__private::Ok(__Field::__field11),
                            12u64 => _serde::__private::Ok(__Field::__field12),
                            13u64 => _serde::__private::Ok(__Field::__field13),
                            14u64 => _serde::__private::Ok(__Field::__field14),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "entry_type" => _serde::__private::Ok(__Field::__field0),
                            "is_primary" => _serde::__private::Ok(__Field::__field1),
                            "text_processor_rule_chain_candidates" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            "inflection_rule_chain_candidates" => {
                                _serde::__private::Ok(__Field::__field3)
                            }
                            "score" => _serde::__private::Ok(__Field::__field4),
                            "frequency_order" => _serde::__private::Ok(__Field::__field5),
                            "dictionary_alias" => {
                                _serde::__private::Ok(__Field::__field6)
                            }
                            "dictionary_index" => {
                                _serde::__private::Ok(__Field::__field7)
                            }
                            "source_term_exact_match_count" => {
                                _serde::__private::Ok(__Field::__field8)
                            }
                            "match_primary_reading" => {
                                _serde::__private::Ok(__Field::__field9)
                            }
                            "max_original_text_length" => {
                                _serde::__private::Ok(__Field::__field10)
                            }
                            "headwords" => _serde::__private::Ok(__Field::__field11),
                            "definitions" => _serde::__private::Ok(__Field::__field12),
                            "pronunciations" => _serde::__private::Ok(__Field::__field13),
                            "frequencies" => _serde::__private::Ok(__Field::__field14),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"entry_type" => _serde::__private::Ok(__Field::__field0),
                            b"is_primary" => _serde::__private::Ok(__Field::__field1),
                            b"text_processor_rule_chain_candidates" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            b"inflection_rule_chain_candidates" => {
                                _serde::__private::Ok(__Field::__field3)
                            }
                            b"score" => _serde::__private::Ok(__Field::__field4),
                            b"frequency_order" => {
                                _serde::__private::Ok(__Field::__field5)
                            }
                            b"dictionary_alias" => {
                                _serde::__private::Ok(__Field::__field6)
                            }
                            b"dictionary_index" => {
                                _serde::__private::Ok(__Field::__field7)
                            }
                            b"source_term_exact_match_count" => {
                                _serde::__private::Ok(__Field::__field8)
                            }
                            b"match_primary_reading" => {
                                _serde::__private::Ok(__Field::__field9)
                            }
                            b"max_original_text_length" => {
                                _serde::__private::Ok(__Field::__field10)
                            }
                            b"headwords" => _serde::__private::Ok(__Field::__field11),
                            b"definitions" => _serde::__private::Ok(__Field::__field12),
                            b"pronunciations" => {
                                _serde::__private::Ok(__Field::__field13)
                            }
                            b"frequencies" => _serde::__private::Ok(__Field::__field14),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<TermDictionaryEntry>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TermDictionaryEntry;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct TermDictionaryEntry",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            TermSourceMatchSource,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct TermDictionaryEntry with 15 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct TermDictionaryEntry with 15 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            Vec<TextProcessorRuleChainCandidate>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct TermDictionaryEntry with 15 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            Vec<InflectionRuleChainCandidate>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct TermDictionaryEntry with 15 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            i128,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct TermDictionaryEntry with 15 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            i128,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct TermDictionaryEntry with 15 elements",
                                    ),
                                );
                            }
                        };
                        let __field6 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        6usize,
                                        &"struct TermDictionaryEntry with 15 elements",
                                    ),
                                );
                            }
                        };
                        let __field7 = match _serde::de::SeqAccess::next_element::<
                            usize,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        7usize,
                                        &"struct TermDictionaryEntry with 15 elements",
                                    ),
                                );
                            }
                        };
                        let __field8 = match _serde::de::SeqAccess::next_element::<
                            usize,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        8usize,
                                        &"struct TermDictionaryEntry with 15 elements",
                                    ),
                                );
                            }
                        };
                        let __field9 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        9usize,
                                        &"struct TermDictionaryEntry with 15 elements",
                                    ),
                                );
                            }
                        };
                        let __field10 = match _serde::de::SeqAccess::next_element::<
                            usize,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        10usize,
                                        &"struct TermDictionaryEntry with 15 elements",
                                    ),
                                );
                            }
                        };
                        let __field11 = match _serde::de::SeqAccess::next_element::<
                            Vec<TermHeadword>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        11usize,
                                        &"struct TermDictionaryEntry with 15 elements",
                                    ),
                                );
                            }
                        };
                        let __field12 = match _serde::de::SeqAccess::next_element::<
                            Vec<TermDefinition>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        12usize,
                                        &"struct TermDictionaryEntry with 15 elements",
                                    ),
                                );
                            }
                        };
                        let __field13 = match _serde::de::SeqAccess::next_element::<
                            Vec<TermPronunciation>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        13usize,
                                        &"struct TermDictionaryEntry with 15 elements",
                                    ),
                                );
                            }
                        };
                        let __field14 = match _serde::de::SeqAccess::next_element::<
                            Vec<TermFrequency>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        14usize,
                                        &"struct TermDictionaryEntry with 15 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(TermDictionaryEntry {
                            entry_type: __field0,
                            is_primary: __field1,
                            text_processor_rule_chain_candidates: __field2,
                            inflection_rule_chain_candidates: __field3,
                            score: __field4,
                            frequency_order: __field5,
                            dictionary_alias: __field6,
                            dictionary_index: __field7,
                            source_term_exact_match_count: __field8,
                            match_primary_reading: __field9,
                            max_original_text_length: __field10,
                            headwords: __field11,
                            definitions: __field12,
                            pronunciations: __field13,
                            frequencies: __field14,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            TermSourceMatchSource,
                        > = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<
                            Vec<TextProcessorRuleChainCandidate>,
                        > = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<
                            Vec<InflectionRuleChainCandidate>,
                        > = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<i128> = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<i128> = _serde::__private::None;
                        let mut __field6: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field7: _serde::__private::Option<usize> = _serde::__private::None;
                        let mut __field8: _serde::__private::Option<usize> = _serde::__private::None;
                        let mut __field9: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field10: _serde::__private::Option<usize> = _serde::__private::None;
                        let mut __field11: _serde::__private::Option<
                            Vec<TermHeadword>,
                        > = _serde::__private::None;
                        let mut __field12: _serde::__private::Option<
                            Vec<TermDefinition>,
                        > = _serde::__private::None;
                        let mut __field13: _serde::__private::Option<
                            Vec<TermPronunciation>,
                        > = _serde::__private::None;
                        let mut __field14: _serde::__private::Option<
                            Vec<TermFrequency>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "entry_type",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            TermSourceMatchSource,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "is_primary",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "text_processor_rule_chain_candidates",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<TextProcessorRuleChainCandidate>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "inflection_rule_chain_candidates",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<InflectionRuleChainCandidate>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("score"),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i128>(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "frequency_order",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i128>(&mut __map)?,
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "dictionary_alias",
                                            ),
                                        );
                                    }
                                    __field6 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field7 => {
                                    if _serde::__private::Option::is_some(&__field7) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "dictionary_index",
                                            ),
                                        );
                                    }
                                    __field7 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<usize>(&mut __map)?,
                                    );
                                }
                                __Field::__field8 => {
                                    if _serde::__private::Option::is_some(&__field8) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "source_term_exact_match_count",
                                            ),
                                        );
                                    }
                                    __field8 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<usize>(&mut __map)?,
                                    );
                                }
                                __Field::__field9 => {
                                    if _serde::__private::Option::is_some(&__field9) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "match_primary_reading",
                                            ),
                                        );
                                    }
                                    __field9 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field10 => {
                                    if _serde::__private::Option::is_some(&__field10) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "max_original_text_length",
                                            ),
                                        );
                                    }
                                    __field10 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<usize>(&mut __map)?,
                                    );
                                }
                                __Field::__field11 => {
                                    if _serde::__private::Option::is_some(&__field11) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "headwords",
                                            ),
                                        );
                                    }
                                    __field11 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<TermHeadword>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field12 => {
                                    if _serde::__private::Option::is_some(&__field12) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "definitions",
                                            ),
                                        );
                                    }
                                    __field12 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<TermDefinition>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field13 => {
                                    if _serde::__private::Option::is_some(&__field13) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "pronunciations",
                                            ),
                                        );
                                    }
                                    __field13 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<TermPronunciation>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field14 => {
                                    if _serde::__private::Option::is_some(&__field14) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "frequencies",
                                            ),
                                        );
                                    }
                                    __field14 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<TermFrequency>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("entry_type")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("is_primary")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "text_processor_rule_chain_candidates",
                                )?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "inflection_rule_chain_candidates",
                                )?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("score")?
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("frequency_order")?
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("dictionary_alias")?
                            }
                        };
                        let __field7 = match __field7 {
                            _serde::__private::Some(__field7) => __field7,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("dictionary_index")?
                            }
                        };
                        let __field8 = match __field8 {
                            _serde::__private::Some(__field8) => __field8,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "source_term_exact_match_count",
                                )?
                            }
                        };
                        let __field9 = match __field9 {
                            _serde::__private::Some(__field9) => __field9,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "match_primary_reading",
                                )?
                            }
                        };
                        let __field10 = match __field10 {
                            _serde::__private::Some(__field10) => __field10,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "max_original_text_length",
                                )?
                            }
                        };
                        let __field11 = match __field11 {
                            _serde::__private::Some(__field11) => __field11,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("headwords")?
                            }
                        };
                        let __field12 = match __field12 {
                            _serde::__private::Some(__field12) => __field12,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("definitions")?
                            }
                        };
                        let __field13 = match __field13 {
                            _serde::__private::Some(__field13) => __field13,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("pronunciations")?
                            }
                        };
                        let __field14 = match __field14 {
                            _serde::__private::Some(__field14) => __field14,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("frequencies")?
                            }
                        };
                        _serde::__private::Ok(TermDictionaryEntry {
                            entry_type: __field0,
                            is_primary: __field1,
                            text_processor_rule_chain_candidates: __field2,
                            inflection_rule_chain_candidates: __field3,
                            score: __field4,
                            frequency_order: __field5,
                            dictionary_alias: __field6,
                            dictionary_index: __field7,
                            source_term_exact_match_count: __field8,
                            match_primary_reading: __field9,
                            max_original_text_length: __field10,
                            headwords: __field11,
                            definitions: __field12,
                            pronunciations: __field13,
                            frequencies: __field14,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "entry_type",
                    "is_primary",
                    "text_processor_rule_chain_candidates",
                    "inflection_rule_chain_candidates",
                    "score",
                    "frequency_order",
                    "dictionary_alias",
                    "dictionary_index",
                    "source_term_exact_match_count",
                    "match_primary_reading",
                    "max_original_text_length",
                    "headwords",
                    "definitions",
                    "pronunciations",
                    "frequencies",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "TermDictionaryEntry",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<TermDictionaryEntry>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
}
mod dictionary_data {
    use crate::database::dictionary_database::{DBMetaType, TermMetaPhoneticData};
    use crate::database::dictionary_importer::FrequencyMode;
    use crate::dictionary::VecNumOrNum;
    use crate::structured_content::ImageElement;
    use native_db::{Key, ToKey};
    use bimap::BiHashMap;
    use indexmap::IndexMap;
    use serde_untagged::UntaggedEnumVisitor;
    use serde::{Deserialize, Deserializer, Serialize};
    use std::string::String;
    use std::sync::LazyLock;
    trait StrMacro {
        fn from_static_str(s: &'static ::core::primitive::str) -> Self;
    }
    impl StrMacro for &::core::primitive::str {
        fn from_static_str(s: &'static ::core::primitive::str) -> Self {
            s
        }
    }
    impl StrMacro for ::std::string::String {
        fn from_static_str(s: &'static ::core::primitive::str) -> Self {
            ::std::borrow::ToOwned::to_owned(s)
        }
    }
    fn main() {
        let _: &str = StrMacro::from_static_str("foo");
        let _: String = StrMacro::from_static_str("foo");
        let _: &'static str = StrMacro::from_static_str("foo");
    }
    #[rustfmt::skip]
    pub static KANA_MAP: LazyLock<BiHashMap<&'static str, &'static str>> = LazyLock::new(||
    {
        BiHashMap::from_iter([
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
            ("", ""),
        ])
    });
    pub enum TermGlossaryType {
        Text,
        Image,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TermGlossaryType {
        #[inline]
        fn clone(&self) -> TermGlossaryType {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for TermGlossaryType {}
    #[automatically_derived]
    impl ::core::fmt::Debug for TermGlossaryType {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    TermGlossaryType::Text => "Text",
                    TermGlossaryType::Image => "Image",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TermGlossaryType {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TermGlossaryType {
        #[inline]
        fn eq(&self, other: &TermGlossaryType) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for TermGlossaryType {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for TermGlossaryType {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_discr, state)
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TermGlossaryType {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    TermGlossaryType::Text => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "TermGlossaryType",
                            0u32,
                            "Text",
                        )
                    }
                    TermGlossaryType::Image => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "TermGlossaryType",
                            1u32,
                            "Image",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TermGlossaryType {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 2",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Text" => _serde::__private::Ok(__Field::__field0),
                            "Image" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Text" => _serde::__private::Ok(__Field::__field0),
                            b"Image" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<TermGlossaryType>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TermGlossaryType;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum TermGlossaryType",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(TermGlossaryType::Text)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(TermGlossaryType::Image)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["Text", "Image"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "TermGlossaryType",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<TermGlossaryType>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    pub struct TermGlossaryImage {
        pub term_glossary_type: TermGlossaryType,
        pub term_image: Option<TermImage>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TermGlossaryImage {
        #[inline]
        fn clone(&self) -> TermGlossaryImage {
            TermGlossaryImage {
                term_glossary_type: ::core::clone::Clone::clone(
                    &self.term_glossary_type,
                ),
                term_image: ::core::clone::Clone::clone(&self.term_image),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TermGlossaryImage {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "TermGlossaryImage",
                "term_glossary_type",
                &self.term_glossary_type,
                "term_image",
                &&self.term_image,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TermGlossaryImage {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TermGlossaryImage {
        #[inline]
        fn eq(&self, other: &TermGlossaryImage) -> bool {
            self.term_glossary_type == other.term_glossary_type
                && self.term_image == other.term_image
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TermGlossaryImage {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "TermGlossaryImage",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "term_glossary_type",
                    &self.term_glossary_type,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "term_image",
                    &self.term_image,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TermGlossaryImage {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "term_glossary_type" => {
                                _serde::__private::Ok(__Field::__field0)
                            }
                            "term_image" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"term_glossary_type" => {
                                _serde::__private::Ok(__Field::__field0)
                            }
                            b"term_image" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<TermGlossaryImage>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TermGlossaryImage;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct TermGlossaryImage",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            TermGlossaryType,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct TermGlossaryImage with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            Option<TermImage>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct TermGlossaryImage with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(TermGlossaryImage {
                            term_glossary_type: __field0,
                            term_image: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<TermGlossaryType> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Option<TermImage>> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "term_glossary_type",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            TermGlossaryType,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "term_image",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<TermImage>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("term_glossary_type")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("term_image")?
                            }
                        };
                        _serde::__private::Ok(TermGlossaryImage {
                            term_glossary_type: __field0,
                            term_image: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "term_glossary_type",
                    "term_image",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "TermGlossaryImage",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<TermGlossaryImage>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    pub struct TermImage {
        pub image_element_base: ImageElement,
        pub vertical_align: Option<()>,
        pub border: Option<()>,
        pub border_radius: Option<()>,
        pub size_units: Option<()>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TermImage {
        #[inline]
        fn clone(&self) -> TermImage {
            TermImage {
                image_element_base: ::core::clone::Clone::clone(
                    &self.image_element_base,
                ),
                vertical_align: ::core::clone::Clone::clone(&self.vertical_align),
                border: ::core::clone::Clone::clone(&self.border),
                border_radius: ::core::clone::Clone::clone(&self.border_radius),
                size_units: ::core::clone::Clone::clone(&self.size_units),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TermImage {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "TermImage",
                "image_element_base",
                &self.image_element_base,
                "vertical_align",
                &self.vertical_align,
                "border",
                &self.border,
                "border_radius",
                &self.border_radius,
                "size_units",
                &&self.size_units,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TermImage {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TermImage {
        #[inline]
        fn eq(&self, other: &TermImage) -> bool {
            self.image_element_base == other.image_element_base
                && self.vertical_align == other.vertical_align
                && self.border == other.border
                && self.border_radius == other.border_radius
                && self.size_units == other.size_units
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TermImage {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "TermImage",
                    false as usize + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "image_element_base",
                    &self.image_element_base,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "vertical_align",
                    &self.vertical_align,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "border",
                    &self.border,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "border_radius",
                    &self.border_radius,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "size_units",
                    &self.size_units,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TermImage {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "image_element_base" => {
                                _serde::__private::Ok(__Field::__field0)
                            }
                            "vertical_align" => _serde::__private::Ok(__Field::__field1),
                            "border" => _serde::__private::Ok(__Field::__field2),
                            "border_radius" => _serde::__private::Ok(__Field::__field3),
                            "size_units" => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"image_element_base" => {
                                _serde::__private::Ok(__Field::__field0)
                            }
                            b"vertical_align" => _serde::__private::Ok(__Field::__field1),
                            b"border" => _serde::__private::Ok(__Field::__field2),
                            b"border_radius" => _serde::__private::Ok(__Field::__field3),
                            b"size_units" => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<TermImage>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TermImage;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct TermImage",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ImageElement,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct TermImage with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            Option<()>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct TermImage with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            Option<()>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct TermImage with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            Option<()>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct TermImage with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            Option<()>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct TermImage with 5 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(TermImage {
                            image_element_base: __field0,
                            vertical_align: __field1,
                            border: __field2,
                            border_radius: __field3,
                            size_units: __field4,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<ImageElement> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Option<()>> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<Option<()>> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<Option<()>> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<Option<()>> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "image_element_base",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ImageElement,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "vertical_align",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Option<()>>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("border"),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Option<()>>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "border_radius",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Option<()>>(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "size_units",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Option<()>>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("image_element_base")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("vertical_align")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("border")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("border_radius")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("size_units")?
                            }
                        };
                        _serde::__private::Ok(TermImage {
                            image_element_base: __field0,
                            vertical_align: __field1,
                            border: __field2,
                            border_radius: __field3,
                            size_units: __field4,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "image_element_base",
                    "vertical_align",
                    "border",
                    "border_radius",
                    "size_units",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "TermImage",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<TermImage>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    /// Represents the metadata of a dictionary.
    pub struct Index {
        /// Title of the dictionary.
        pub title: String,
        /// Revision of the dictionary.
        ///
        /// This value is only used for displaying information.
        pub revision: String,
        /// Whether or not this dictionary contains sequencing information for related terms.
        pub sequenced: Option<bool>,
        /// Format of data found in the JSON data files.
        pub format: Option<u8>,
        /// Alias for format.
        /// Versions can include: `1 - 3`.
        pub version: Option<u8>,
        pub minimum_yomitan_version: Option<String>,
        pub is_updatable: Option<bool>,
        pub index_url: Option<String>,
        pub download_url: Option<String>,
        /// Creator of the dictionary.
        pub author: Option<String>,
        /// URL for the source of the dictionary.
        pub url: Option<String>,
        /// Description of the dictionary data.
        pub description: Option<String>,
        /// Attribution information for the dictionary data.
        pub attribution: Option<String>,
        /// Language of the terms in the dictionary.
        ///
        /// See: [iso639 code list](https://www.loc.gov/standards/iso639-2/php/code_list.php).
        pub source_language: Option<String>,
        /// Main language of the definitions in the dictionary.
        ///
        /// See: [iso639 code list](https://www.loc.gov/standards/iso639-2/php/code_list.php).
        pub target_language: Option<String>,
        pub frequency_mode: Option<FrequencyMode>,
        pub tag_meta: Option<IndexMap<String, IndexTag>>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Index {
        #[inline]
        fn clone(&self) -> Index {
            Index {
                title: ::core::clone::Clone::clone(&self.title),
                revision: ::core::clone::Clone::clone(&self.revision),
                sequenced: ::core::clone::Clone::clone(&self.sequenced),
                format: ::core::clone::Clone::clone(&self.format),
                version: ::core::clone::Clone::clone(&self.version),
                minimum_yomitan_version: ::core::clone::Clone::clone(
                    &self.minimum_yomitan_version,
                ),
                is_updatable: ::core::clone::Clone::clone(&self.is_updatable),
                index_url: ::core::clone::Clone::clone(&self.index_url),
                download_url: ::core::clone::Clone::clone(&self.download_url),
                author: ::core::clone::Clone::clone(&self.author),
                url: ::core::clone::Clone::clone(&self.url),
                description: ::core::clone::Clone::clone(&self.description),
                attribution: ::core::clone::Clone::clone(&self.attribution),
                source_language: ::core::clone::Clone::clone(&self.source_language),
                target_language: ::core::clone::Clone::clone(&self.target_language),
                frequency_mode: ::core::clone::Clone::clone(&self.frequency_mode),
                tag_meta: ::core::clone::Clone::clone(&self.tag_meta),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Index {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "title",
                "revision",
                "sequenced",
                "format",
                "version",
                "minimum_yomitan_version",
                "is_updatable",
                "index_url",
                "download_url",
                "author",
                "url",
                "description",
                "attribution",
                "source_language",
                "target_language",
                "frequency_mode",
                "tag_meta",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.title,
                &self.revision,
                &self.sequenced,
                &self.format,
                &self.version,
                &self.minimum_yomitan_version,
                &self.is_updatable,
                &self.index_url,
                &self.download_url,
                &self.author,
                &self.url,
                &self.description,
                &self.attribution,
                &self.source_language,
                &self.target_language,
                &self.frequency_mode,
                &&self.tag_meta,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(f, "Index", names, values)
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Index {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Index {
        #[inline]
        fn eq(&self, other: &Index) -> bool {
            self.title == other.title && self.revision == other.revision
                && self.sequenced == other.sequenced && self.format == other.format
                && self.version == other.version
                && self.minimum_yomitan_version == other.minimum_yomitan_version
                && self.is_updatable == other.is_updatable
                && self.index_url == other.index_url
                && self.download_url == other.download_url && self.author == other.author
                && self.url == other.url && self.description == other.description
                && self.attribution == other.attribution
                && self.source_language == other.source_language
                && self.target_language == other.target_language
                && self.frequency_mode == other.frequency_mode
                && self.tag_meta == other.tag_meta
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Index {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "Index",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1
                        + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "title",
                    &self.title,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "revision",
                    &self.revision,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "sequenced",
                    &self.sequenced,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "format",
                    &self.format,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "version",
                    &self.version,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "minimum_yomitan_version",
                    &self.minimum_yomitan_version,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "is_updatable",
                    &self.is_updatable,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "index_url",
                    &self.index_url,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "download_url",
                    &self.download_url,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "author",
                    &self.author,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "url",
                    &self.url,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "description",
                    &self.description,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "attribution",
                    &self.attribution,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "source_language",
                    &self.source_language,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "target_language",
                    &self.target_language,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "frequency_mode",
                    &self.frequency_mode,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "tag_meta",
                    &self.tag_meta,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Index {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __field8,
                    __field9,
                    __field10,
                    __field11,
                    __field12,
                    __field13,
                    __field14,
                    __field15,
                    __field16,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            8u64 => _serde::__private::Ok(__Field::__field8),
                            9u64 => _serde::__private::Ok(__Field::__field9),
                            10u64 => _serde::__private::Ok(__Field::__field10),
                            11u64 => _serde::__private::Ok(__Field::__field11),
                            12u64 => _serde::__private::Ok(__Field::__field12),
                            13u64 => _serde::__private::Ok(__Field::__field13),
                            14u64 => _serde::__private::Ok(__Field::__field14),
                            15u64 => _serde::__private::Ok(__Field::__field15),
                            16u64 => _serde::__private::Ok(__Field::__field16),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "title" => _serde::__private::Ok(__Field::__field0),
                            "revision" => _serde::__private::Ok(__Field::__field1),
                            "sequenced" => _serde::__private::Ok(__Field::__field2),
                            "format" => _serde::__private::Ok(__Field::__field3),
                            "version" => _serde::__private::Ok(__Field::__field4),
                            "minimum_yomitan_version" => {
                                _serde::__private::Ok(__Field::__field5)
                            }
                            "is_updatable" => _serde::__private::Ok(__Field::__field6),
                            "index_url" => _serde::__private::Ok(__Field::__field7),
                            "download_url" => _serde::__private::Ok(__Field::__field8),
                            "author" => _serde::__private::Ok(__Field::__field9),
                            "url" => _serde::__private::Ok(__Field::__field10),
                            "description" => _serde::__private::Ok(__Field::__field11),
                            "attribution" => _serde::__private::Ok(__Field::__field12),
                            "source_language" => {
                                _serde::__private::Ok(__Field::__field13)
                            }
                            "target_language" => {
                                _serde::__private::Ok(__Field::__field14)
                            }
                            "frequency_mode" => _serde::__private::Ok(__Field::__field15),
                            "tag_meta" => _serde::__private::Ok(__Field::__field16),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"title" => _serde::__private::Ok(__Field::__field0),
                            b"revision" => _serde::__private::Ok(__Field::__field1),
                            b"sequenced" => _serde::__private::Ok(__Field::__field2),
                            b"format" => _serde::__private::Ok(__Field::__field3),
                            b"version" => _serde::__private::Ok(__Field::__field4),
                            b"minimum_yomitan_version" => {
                                _serde::__private::Ok(__Field::__field5)
                            }
                            b"is_updatable" => _serde::__private::Ok(__Field::__field6),
                            b"index_url" => _serde::__private::Ok(__Field::__field7),
                            b"download_url" => _serde::__private::Ok(__Field::__field8),
                            b"author" => _serde::__private::Ok(__Field::__field9),
                            b"url" => _serde::__private::Ok(__Field::__field10),
                            b"description" => _serde::__private::Ok(__Field::__field11),
                            b"attribution" => _serde::__private::Ok(__Field::__field12),
                            b"source_language" => {
                                _serde::__private::Ok(__Field::__field13)
                            }
                            b"target_language" => {
                                _serde::__private::Ok(__Field::__field14)
                            }
                            b"frequency_mode" => {
                                _serde::__private::Ok(__Field::__field15)
                            }
                            b"tag_meta" => _serde::__private::Ok(__Field::__field16),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Index>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Index;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Index",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Index with 17 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Index with 17 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            Option<bool>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct Index with 17 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            Option<u8>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct Index with 17 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            Option<u8>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct Index with 17 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct Index with 17 elements",
                                    ),
                                );
                            }
                        };
                        let __field6 = match _serde::de::SeqAccess::next_element::<
                            Option<bool>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        6usize,
                                        &"struct Index with 17 elements",
                                    ),
                                );
                            }
                        };
                        let __field7 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        7usize,
                                        &"struct Index with 17 elements",
                                    ),
                                );
                            }
                        };
                        let __field8 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        8usize,
                                        &"struct Index with 17 elements",
                                    ),
                                );
                            }
                        };
                        let __field9 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        9usize,
                                        &"struct Index with 17 elements",
                                    ),
                                );
                            }
                        };
                        let __field10 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        10usize,
                                        &"struct Index with 17 elements",
                                    ),
                                );
                            }
                        };
                        let __field11 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        11usize,
                                        &"struct Index with 17 elements",
                                    ),
                                );
                            }
                        };
                        let __field12 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        12usize,
                                        &"struct Index with 17 elements",
                                    ),
                                );
                            }
                        };
                        let __field13 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        13usize,
                                        &"struct Index with 17 elements",
                                    ),
                                );
                            }
                        };
                        let __field14 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        14usize,
                                        &"struct Index with 17 elements",
                                    ),
                                );
                            }
                        };
                        let __field15 = match _serde::de::SeqAccess::next_element::<
                            Option<FrequencyMode>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        15usize,
                                        &"struct Index with 17 elements",
                                    ),
                                );
                            }
                        };
                        let __field16 = match _serde::de::SeqAccess::next_element::<
                            Option<IndexMap<String, IndexTag>>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        16usize,
                                        &"struct Index with 17 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Index {
                            title: __field0,
                            revision: __field1,
                            sequenced: __field2,
                            format: __field3,
                            version: __field4,
                            minimum_yomitan_version: __field5,
                            is_updatable: __field6,
                            index_url: __field7,
                            download_url: __field8,
                            author: __field9,
                            url: __field10,
                            description: __field11,
                            attribution: __field12,
                            source_language: __field13,
                            target_language: __field14,
                            frequency_mode: __field15,
                            tag_meta: __field16,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<Option<bool>> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<Option<u8>> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<Option<u8>> = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field6: _serde::__private::Option<Option<bool>> = _serde::__private::None;
                        let mut __field7: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field8: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field9: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field10: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field11: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field12: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field13: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field14: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field15: _serde::__private::Option<
                            Option<FrequencyMode>,
                        > = _serde::__private::None;
                        let mut __field16: _serde::__private::Option<
                            Option<IndexMap<String, IndexTag>>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("title"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "revision",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "sequenced",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<bool>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("format"),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Option<u8>>(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "version",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Option<u8>>(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "minimum_yomitan_version",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "is_updatable",
                                            ),
                                        );
                                    }
                                    __field6 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<bool>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field7 => {
                                    if _serde::__private::Option::is_some(&__field7) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "index_url",
                                            ),
                                        );
                                    }
                                    __field7 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field8 => {
                                    if _serde::__private::Option::is_some(&__field8) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "download_url",
                                            ),
                                        );
                                    }
                                    __field8 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field9 => {
                                    if _serde::__private::Option::is_some(&__field9) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("author"),
                                        );
                                    }
                                    __field9 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field10 => {
                                    if _serde::__private::Option::is_some(&__field10) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("url"),
                                        );
                                    }
                                    __field10 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field11 => {
                                    if _serde::__private::Option::is_some(&__field11) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "description",
                                            ),
                                        );
                                    }
                                    __field11 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field12 => {
                                    if _serde::__private::Option::is_some(&__field12) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "attribution",
                                            ),
                                        );
                                    }
                                    __field12 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field13 => {
                                    if _serde::__private::Option::is_some(&__field13) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "source_language",
                                            ),
                                        );
                                    }
                                    __field13 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field14 => {
                                    if _serde::__private::Option::is_some(&__field14) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "target_language",
                                            ),
                                        );
                                    }
                                    __field14 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field15 => {
                                    if _serde::__private::Option::is_some(&__field15) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "frequency_mode",
                                            ),
                                        );
                                    }
                                    __field15 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<FrequencyMode>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field16 => {
                                    if _serde::__private::Option::is_some(&__field16) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "tag_meta",
                                            ),
                                        );
                                    }
                                    __field16 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<IndexMap<String, IndexTag>>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("title")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("revision")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("sequenced")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("format")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("version")?
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "minimum_yomitan_version",
                                )?
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("is_updatable")?
                            }
                        };
                        let __field7 = match __field7 {
                            _serde::__private::Some(__field7) => __field7,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("index_url")?
                            }
                        };
                        let __field8 = match __field8 {
                            _serde::__private::Some(__field8) => __field8,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("download_url")?
                            }
                        };
                        let __field9 = match __field9 {
                            _serde::__private::Some(__field9) => __field9,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("author")?
                            }
                        };
                        let __field10 = match __field10 {
                            _serde::__private::Some(__field10) => __field10,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("url")?
                            }
                        };
                        let __field11 = match __field11 {
                            _serde::__private::Some(__field11) => __field11,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("description")?
                            }
                        };
                        let __field12 = match __field12 {
                            _serde::__private::Some(__field12) => __field12,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("attribution")?
                            }
                        };
                        let __field13 = match __field13 {
                            _serde::__private::Some(__field13) => __field13,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("source_language")?
                            }
                        };
                        let __field14 = match __field14 {
                            _serde::__private::Some(__field14) => __field14,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("target_language")?
                            }
                        };
                        let __field15 = match __field15 {
                            _serde::__private::Some(__field15) => __field15,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("frequency_mode")?
                            }
                        };
                        let __field16 = match __field16 {
                            _serde::__private::Some(__field16) => __field16,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("tag_meta")?
                            }
                        };
                        _serde::__private::Ok(Index {
                            title: __field0,
                            revision: __field1,
                            sequenced: __field2,
                            format: __field3,
                            version: __field4,
                            minimum_yomitan_version: __field5,
                            is_updatable: __field6,
                            index_url: __field7,
                            download_url: __field8,
                            author: __field9,
                            url: __field10,
                            description: __field11,
                            attribution: __field12,
                            source_language: __field13,
                            target_language: __field14,
                            frequency_mode: __field15,
                            tag_meta: __field16,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "title",
                    "revision",
                    "sequenced",
                    "format",
                    "version",
                    "minimum_yomitan_version",
                    "is_updatable",
                    "index_url",
                    "download_url",
                    "author",
                    "url",
                    "description",
                    "attribution",
                    "source_language",
                    "target_language",
                    "frequency_mode",
                    "tag_meta",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Index",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Index>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    /// Tag information for terms and kanji.
    ///
    /// This object is deprecated, and individual tag files should be used instead.
    pub struct IndexTagMeta {
        pub tags: IndexMap<String, IndexTag>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for IndexTagMeta {
        #[inline]
        fn clone(&self) -> IndexTagMeta {
            IndexTagMeta {
                tags: ::core::clone::Clone::clone(&self.tags),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for IndexTagMeta {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "IndexTagMeta",
                "tags",
                &&self.tags,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for IndexTagMeta {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for IndexTagMeta {
        #[inline]
        fn eq(&self, other: &IndexTagMeta) -> bool {
            self.tags == other.tags
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for IndexTagMeta {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "IndexTagMeta",
                    false as usize + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "tags",
                    &self.tags,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for IndexTagMeta {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "tags" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"tags" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<IndexTagMeta>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = IndexTagMeta;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct IndexTagMeta",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            IndexMap<String, IndexTag>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct IndexTagMeta with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(IndexTagMeta { tags: __field0 })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            IndexMap<String, IndexTag>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("tags"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            IndexMap<String, IndexTag>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("tags")?
                            }
                        };
                        _serde::__private::Ok(IndexTagMeta { tags: __field0 })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["tags"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "IndexTagMeta",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<IndexTagMeta>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[deprecated(since = "0.0.1", note = "individual tag files should be used instead")]
    /// Tag information for terms and kanji.
    ///
    /// This object is deprecated, and individual tag files should be used instead.
    pub struct IndexTag {
        category: String,
        order: u16,
        notes: String,
        score: u16,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for IndexTag {
        #[inline]
        fn clone(&self) -> IndexTag {
            IndexTag {
                category: ::core::clone::Clone::clone(&self.category),
                order: ::core::clone::Clone::clone(&self.order),
                notes: ::core::clone::Clone::clone(&self.notes),
                score: ::core::clone::Clone::clone(&self.score),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for IndexTag {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "IndexTag",
                "category",
                &self.category,
                "order",
                &self.order,
                "notes",
                &self.notes,
                "score",
                &&self.score,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for IndexTag {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for IndexTag {
        #[inline]
        fn eq(&self, other: &IndexTag) -> bool {
            self.category == other.category && self.order == other.order
                && self.notes == other.notes && self.score == other.score
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for IndexTag {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "IndexTag",
                    false as usize + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "category",
                    &self.category,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "order",
                    &self.order,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "notes",
                    &self.notes,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "score",
                    &self.score,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for IndexTag {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "category" => _serde::__private::Ok(__Field::__field0),
                            "order" => _serde::__private::Ok(__Field::__field1),
                            "notes" => _serde::__private::Ok(__Field::__field2),
                            "score" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"category" => _serde::__private::Ok(__Field::__field0),
                            b"order" => _serde::__private::Ok(__Field::__field1),
                            b"notes" => _serde::__private::Ok(__Field::__field2),
                            b"score" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<IndexTag>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = IndexTag;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct IndexTag",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct IndexTag with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            u16,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct IndexTag with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct IndexTag with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            u16,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct IndexTag with 4 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(IndexTag {
                            category: __field0,
                            order: __field1,
                            notes: __field2,
                            score: __field3,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<u16> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<u16> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "category",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("order"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u16>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("notes"),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("score"),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u16>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("category")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("order")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("notes")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("score")?
                            }
                        };
                        _serde::__private::Ok(IndexTag {
                            category: __field0,
                            order: __field1,
                            notes: __field2,
                            score: __field3,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "category",
                    "order",
                    "notes",
                    "score",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "IndexTag",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<IndexTag>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    /// Information about a single tag.
    pub struct DictionaryDataTag {
        /// Tag name.
        pub name: String,
        /// Category for the tag.
        pub category: String,
        /// Sorting order for the tag.
        pub order: u64,
        /// Notes for the tag.
        pub notes: String,
        /// Score used to determine popularity.
        ///
        /// Negative values are more rare and positive values are more frequent.
        /// This score is also used to sort search results.
        pub score: i128,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for DictionaryDataTag {
        #[inline]
        fn clone(&self) -> DictionaryDataTag {
            DictionaryDataTag {
                name: ::core::clone::Clone::clone(&self.name),
                category: ::core::clone::Clone::clone(&self.category),
                order: ::core::clone::Clone::clone(&self.order),
                notes: ::core::clone::Clone::clone(&self.notes),
                score: ::core::clone::Clone::clone(&self.score),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for DictionaryDataTag {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "DictionaryDataTag",
                "name",
                &self.name,
                "category",
                &self.category,
                "order",
                &self.order,
                "notes",
                &self.notes,
                "score",
                &&self.score,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for DictionaryDataTag {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for DictionaryDataTag {
        #[inline]
        fn eq(&self, other: &DictionaryDataTag) -> bool {
            self.name == other.name && self.category == other.category
                && self.order == other.order && self.notes == other.notes
                && self.score == other.score
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for DictionaryDataTag {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "DictionaryDataTag",
                    false as usize + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "name",
                    &self.name,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "category",
                    &self.category,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "order",
                    &self.order,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "notes",
                    &self.notes,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "score",
                    &self.score,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for DictionaryDataTag {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "name" => _serde::__private::Ok(__Field::__field0),
                            "category" => _serde::__private::Ok(__Field::__field1),
                            "order" => _serde::__private::Ok(__Field::__field2),
                            "notes" => _serde::__private::Ok(__Field::__field3),
                            "score" => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"name" => _serde::__private::Ok(__Field::__field0),
                            b"category" => _serde::__private::Ok(__Field::__field1),
                            b"order" => _serde::__private::Ok(__Field::__field2),
                            b"notes" => _serde::__private::Ok(__Field::__field3),
                            b"score" => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<DictionaryDataTag>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = DictionaryDataTag;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct DictionaryDataTag",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct DictionaryDataTag with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct DictionaryDataTag with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            u64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct DictionaryDataTag with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct DictionaryDataTag with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            i128,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct DictionaryDataTag with 5 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(DictionaryDataTag {
                            name: __field0,
                            category: __field1,
                            order: __field2,
                            notes: __field3,
                            score: __field4,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<u64> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<i128> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "category",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("order"),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("notes"),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("score"),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i128>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("name")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("category")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("order")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("notes")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("score")?
                            }
                        };
                        _serde::__private::Ok(DictionaryDataTag {
                            name: __field0,
                            category: __field1,
                            order: __field2,
                            notes: __field3,
                            score: __field4,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "name",
                    "category",
                    "order",
                    "notes",
                    "score",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "DictionaryDataTag",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<DictionaryDataTag>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    pub enum TermGlossary {
        Content(Box<TermGlossaryContent>),
        /// This is a tuple struct in js.
        /// If you see an `Array.isArray()` check on a [TermGlossary], its looking for this.
        Deinflection(TermGlossaryDeinflection),
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TermGlossary {
        #[inline]
        fn clone(&self) -> TermGlossary {
            match self {
                TermGlossary::Content(__self_0) => {
                    TermGlossary::Content(::core::clone::Clone::clone(__self_0))
                }
                TermGlossary::Deinflection(__self_0) => {
                    TermGlossary::Deinflection(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TermGlossary {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                TermGlossary::Content(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Content",
                        &__self_0,
                    )
                }
                TermGlossary::Deinflection(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Deinflection",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TermGlossary {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TermGlossary {
        #[inline]
        fn eq(&self, other: &TermGlossary) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
                && match (self, other) {
                    (
                        TermGlossary::Content(__self_0),
                        TermGlossary::Content(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        TermGlossary::Deinflection(__self_0),
                        TermGlossary::Deinflection(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TermGlossary {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    TermGlossary::Content(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "TermGlossary",
                            0u32,
                            "Content",
                            __field0,
                        )
                    }
                    TermGlossary::Deinflection(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "TermGlossary",
                            1u32,
                            "Deinflection",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TermGlossary {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 2",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Content" => _serde::__private::Ok(__Field::__field0),
                            "Deinflection" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Content" => _serde::__private::Ok(__Field::__field0),
                            b"Deinflection" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<TermGlossary>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TermGlossary;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum TermGlossary",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        Box<TermGlossaryContent>,
                                    >(__variant),
                                    TermGlossary::Content,
                                )
                            }
                            (__Field::__field1, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        TermGlossaryDeinflection,
                                    >(__variant),
                                    TermGlossary::Deinflection,
                                )
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["Content", "Deinflection"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "TermGlossary",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<TermGlossary>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    impl Default for TermGlossary {
        fn default() -> Self {
            TermGlossary::Content(Box::default())
        }
    }
    /// The last three values are [`None`] for now because
    /// I have to figure them out lol
    pub struct TermGlossaryContent {
        /// A single string of continuous text containing the entry's definition.
        /// The `entry`'s definition is simply extracted and concatenated-
        /// meaning that there is no formatting.
        pub term_glossary_string: String,
        pub term_glossary_text: Option<TermGlossaryText>,
        pub term_glossary_image: Option<TermGlossaryImage>,
        /// An entry's raw HTML [`StructuredContent`]is converted into a String,
        /// without deserialization.
        /// As such, it is up to the program to render the content properly.
        pub term_glossary_structured_content: Option<TermGlossaryStructuredContent>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TermGlossaryContent {
        #[inline]
        fn clone(&self) -> TermGlossaryContent {
            TermGlossaryContent {
                term_glossary_string: ::core::clone::Clone::clone(
                    &self.term_glossary_string,
                ),
                term_glossary_text: ::core::clone::Clone::clone(
                    &self.term_glossary_text,
                ),
                term_glossary_image: ::core::clone::Clone::clone(
                    &self.term_glossary_image,
                ),
                term_glossary_structured_content: ::core::clone::Clone::clone(
                    &self.term_glossary_structured_content,
                ),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TermGlossaryContent {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "TermGlossaryContent",
                "term_glossary_string",
                &self.term_glossary_string,
                "term_glossary_text",
                &self.term_glossary_text,
                "term_glossary_image",
                &self.term_glossary_image,
                "term_glossary_structured_content",
                &&self.term_glossary_structured_content,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TermGlossaryContent {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TermGlossaryContent {
        #[inline]
        fn eq(&self, other: &TermGlossaryContent) -> bool {
            self.term_glossary_string == other.term_glossary_string
                && self.term_glossary_text == other.term_glossary_text
                && self.term_glossary_image == other.term_glossary_image
                && self.term_glossary_structured_content
                    == other.term_glossary_structured_content
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TermGlossaryContent {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "TermGlossaryContent",
                    false as usize + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "term_glossary_string",
                    &self.term_glossary_string,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "term_glossary_text",
                    &self.term_glossary_text,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "term_glossary_image",
                    &self.term_glossary_image,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "term_glossary_structured_content",
                    &self.term_glossary_structured_content,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TermGlossaryContent {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "term_glossary_string" => {
                                _serde::__private::Ok(__Field::__field0)
                            }
                            "term_glossary_text" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            "term_glossary_image" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            "term_glossary_structured_content" => {
                                _serde::__private::Ok(__Field::__field3)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"term_glossary_string" => {
                                _serde::__private::Ok(__Field::__field0)
                            }
                            b"term_glossary_text" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            b"term_glossary_image" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            b"term_glossary_structured_content" => {
                                _serde::__private::Ok(__Field::__field3)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<TermGlossaryContent>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TermGlossaryContent;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct TermGlossaryContent",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct TermGlossaryContent with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            Option<TermGlossaryText>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct TermGlossaryContent with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            Option<TermGlossaryImage>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct TermGlossaryContent with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            Option<TermGlossaryStructuredContent>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct TermGlossaryContent with 4 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(TermGlossaryContent {
                            term_glossary_string: __field0,
                            term_glossary_text: __field1,
                            term_glossary_image: __field2,
                            term_glossary_structured_content: __field3,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            Option<TermGlossaryText>,
                        > = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<
                            Option<TermGlossaryImage>,
                        > = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<
                            Option<TermGlossaryStructuredContent>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "term_glossary_string",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "term_glossary_text",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<TermGlossaryText>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "term_glossary_image",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<TermGlossaryImage>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "term_glossary_structured_content",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<TermGlossaryStructuredContent>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "term_glossary_string",
                                )?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("term_glossary_text")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("term_glossary_image")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "term_glossary_structured_content",
                                )?
                            }
                        };
                        _serde::__private::Ok(TermGlossaryContent {
                            term_glossary_string: __field0,
                            term_glossary_text: __field1,
                            term_glossary_image: __field2,
                            term_glossary_structured_content: __field3,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "term_glossary_string",
                    "term_glossary_text",
                    "term_glossary_image",
                    "term_glossary_structured_content",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "TermGlossaryContent",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<TermGlossaryContent>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for TermGlossaryContent {
        #[inline]
        fn default() -> TermGlossaryContent {
            TermGlossaryContent {
                term_glossary_string: ::core::default::Default::default(),
                term_glossary_text: ::core::default::Default::default(),
                term_glossary_image: ::core::default::Default::default(),
                term_glossary_structured_content: ::core::default::Default::default(),
            }
        }
    }
    impl TermGlossaryContent {
        pub fn new(
            tgs: String,
            tgt: Option<TermGlossaryText>,
            tgi: Option<TermGlossaryImage>,
            tgsc: Option<TermGlossaryStructuredContent>,
        ) -> Self {
            Self {
                term_glossary_string: tgs,
                term_glossary_text: tgt,
                term_glossary_image: tgi,
                term_glossary_structured_content: tgsc,
            }
        }
    }
    pub struct TermGlossaryText {
        pub term_glossary_type: TermGlossaryType,
        pub text: String,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TermGlossaryText {
        #[inline]
        fn clone(&self) -> TermGlossaryText {
            TermGlossaryText {
                term_glossary_type: ::core::clone::Clone::clone(
                    &self.term_glossary_type,
                ),
                text: ::core::clone::Clone::clone(&self.text),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TermGlossaryText {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "TermGlossaryText",
                "term_glossary_type",
                &self.term_glossary_type,
                "text",
                &&self.text,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TermGlossaryText {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TermGlossaryText {
        #[inline]
        fn eq(&self, other: &TermGlossaryText) -> bool {
            self.term_glossary_type == other.term_glossary_type
                && self.text == other.text
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for TermGlossaryText {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<TermGlossaryType>;
            let _: ::core::cmp::AssertParamIsEq<String>;
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for TermGlossaryText {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.term_glossary_type, state);
            ::core::hash::Hash::hash(&self.text, state)
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TermGlossaryText {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "TermGlossaryText",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "term_glossary_type",
                    &self.term_glossary_type,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "text",
                    &self.text,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TermGlossaryText {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "term_glossary_type" => {
                                _serde::__private::Ok(__Field::__field0)
                            }
                            "text" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"term_glossary_type" => {
                                _serde::__private::Ok(__Field::__field0)
                            }
                            b"text" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<TermGlossaryText>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TermGlossaryText;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct TermGlossaryText",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            TermGlossaryType,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct TermGlossaryText with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct TermGlossaryText with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(TermGlossaryText {
                            term_glossary_type: __field0,
                            text: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<TermGlossaryType> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "term_glossary_type",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            TermGlossaryType,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("text"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("term_glossary_type")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("text")?
                            }
                        };
                        _serde::__private::Ok(TermGlossaryText {
                            term_glossary_type: __field0,
                            text: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["term_glossary_type", "text"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "TermGlossaryText",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<TermGlossaryText>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    /// Represents the structured content of a term.
    ///
    /// An entry's entire HTML [`StructuredContent`] is [`Deserialize`]d into a String and pushed into `content`.
    /// As such, it is up to the program to render `content` properly.
    ///
    /// If the program is unable/unwilling to render html:
    /// See: [`TermV4`]
    pub struct TermGlossaryStructuredContent {
        content: String,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TermGlossaryStructuredContent {
        #[inline]
        fn clone(&self) -> TermGlossaryStructuredContent {
            TermGlossaryStructuredContent {
                content: ::core::clone::Clone::clone(&self.content),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TermGlossaryStructuredContent {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "TermGlossaryStructuredContent",
                "content",
                &&self.content,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TermGlossaryStructuredContent {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TermGlossaryStructuredContent {
        #[inline]
        fn eq(&self, other: &TermGlossaryStructuredContent) -> bool {
            self.content == other.content
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for TermGlossaryStructuredContent {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<String>;
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for TermGlossaryStructuredContent {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.content, state)
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TermGlossaryStructuredContent {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "TermGlossaryStructuredContent",
                    false as usize + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "content",
                    &self.content,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TermGlossaryStructuredContent {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "content" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"content" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<
                        TermGlossaryStructuredContent,
                    >,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TermGlossaryStructuredContent;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct TermGlossaryStructuredContent",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct TermGlossaryStructuredContent with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(TermGlossaryStructuredContent {
                            content: __field0,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "content",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("content")?
                            }
                        };
                        _serde::__private::Ok(TermGlossaryStructuredContent {
                            content: __field0,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["content"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "TermGlossaryStructuredContent",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            TermGlossaryStructuredContent,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    /// Yomichan-like term model.
    ///
    /// Because of how Yomichan is designed, the definition's raw HTML is contained in
    /// [`TermGlossaryContent::term_glossary_structured_content`]/`content` as a String.
    ///
    /// If the program is unable/unwilling to render HTML:
    /// See: [`TermV4`]
    ///
    /// Related: [`TermGlossaryContent`]
    pub struct TermV3 {
        pub expression: String,
        pub reading: String,
        pub definition_tags: Option<String>,
        pub rules: String,
        pub score: i128,
        pub glossary: Vec<TermGlossary>,
        pub sequence: i64,
        pub term_tags: String,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TermV3 {
        #[inline]
        fn clone(&self) -> TermV3 {
            TermV3 {
                expression: ::core::clone::Clone::clone(&self.expression),
                reading: ::core::clone::Clone::clone(&self.reading),
                definition_tags: ::core::clone::Clone::clone(&self.definition_tags),
                rules: ::core::clone::Clone::clone(&self.rules),
                score: ::core::clone::Clone::clone(&self.score),
                glossary: ::core::clone::Clone::clone(&self.glossary),
                sequence: ::core::clone::Clone::clone(&self.sequence),
                term_tags: ::core::clone::Clone::clone(&self.term_tags),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TermV3 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "expression",
                "reading",
                "definition_tags",
                "rules",
                "score",
                "glossary",
                "sequence",
                "term_tags",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.expression,
                &self.reading,
                &self.definition_tags,
                &self.rules,
                &self.score,
                &self.glossary,
                &self.sequence,
                &&self.term_tags,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "TermV3",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TermV3 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TermV3 {
        #[inline]
        fn eq(&self, other: &TermV3) -> bool {
            self.expression == other.expression && self.reading == other.reading
                && self.definition_tags == other.definition_tags
                && self.rules == other.rules && self.score == other.score
                && self.glossary == other.glossary && self.sequence == other.sequence
                && self.term_tags == other.term_tags
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TermV3 {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "TermV3",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "expression",
                    &self.expression,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "reading",
                    &self.reading,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "definition_tags",
                    &self.definition_tags,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "rules",
                    &self.rules,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "score",
                    &self.score,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "glossary",
                    &self.glossary,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "sequence",
                    &self.sequence,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "term_tags",
                    &self.term_tags,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TermV3 {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "expression" => _serde::__private::Ok(__Field::__field0),
                            "reading" => _serde::__private::Ok(__Field::__field1),
                            "definition_tags" => _serde::__private::Ok(__Field::__field2),
                            "rules" => _serde::__private::Ok(__Field::__field3),
                            "score" => _serde::__private::Ok(__Field::__field4),
                            "glossary" => _serde::__private::Ok(__Field::__field5),
                            "sequence" => _serde::__private::Ok(__Field::__field6),
                            "term_tags" => _serde::__private::Ok(__Field::__field7),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"expression" => _serde::__private::Ok(__Field::__field0),
                            b"reading" => _serde::__private::Ok(__Field::__field1),
                            b"definition_tags" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            b"rules" => _serde::__private::Ok(__Field::__field3),
                            b"score" => _serde::__private::Ok(__Field::__field4),
                            b"glossary" => _serde::__private::Ok(__Field::__field5),
                            b"sequence" => _serde::__private::Ok(__Field::__field6),
                            b"term_tags" => _serde::__private::Ok(__Field::__field7),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<TermV3>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TermV3;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct TermV3",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct TermV3 with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct TermV3 with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct TermV3 with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct TermV3 with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            i128,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct TermV3 with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            Vec<TermGlossary>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct TermV3 with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field6 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        6usize,
                                        &"struct TermV3 with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field7 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        7usize,
                                        &"struct TermV3 with 8 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(TermV3 {
                            expression: __field0,
                            reading: __field1,
                            definition_tags: __field2,
                            rules: __field3,
                            score: __field4,
                            glossary: __field5,
                            sequence: __field6,
                            term_tags: __field7,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<i128> = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<Vec<TermGlossary>> = _serde::__private::None;
                        let mut __field6: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field7: _serde::__private::Option<String> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "expression",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "reading",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "definition_tags",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("rules"),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("score"),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i128>(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "glossary",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<TermGlossary>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "sequence",
                                            ),
                                        );
                                    }
                                    __field6 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field7 => {
                                    if _serde::__private::Option::is_some(&__field7) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "term_tags",
                                            ),
                                        );
                                    }
                                    __field7 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("expression")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("reading")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("definition_tags")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("rules")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("score")?
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("glossary")?
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("sequence")?
                            }
                        };
                        let __field7 = match __field7 {
                            _serde::__private::Some(__field7) => __field7,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("term_tags")?
                            }
                        };
                        _serde::__private::Ok(TermV3 {
                            expression: __field0,
                            reading: __field1,
                            definition_tags: __field2,
                            rules: __field3,
                            score: __field4,
                            glossary: __field5,
                            sequence: __field6,
                            term_tags: __field7,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "expression",
                    "reading",
                    "definition_tags",
                    "rules",
                    "score",
                    "glossary",
                    "sequence",
                    "term_tags",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "TermV3",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<TermV3>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for TermV3 {
        #[inline]
        fn default() -> TermV3 {
            TermV3 {
                expression: ::core::default::Default::default(),
                reading: ::core::default::Default::default(),
                definition_tags: ::core::default::Default::default(),
                rules: ::core::default::Default::default(),
                score: ::core::default::Default::default(),
                glossary: ::core::default::Default::default(),
                sequence: ::core::default::Default::default(),
                term_tags: ::core::default::Default::default(),
            }
        }
    }
    /// Custom `Yomichan.rs`-unique term model.
    /// Allows access to `entry` data _(ie: definitions)_ as a concatenated String instead of raw HTML.
    ///
    /// The String data is simply extracted and concatenated-
    /// meaning that there is _no_ formatting; A single string of continuous text.
    ///
    /// If the program _is_ able to render html, this may be preferable:
    /// See: [`TermV3`]
    pub struct TermV4 {
        pub expression: String,
        pub reading: String,
        pub definition_tags: Option<String>,
        pub rules: String,
        pub score: i8,
        pub definition: String,
        pub sequence: i128,
        pub term_tags: String,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TermV4 {
        #[inline]
        fn clone(&self) -> TermV4 {
            TermV4 {
                expression: ::core::clone::Clone::clone(&self.expression),
                reading: ::core::clone::Clone::clone(&self.reading),
                definition_tags: ::core::clone::Clone::clone(&self.definition_tags),
                rules: ::core::clone::Clone::clone(&self.rules),
                score: ::core::clone::Clone::clone(&self.score),
                definition: ::core::clone::Clone::clone(&self.definition),
                sequence: ::core::clone::Clone::clone(&self.sequence),
                term_tags: ::core::clone::Clone::clone(&self.term_tags),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TermV4 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "expression",
                "reading",
                "definition_tags",
                "rules",
                "score",
                "definition",
                "sequence",
                "term_tags",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.expression,
                &self.reading,
                &self.definition_tags,
                &self.rules,
                &self.score,
                &self.definition,
                &self.sequence,
                &&self.term_tags,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "TermV4",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TermV4 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TermV4 {
        #[inline]
        fn eq(&self, other: &TermV4) -> bool {
            self.expression == other.expression && self.reading == other.reading
                && self.definition_tags == other.definition_tags
                && self.rules == other.rules && self.score == other.score
                && self.definition == other.definition && self.sequence == other.sequence
                && self.term_tags == other.term_tags
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TermV4 {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "TermV4",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "expression",
                    &self.expression,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "reading",
                    &self.reading,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "definition_tags",
                    &self.definition_tags,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "rules",
                    &self.rules,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "score",
                    &self.score,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "definition",
                    &self.definition,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "sequence",
                    &self.sequence,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "term_tags",
                    &self.term_tags,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TermV4 {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "expression" => _serde::__private::Ok(__Field::__field0),
                            "reading" => _serde::__private::Ok(__Field::__field1),
                            "definition_tags" => _serde::__private::Ok(__Field::__field2),
                            "rules" => _serde::__private::Ok(__Field::__field3),
                            "score" => _serde::__private::Ok(__Field::__field4),
                            "definition" => _serde::__private::Ok(__Field::__field5),
                            "sequence" => _serde::__private::Ok(__Field::__field6),
                            "term_tags" => _serde::__private::Ok(__Field::__field7),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"expression" => _serde::__private::Ok(__Field::__field0),
                            b"reading" => _serde::__private::Ok(__Field::__field1),
                            b"definition_tags" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            b"rules" => _serde::__private::Ok(__Field::__field3),
                            b"score" => _serde::__private::Ok(__Field::__field4),
                            b"definition" => _serde::__private::Ok(__Field::__field5),
                            b"sequence" => _serde::__private::Ok(__Field::__field6),
                            b"term_tags" => _serde::__private::Ok(__Field::__field7),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<TermV4>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TermV4;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct TermV4",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct TermV4 with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct TermV4 with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct TermV4 with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct TermV4 with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            i8,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct TermV4 with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct TermV4 with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field6 = match _serde::de::SeqAccess::next_element::<
                            i128,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        6usize,
                                        &"struct TermV4 with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field7 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        7usize,
                                        &"struct TermV4 with 8 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(TermV4 {
                            expression: __field0,
                            reading: __field1,
                            definition_tags: __field2,
                            rules: __field3,
                            score: __field4,
                            definition: __field5,
                            sequence: __field6,
                            term_tags: __field7,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<i8> = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field6: _serde::__private::Option<i128> = _serde::__private::None;
                        let mut __field7: _serde::__private::Option<String> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "expression",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "reading",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "definition_tags",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("rules"),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("score"),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i8>(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "definition",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "sequence",
                                            ),
                                        );
                                    }
                                    __field6 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i128>(&mut __map)?,
                                    );
                                }
                                __Field::__field7 => {
                                    if _serde::__private::Option::is_some(&__field7) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "term_tags",
                                            ),
                                        );
                                    }
                                    __field7 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("expression")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("reading")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("definition_tags")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("rules")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("score")?
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("definition")?
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("sequence")?
                            }
                        };
                        let __field7 = match __field7 {
                            _serde::__private::Some(__field7) => __field7,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("term_tags")?
                            }
                        };
                        _serde::__private::Ok(TermV4 {
                            expression: __field0,
                            reading: __field1,
                            definition_tags: __field2,
                            rules: __field3,
                            score: __field4,
                            definition: __field5,
                            sequence: __field6,
                            term_tags: __field7,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "expression",
                    "reading",
                    "definition_tags",
                    "rules",
                    "score",
                    "definition",
                    "sequence",
                    "term_tags",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "TermV4",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<TermV4>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for TermV4 {
        #[inline]
        fn default() -> TermV4 {
            TermV4 {
                expression: ::core::default::Default::default(),
                reading: ::core::default::Default::default(),
                definition_tags: ::core::default::Default::default(),
                rules: ::core::default::Default::default(),
                score: ::core::default::Default::default(),
                definition: ::core::default::Default::default(),
                sequence: ::core::default::Default::default(),
                term_tags: ::core::default::Default::default(),
            }
        }
    }
    /// TermGlossaryDeinflection represents the deinflection information of a term.
    pub struct TermGlossaryDeinflection {
        pub uninflected: String,
        pub inflection_rule_chain: Vec<String>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TermGlossaryDeinflection {
        #[inline]
        fn clone(&self) -> TermGlossaryDeinflection {
            TermGlossaryDeinflection {
                uninflected: ::core::clone::Clone::clone(&self.uninflected),
                inflection_rule_chain: ::core::clone::Clone::clone(
                    &self.inflection_rule_chain,
                ),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TermGlossaryDeinflection {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "TermGlossaryDeinflection",
                "uninflected",
                &self.uninflected,
                "inflection_rule_chain",
                &&self.inflection_rule_chain,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TermGlossaryDeinflection {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TermGlossaryDeinflection {
        #[inline]
        fn eq(&self, other: &TermGlossaryDeinflection) -> bool {
            self.uninflected == other.uninflected
                && self.inflection_rule_chain == other.inflection_rule_chain
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TermGlossaryDeinflection {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "TermGlossaryDeinflection",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "uninflected",
                    &self.uninflected,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "inflection_rule_chain",
                    &self.inflection_rule_chain,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TermGlossaryDeinflection {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "uninflected" => _serde::__private::Ok(__Field::__field0),
                            "inflection_rule_chain" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"uninflected" => _serde::__private::Ok(__Field::__field0),
                            b"inflection_rule_chain" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<TermGlossaryDeinflection>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TermGlossaryDeinflection;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct TermGlossaryDeinflection",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct TermGlossaryDeinflection with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            Vec<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct TermGlossaryDeinflection with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(TermGlossaryDeinflection {
                            uninflected: __field0,
                            inflection_rule_chain: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Vec<String>> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "uninflected",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "inflection_rule_chain",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("uninflected")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "inflection_rule_chain",
                                )?
                            }
                        };
                        _serde::__private::Ok(TermGlossaryDeinflection {
                            uninflected: __field0,
                            inflection_rule_chain: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "uninflected",
                    "inflection_rule_chain",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "TermGlossaryDeinflection",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            TermGlossaryDeinflection,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    pub struct TermMeta {
        pub expression: String,
        pub mode: TermMetaModeType,
        pub data: MetaDataMatchType,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TermMeta {
        #[inline]
        fn clone(&self) -> TermMeta {
            TermMeta {
                expression: ::core::clone::Clone::clone(&self.expression),
                mode: ::core::clone::Clone::clone(&self.mode),
                data: ::core::clone::Clone::clone(&self.data),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TermMeta {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "TermMeta",
                "expression",
                &self.expression,
                "mode",
                &self.mode,
                "data",
                &&self.data,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TermMeta {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TermMeta {
        #[inline]
        fn eq(&self, other: &TermMeta) -> bool {
            self.expression == other.expression && self.mode == other.mode
                && self.data == other.data
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TermMeta {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "TermMeta",
                    false as usize + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "expression",
                    &self.expression,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "mode",
                    &self.mode,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "data",
                    &self.data,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TermMeta {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "expression" => _serde::__private::Ok(__Field::__field0),
                            "mode" => _serde::__private::Ok(__Field::__field1),
                            "data" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"expression" => _serde::__private::Ok(__Field::__field0),
                            b"mode" => _serde::__private::Ok(__Field::__field1),
                            b"data" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<TermMeta>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TermMeta;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct TermMeta",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct TermMeta with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            TermMetaModeType,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct TermMeta with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            MetaDataMatchType,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct TermMeta with 3 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(TermMeta {
                            expression: __field0,
                            mode: __field1,
                            data: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<TermMetaModeType> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<MetaDataMatchType> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "expression",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("mode"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            TermMetaModeType,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("data"),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            MetaDataMatchType,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("expression")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("mode")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("data")?
                            }
                        };
                        _serde::__private::Ok(TermMeta {
                            expression: __field0,
                            mode: __field1,
                            data: __field2,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["expression", "mode", "data"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "TermMeta",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<TermMeta>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    /// The metadata of a term.
    #[serde(untagged)]
    pub enum MetaDataMatchType {
        Frequency(TermMetaFreqDataMatchType),
        Pitch(TermMetaPitchData),
        Phonetic(TermMetaPhoneticData),
    }
    #[automatically_derived]
    impl ::core::clone::Clone for MetaDataMatchType {
        #[inline]
        fn clone(&self) -> MetaDataMatchType {
            match self {
                MetaDataMatchType::Frequency(__self_0) => {
                    MetaDataMatchType::Frequency(::core::clone::Clone::clone(__self_0))
                }
                MetaDataMatchType::Pitch(__self_0) => {
                    MetaDataMatchType::Pitch(::core::clone::Clone::clone(__self_0))
                }
                MetaDataMatchType::Phonetic(__self_0) => {
                    MetaDataMatchType::Phonetic(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for MetaDataMatchType {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                MetaDataMatchType::Frequency(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Frequency",
                        &__self_0,
                    )
                }
                MetaDataMatchType::Pitch(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Pitch",
                        &__self_0,
                    )
                }
                MetaDataMatchType::Phonetic(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Phonetic",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for MetaDataMatchType {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for MetaDataMatchType {
        #[inline]
        fn eq(&self, other: &MetaDataMatchType) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
                && match (self, other) {
                    (
                        MetaDataMatchType::Frequency(__self_0),
                        MetaDataMatchType::Frequency(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        MetaDataMatchType::Pitch(__self_0),
                        MetaDataMatchType::Pitch(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        MetaDataMatchType::Phonetic(__self_0),
                        MetaDataMatchType::Phonetic(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for MetaDataMatchType {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    MetaDataMatchType::Frequency(ref __field0) => {
                        _serde::Serialize::serialize(__field0, __serializer)
                    }
                    MetaDataMatchType::Pitch(ref __field0) => {
                        _serde::Serialize::serialize(__field0, __serializer)
                    }
                    MetaDataMatchType::Phonetic(ref __field0) => {
                        _serde::Serialize::serialize(__field0, __serializer)
                    }
                }
            }
        }
    };
    impl<'de> Deserialize<'de> for MetaDataMatchType {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: Deserializer<'de>,
        {
            serde_untagged::UntaggedEnumVisitor::new()
                .string(|str| {
                    Ok(
                        MetaDataMatchType::Frequency(
                            TermMetaFreqDataMatchType::Generic(
                                GenericFreqData::String(str.to_string()),
                            ),
                        ),
                    )
                })
                .i128(|int| {
                    Ok(
                        MetaDataMatchType::Frequency(
                            TermMetaFreqDataMatchType::Generic(
                                GenericFreqData::Integer(int),
                            ),
                        ),
                    )
                })
                .map(|map| {
                    let value = map.deserialize::<serde_json::Value>()?;
                    #[allow(clippy::if_same_then_else)]
                    if value.get("frequency").is_some() {
                        serde_json::from_value(value)
                            .map(MetaDataMatchType::Frequency)
                            .map_err(serde::de::Error::custom)
                    } else if value.get("value").is_some() {
                        serde_json::from_value(value)
                            .map(MetaDataMatchType::Frequency)
                            .map_err(serde::de::Error::custom)
                    } else if value.get("pitches").is_some() {
                        serde_json::from_value(value)
                            .map(MetaDataMatchType::Pitch)
                            .map_err(serde::de::Error::custom)
                    } else if value.get("transcriptions").is_some() {
                        serde_json::from_value(value)
                            .map(MetaDataMatchType::Phonetic)
                            .map_err(serde::de::Error::custom)
                    } else {
                        Err(
                            serde::de::Error::custom(
                                ::alloc::__export::must_use({
                                    let res = ::alloc::fmt::format(
                                        format_args!("Unknown term meta data type: {0:?}", value),
                                    );
                                    res
                                }),
                            ),
                        )
                    }
                })
                .deserialize(deserializer)
        }
    }
    /// A helper Enum to select the mode for TermMeta data structures.
    #[serde(rename_all = "lowercase")]
    pub enum TermMetaModeType {
        Freq,
        Pitch,
        Ipa,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TermMetaModeType {
        #[inline]
        fn clone(&self) -> TermMetaModeType {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for TermMetaModeType {}
    #[automatically_derived]
    impl ::core::fmt::Debug for TermMetaModeType {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    TermMetaModeType::Freq => "Freq",
                    TermMetaModeType::Pitch => "Pitch",
                    TermMetaModeType::Ipa => "Ipa",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TermMetaModeType {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TermMetaModeType {
        #[inline]
        fn eq(&self, other: &TermMetaModeType) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for TermMetaModeType {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for TermMetaModeType {
        #[inline]
        fn partial_cmp(
            &self,
            other: &TermMetaModeType,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            ::core::cmp::PartialOrd::partial_cmp(&__self_discr, &__arg1_discr)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for TermMetaModeType {
        #[inline]
        fn cmp(&self, other: &TermMetaModeType) -> ::core::cmp::Ordering {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            ::core::cmp::Ord::cmp(&__self_discr, &__arg1_discr)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for TermMetaModeType {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_discr, state)
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TermMetaModeType {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    TermMetaModeType::Freq => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "TermMetaModeType",
                            0u32,
                            "freq",
                        )
                    }
                    TermMetaModeType::Pitch => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "TermMetaModeType",
                            1u32,
                            "pitch",
                        )
                    }
                    TermMetaModeType::Ipa => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "TermMetaModeType",
                            2u32,
                            "ipa",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TermMetaModeType {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 3",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "freq" => _serde::__private::Ok(__Field::__field0),
                            "pitch" => _serde::__private::Ok(__Field::__field1),
                            "ipa" => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"freq" => _serde::__private::Ok(__Field::__field0),
                            b"pitch" => _serde::__private::Ok(__Field::__field1),
                            b"ipa" => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<TermMetaModeType>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TermMetaModeType;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum TermMetaModeType",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(TermMetaModeType::Freq)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(TermMetaModeType::Pitch)
                            }
                            (__Field::__field2, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(TermMetaModeType::Ipa)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["freq", "pitch", "ipa"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "TermMetaModeType",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<TermMetaModeType>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    impl From<TermMetaModeType> for u8 {
        fn from(value: TermMetaModeType) -> Self {
            match value {
                TermMetaModeType::Freq => 0,
                TermMetaModeType::Pitch => 1,
                TermMetaModeType::Ipa => 2,
            }
        }
    }
    /// The frequency metadata of a term.
    ///
    /// This is currently use to [`Deserialize`] terms from
    /// term_meta_bank_$ files.
    pub struct TermMetaFrequency {
        pub expression: String,
        /// This will be `"freq"` in the json.
        pub mode: TermMetaModeType,
        pub data: TermMetaFreqDataMatchType,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TermMetaFrequency {
        #[inline]
        fn clone(&self) -> TermMetaFrequency {
            TermMetaFrequency {
                expression: ::core::clone::Clone::clone(&self.expression),
                mode: ::core::clone::Clone::clone(&self.mode),
                data: ::core::clone::Clone::clone(&self.data),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TermMetaFrequency {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "TermMetaFrequency",
                "expression",
                &self.expression,
                "mode",
                &self.mode,
                "data",
                &&self.data,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TermMetaFrequency {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TermMetaFrequency {
        #[inline]
        fn eq(&self, other: &TermMetaFrequency) -> bool {
            self.expression == other.expression && self.mode == other.mode
                && self.data == other.data
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TermMetaFrequency {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "TermMetaFrequency",
                    false as usize + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "expression",
                    &self.expression,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "mode",
                    &self.mode,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "data",
                    &self.data,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TermMetaFrequency {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "expression" => _serde::__private::Ok(__Field::__field0),
                            "mode" => _serde::__private::Ok(__Field::__field1),
                            "data" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"expression" => _serde::__private::Ok(__Field::__field0),
                            b"mode" => _serde::__private::Ok(__Field::__field1),
                            b"data" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<TermMetaFrequency>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TermMetaFrequency;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct TermMetaFrequency",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct TermMetaFrequency with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            TermMetaModeType,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct TermMetaFrequency with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            TermMetaFreqDataMatchType,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct TermMetaFrequency with 3 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(TermMetaFrequency {
                            expression: __field0,
                            mode: __field1,
                            data: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<TermMetaModeType> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<
                            TermMetaFreqDataMatchType,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "expression",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("mode"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            TermMetaModeType,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("data"),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            TermMetaFreqDataMatchType,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("expression")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("mode")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("data")?
                            }
                        };
                        _serde::__private::Ok(TermMetaFrequency {
                            expression: __field0,
                            mode: __field1,
                            data: __field2,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["expression", "mode", "data"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "TermMetaFrequency",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<TermMetaFrequency>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    pub struct FrequencyInfo {
        pub frequency: i128,
        pub display_value: Option<String>,
        pub display_value_parsed: bool,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for FrequencyInfo {
        #[inline]
        fn clone(&self) -> FrequencyInfo {
            FrequencyInfo {
                frequency: ::core::clone::Clone::clone(&self.frequency),
                display_value: ::core::clone::Clone::clone(&self.display_value),
                display_value_parsed: ::core::clone::Clone::clone(
                    &self.display_value_parsed,
                ),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for FrequencyInfo {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "FrequencyInfo",
                "frequency",
                &self.frequency,
                "display_value",
                &self.display_value,
                "display_value_parsed",
                &&self.display_value_parsed,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for FrequencyInfo {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for FrequencyInfo {
        #[inline]
        fn eq(&self, other: &FrequencyInfo) -> bool {
            self.frequency == other.frequency
                && self.display_value == other.display_value
                && self.display_value_parsed == other.display_value_parsed
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for FrequencyInfo {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "FrequencyInfo",
                    false as usize + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "frequency",
                    &self.frequency,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "display_value",
                    &self.display_value,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "display_value_parsed",
                    &self.display_value_parsed,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for FrequencyInfo {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "frequency" => _serde::__private::Ok(__Field::__field0),
                            "display_value" => _serde::__private::Ok(__Field::__field1),
                            "display_value_parsed" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"frequency" => _serde::__private::Ok(__Field::__field0),
                            b"display_value" => _serde::__private::Ok(__Field::__field1),
                            b"display_value_parsed" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<FrequencyInfo>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = FrequencyInfo;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct FrequencyInfo",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            i128,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct FrequencyInfo with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct FrequencyInfo with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct FrequencyInfo with 3 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(FrequencyInfo {
                            frequency: __field0,
                            display_value: __field1,
                            display_value_parsed: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<i128> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<bool> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "frequency",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i128>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "display_value",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "display_value_parsed",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("frequency")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("display_value")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "display_value_parsed",
                                )?
                            }
                        };
                        _serde::__private::Ok(FrequencyInfo {
                            frequency: __field0,
                            display_value: __field1,
                            display_value_parsed: __field2,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "frequency",
                    "display_value",
                    "display_value_parsed",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "FrequencyInfo",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<FrequencyInfo>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    pub enum TermMetaFreqDataMatchType {
        WithReading(TermMetaFreqDataWithReading),
        Generic(GenericFreqData),
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TermMetaFreqDataMatchType {
        #[inline]
        fn clone(&self) -> TermMetaFreqDataMatchType {
            match self {
                TermMetaFreqDataMatchType::WithReading(__self_0) => {
                    TermMetaFreqDataMatchType::WithReading(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                TermMetaFreqDataMatchType::Generic(__self_0) => {
                    TermMetaFreqDataMatchType::Generic(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TermMetaFreqDataMatchType {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                TermMetaFreqDataMatchType::WithReading(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "WithReading",
                        &__self_0,
                    )
                }
                TermMetaFreqDataMatchType::Generic(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Generic",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TermMetaFreqDataMatchType {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TermMetaFreqDataMatchType {
        #[inline]
        fn eq(&self, other: &TermMetaFreqDataMatchType) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
                && match (self, other) {
                    (
                        TermMetaFreqDataMatchType::WithReading(__self_0),
                        TermMetaFreqDataMatchType::WithReading(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        TermMetaFreqDataMatchType::Generic(__self_0),
                        TermMetaFreqDataMatchType::Generic(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TermMetaFreqDataMatchType {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    TermMetaFreqDataMatchType::WithReading(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "TermMetaFreqDataMatchType",
                            0u32,
                            "WithReading",
                            __field0,
                        )
                    }
                    TermMetaFreqDataMatchType::Generic(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "TermMetaFreqDataMatchType",
                            1u32,
                            "Generic",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TermMetaFreqDataMatchType {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 2",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "WithReading" => _serde::__private::Ok(__Field::__field0),
                            "Generic" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"WithReading" => _serde::__private::Ok(__Field::__field0),
                            b"Generic" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<TermMetaFreqDataMatchType>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TermMetaFreqDataMatchType;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum TermMetaFreqDataMatchType",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        TermMetaFreqDataWithReading,
                                    >(__variant),
                                    TermMetaFreqDataMatchType::WithReading,
                                )
                            }
                            (__Field::__field1, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        GenericFreqData,
                                    >(__variant),
                                    TermMetaFreqDataMatchType::Generic,
                                )
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["WithReading", "Generic"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "TermMetaFreqDataMatchType",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            TermMetaFreqDataMatchType,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    pub enum GenericFreqData {
        Object(FreqObjectData),
        Integer(i128),
        String(String),
    }
    #[automatically_derived]
    impl ::core::clone::Clone for GenericFreqData {
        #[inline]
        fn clone(&self) -> GenericFreqData {
            match self {
                GenericFreqData::Object(__self_0) => {
                    GenericFreqData::Object(::core::clone::Clone::clone(__self_0))
                }
                GenericFreqData::Integer(__self_0) => {
                    GenericFreqData::Integer(::core::clone::Clone::clone(__self_0))
                }
                GenericFreqData::String(__self_0) => {
                    GenericFreqData::String(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for GenericFreqData {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                GenericFreqData::Object(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Object",
                        &__self_0,
                    )
                }
                GenericFreqData::Integer(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Integer",
                        &__self_0,
                    )
                }
                GenericFreqData::String(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "String",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for GenericFreqData {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for GenericFreqData {
        #[inline]
        fn eq(&self, other: &GenericFreqData) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
                && match (self, other) {
                    (
                        GenericFreqData::Object(__self_0),
                        GenericFreqData::Object(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        GenericFreqData::Integer(__self_0),
                        GenericFreqData::Integer(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        GenericFreqData::String(__self_0),
                        GenericFreqData::String(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for GenericFreqData {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    GenericFreqData::Object(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "GenericFreqData",
                            0u32,
                            "Object",
                            __field0,
                        )
                    }
                    GenericFreqData::Integer(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "GenericFreqData",
                            1u32,
                            "Integer",
                            __field0,
                        )
                    }
                    GenericFreqData::String(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "GenericFreqData",
                            2u32,
                            "String",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for GenericFreqData {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 3",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Object" => _serde::__private::Ok(__Field::__field0),
                            "Integer" => _serde::__private::Ok(__Field::__field1),
                            "String" => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Object" => _serde::__private::Ok(__Field::__field0),
                            b"Integer" => _serde::__private::Ok(__Field::__field1),
                            b"String" => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<GenericFreqData>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = GenericFreqData;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum GenericFreqData",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        FreqObjectData,
                                    >(__variant),
                                    GenericFreqData::Object,
                                )
                            }
                            (__Field::__field1, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        i128,
                                    >(__variant),
                                    GenericFreqData::Integer,
                                )
                            }
                            (__Field::__field2, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        String,
                                    >(__variant),
                                    GenericFreqData::String,
                                )
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "Object",
                    "Integer",
                    "String",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "GenericFreqData",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<GenericFreqData>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    pub struct FreqObjectData {
        pub value: i128,
        #[serde(rename = "displayValue")]
        pub display_value: Option<String>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for FreqObjectData {
        #[inline]
        fn clone(&self) -> FreqObjectData {
            FreqObjectData {
                value: ::core::clone::Clone::clone(&self.value),
                display_value: ::core::clone::Clone::clone(&self.display_value),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for FreqObjectData {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "FreqObjectData",
                "value",
                &self.value,
                "display_value",
                &&self.display_value,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for FreqObjectData {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for FreqObjectData {
        #[inline]
        fn eq(&self, other: &FreqObjectData) -> bool {
            self.value == other.value && self.display_value == other.display_value
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for FreqObjectData {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<i128>;
            let _: ::core::cmp::AssertParamIsEq<Option<String>>;
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for FreqObjectData {
        #[inline]
        fn partial_cmp(
            &self,
            other: &FreqObjectData,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(&self.value, &other.value) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    ::core::cmp::PartialOrd::partial_cmp(
                        &self.display_value,
                        &other.display_value,
                    )
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for FreqObjectData {
        #[inline]
        fn cmp(&self, other: &FreqObjectData) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.value, &other.value) {
                ::core::cmp::Ordering::Equal => {
                    ::core::cmp::Ord::cmp(&self.display_value, &other.display_value)
                }
                cmp => cmp,
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for FreqObjectData {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "FreqObjectData",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "value",
                    &self.value,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "displayValue",
                    &self.display_value,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for FreqObjectData {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "value" => _serde::__private::Ok(__Field::__field0),
                            "displayValue" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"value" => _serde::__private::Ok(__Field::__field0),
                            b"displayValue" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<FreqObjectData>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = FreqObjectData;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct FreqObjectData",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            i128,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct FreqObjectData with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct FreqObjectData with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(FreqObjectData {
                            value: __field0,
                            display_value: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<i128> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("value"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i128>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "displayValue",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("value")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("displayValue")?
                            }
                        };
                        _serde::__private::Ok(FreqObjectData {
                            value: __field0,
                            display_value: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["value", "displayValue"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "FreqObjectData",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<FreqObjectData>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    pub struct TermMetaFreqDataWithReading {
        pub reading: String,
        pub frequency: GenericFreqData,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TermMetaFreqDataWithReading {
        #[inline]
        fn clone(&self) -> TermMetaFreqDataWithReading {
            TermMetaFreqDataWithReading {
                reading: ::core::clone::Clone::clone(&self.reading),
                frequency: ::core::clone::Clone::clone(&self.frequency),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TermMetaFreqDataWithReading {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "TermMetaFreqDataWithReading",
                "reading",
                &self.reading,
                "frequency",
                &&self.frequency,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TermMetaFreqDataWithReading {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TermMetaFreqDataWithReading {
        #[inline]
        fn eq(&self, other: &TermMetaFreqDataWithReading) -> bool {
            self.reading == other.reading && self.frequency == other.frequency
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TermMetaFreqDataWithReading {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "TermMetaFreqDataWithReading",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "reading",
                    &self.reading,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "frequency",
                    &self.frequency,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TermMetaFreqDataWithReading {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "reading" => _serde::__private::Ok(__Field::__field0),
                            "frequency" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"reading" => _serde::__private::Ok(__Field::__field0),
                            b"frequency" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<TermMetaFreqDataWithReading>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TermMetaFreqDataWithReading;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct TermMetaFreqDataWithReading",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct TermMetaFreqDataWithReading with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            GenericFreqData,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct TermMetaFreqDataWithReading with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(TermMetaFreqDataWithReading {
                            reading: __field0,
                            frequency: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<GenericFreqData> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "reading",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "frequency",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            GenericFreqData,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("reading")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("frequency")?
                            }
                        };
                        _serde::__private::Ok(TermMetaFreqDataWithReading {
                            reading: __field0,
                            frequency: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["reading", "frequency"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "TermMetaFreqDataWithReading",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            TermMetaFreqDataWithReading,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    impl GenericFreqData {
        pub fn try_get_reading(&self) -> Option<&String> {
            match self {
                Self::Integer(_) => None,
                Self::String(str) => Some(str),
                Self::Object(obj) => obj.display_value.as_ref(),
            }
        }
    }
    /// The pitch metadata of a term.
    pub struct TermMetaPitch {
        expression: String,
        /// This will be `"pitch"` in the json.
        mode: TermMetaModeType,
        data: TermMetaPitchData,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TermMetaPitch {
        #[inline]
        fn clone(&self) -> TermMetaPitch {
            TermMetaPitch {
                expression: ::core::clone::Clone::clone(&self.expression),
                mode: ::core::clone::Clone::clone(&self.mode),
                data: ::core::clone::Clone::clone(&self.data),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TermMetaPitch {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "TermMetaPitch",
                "expression",
                &self.expression,
                "mode",
                &self.mode,
                "data",
                &&self.data,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TermMetaPitch {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TermMetaPitch {
        #[inline]
        fn eq(&self, other: &TermMetaPitch) -> bool {
            self.expression == other.expression && self.mode == other.mode
                && self.data == other.data
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TermMetaPitch {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "TermMetaPitch",
                    false as usize + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "expression",
                    &self.expression,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "mode",
                    &self.mode,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "data",
                    &self.data,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TermMetaPitch {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "expression" => _serde::__private::Ok(__Field::__field0),
                            "mode" => _serde::__private::Ok(__Field::__field1),
                            "data" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"expression" => _serde::__private::Ok(__Field::__field0),
                            b"mode" => _serde::__private::Ok(__Field::__field1),
                            b"data" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<TermMetaPitch>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TermMetaPitch;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct TermMetaPitch",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct TermMetaPitch with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            TermMetaModeType,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct TermMetaPitch with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            TermMetaPitchData,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct TermMetaPitch with 3 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(TermMetaPitch {
                            expression: __field0,
                            mode: __field1,
                            data: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<TermMetaModeType> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<TermMetaPitchData> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "expression",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("mode"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            TermMetaModeType,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("data"),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            TermMetaPitchData,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("expression")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("mode")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("data")?
                            }
                        };
                        _serde::__private::Ok(TermMetaPitch {
                            expression: __field0,
                            mode: __field1,
                            data: __field2,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["expression", "mode", "data"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "TermMetaPitch",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<TermMetaPitch>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    /// List of different pitch accent information for the term and reading combination.
    pub struct Pitch {
        /// Mora position of the pitch accent downstep.
        /// A value of 0 indicates that the word does not have a downstep (heiban).
        pub position: u8,
        /// Positions of a morae with nasal sound.
        pub nasal: Option<VecNumOrNum>,
        /// Positions of morae with devoiced sound.
        pub devoice: Option<VecNumOrNum>,
        /// List of tags for this pitch accent.
        /// This typically corresponds to a certain type of part of speech.
        pub tags: Option<Vec<String>>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Pitch {
        #[inline]
        fn clone(&self) -> Pitch {
            Pitch {
                position: ::core::clone::Clone::clone(&self.position),
                nasal: ::core::clone::Clone::clone(&self.nasal),
                devoice: ::core::clone::Clone::clone(&self.devoice),
                tags: ::core::clone::Clone::clone(&self.tags),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Pitch {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "Pitch",
                "position",
                &self.position,
                "nasal",
                &self.nasal,
                "devoice",
                &self.devoice,
                "tags",
                &&self.tags,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Pitch {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Pitch {
        #[inline]
        fn eq(&self, other: &Pitch) -> bool {
            self.position == other.position && self.nasal == other.nasal
                && self.devoice == other.devoice && self.tags == other.tags
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Pitch {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "Pitch",
                    false as usize + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "position",
                    &self.position,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "nasal",
                    &self.nasal,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "devoice",
                    &self.devoice,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "tags",
                    &self.tags,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Pitch {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "position" => _serde::__private::Ok(__Field::__field0),
                            "nasal" => _serde::__private::Ok(__Field::__field1),
                            "devoice" => _serde::__private::Ok(__Field::__field2),
                            "tags" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"position" => _serde::__private::Ok(__Field::__field0),
                            b"nasal" => _serde::__private::Ok(__Field::__field1),
                            b"devoice" => _serde::__private::Ok(__Field::__field2),
                            b"tags" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Pitch>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Pitch;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Pitch",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            u8,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Pitch with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            Option<VecNumOrNum>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Pitch with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            Option<VecNumOrNum>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct Pitch with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            Option<Vec<String>>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct Pitch with 4 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Pitch {
                            position: __field0,
                            nasal: __field1,
                            devoice: __field2,
                            tags: __field3,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<u8> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            Option<VecNumOrNum>,
                        > = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<
                            Option<VecNumOrNum>,
                        > = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<
                            Option<Vec<String>>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "position",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u8>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("nasal"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<VecNumOrNum>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "devoice",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<VecNumOrNum>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("tags"),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<Vec<String>>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("position")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("nasal")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("devoice")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("tags")?
                            }
                        };
                        _serde::__private::Ok(Pitch {
                            position: __field0,
                            nasal: __field1,
                            devoice: __field2,
                            tags: __field3,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "position",
                    "nasal",
                    "devoice",
                    "tags",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Pitch",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Pitch>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    /// The pitch data of a term.
    pub struct TermMetaPitchData {
        pub reading: String,
        pub pitches: Vec<Pitch>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TermMetaPitchData {
        #[inline]
        fn clone(&self) -> TermMetaPitchData {
            TermMetaPitchData {
                reading: ::core::clone::Clone::clone(&self.reading),
                pitches: ::core::clone::Clone::clone(&self.pitches),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TermMetaPitchData {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "TermMetaPitchData",
                "reading",
                &self.reading,
                "pitches",
                &&self.pitches,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TermMetaPitchData {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TermMetaPitchData {
        #[inline]
        fn eq(&self, other: &TermMetaPitchData) -> bool {
            self.reading == other.reading && self.pitches == other.pitches
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TermMetaPitchData {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "TermMetaPitchData",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "reading",
                    &self.reading,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "pitches",
                    &self.pitches,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TermMetaPitchData {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "reading" => _serde::__private::Ok(__Field::__field0),
                            "pitches" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"reading" => _serde::__private::Ok(__Field::__field0),
                            b"pitches" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<TermMetaPitchData>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TermMetaPitchData;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct TermMetaPitchData",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct TermMetaPitchData with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            Vec<Pitch>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct TermMetaPitchData with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(TermMetaPitchData {
                            reading: __field0,
                            pitches: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Vec<Pitch>> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "reading",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "pitches",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Vec<Pitch>>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("reading")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("pitches")?
                            }
                        };
                        _serde::__private::Ok(TermMetaPitchData {
                            reading: __field0,
                            pitches: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["reading", "pitches"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "TermMetaPitchData",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<TermMetaPitchData>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    pub mod dictionary_data_util {
        use fancy_regex::Regex;
        use std::sync::LazyLock;
        use url::{ParseError as UrlParseError, Url};
        pub static SIMPLE_VERSION_TEST: LazyLock<Regex> = LazyLock::new(|| {
            Regex::new(r"^(\d+\.)*\d+$").unwrap()
        });
        pub fn compare_revisions(current: &str, latest: &str) -> bool {
            if !SIMPLE_VERSION_TEST.is_match(current).unwrap()
                || !SIMPLE_VERSION_TEST.is_match(latest).unwrap()
            {
                return current < latest;
            }
            let current_parts: Vec<u32> = current
                .split('.')
                .map(|part| part.parse::<u32>().unwrap())
                .collect();
            let latest_parts: Vec<u32> = latest
                .split('.')
                .map(|part| part.parse::<u32>().unwrap())
                .collect();
            if current_parts.len() != latest_parts.len() {
                return current < latest;
            }
            for i in 0..current_parts.len() {
                if current_parts[i] != latest_parts[i] {
                    return current_parts[i] < latest_parts[i];
                }
            }
            false
        }
        pub fn validate_url(s: &str) -> Result<(), UrlParseError> {
            let Err(e) = Url::parse(s) else {
                return Ok(());
            };
            Err(e)
        }
    }
}
mod environment {
    use std::{env::consts::OS, sync::LazyLock};
    pub struct EnvironmentInfo {
        paltform: &'static str,
    }
    impl Default for EnvironmentInfo {
        fn default() -> Self {
            Self { paltform: OS }
        }
    }
    pub static CACHED_ENVIRONMENT_INFO: LazyLock<EnvironmentInfo> = LazyLock::new(|| EnvironmentInfo {
        paltform: OS,
    });
}
mod errors {
    use native_db::db_type;
    use snafu::Snafu;
    use std::{error::Error, path::{Path, PathBuf}};
    use thiserror::Error;
    use crate::database::dictionary_importer::DictionarySummaryError;
    pub enum ImportZipError {
        #[error("the zip path: `{0}` does not exist")]
        DoesNotExist(PathBuf),
        #[error("`zip` crate error: {0}")]
        ZipCrate(#[from] zip::result::ZipError),
        #[error("filesystemIO error: {0}")]
        Io(#[from] std::io::Error),
    }
    #[allow(unused_qualifications)]
    #[automatically_derived]
    impl ::thiserror::__private::Error for ImportZipError {
        fn source(
            &self,
        ) -> ::core::option::Option<&(dyn ::thiserror::__private::Error + 'static)> {
            use ::thiserror::__private::AsDynError as _;
            #[allow(deprecated)]
            match self {
                ImportZipError::DoesNotExist { .. } => ::core::option::Option::None,
                ImportZipError::ZipCrate { 0: source, .. } => {
                    ::core::option::Option::Some(source.as_dyn_error())
                }
                ImportZipError::Io { 0: source, .. } => {
                    ::core::option::Option::Some(source.as_dyn_error())
                }
            }
        }
    }
    #[allow(unused_qualifications)]
    #[automatically_derived]
    impl ::core::fmt::Display for ImportZipError {
        fn fmt(&self, __formatter: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            use ::thiserror::__private::AsDisplay as _;
            #[allow(unused_variables, deprecated, clippy::used_underscore_binding)]
            match self {
                ImportZipError::DoesNotExist(_0) => {
                    match (_0.as_display(),) {
                        (__display0,) => {
                            __formatter
                                .write_fmt(
                                    format_args!(
                                        "the zip path: `{0}` does not exist",
                                        __display0,
                                    ),
                                )
                        }
                    }
                }
                ImportZipError::ZipCrate(_0) => {
                    match (_0.as_display(),) {
                        (__display0,) => {
                            __formatter
                                .write_fmt(
                                    format_args!("`zip` crate error: {0}", __display0),
                                )
                        }
                    }
                }
                ImportZipError::Io(_0) => {
                    match (_0.as_display(),) {
                        (__display0,) => {
                            __formatter
                                .write_fmt(
                                    format_args!("filesystemIO error: {0}", __display0),
                                )
                        }
                    }
                }
            }
        }
    }
    #[allow(
        deprecated,
        unused_qualifications,
        clippy::elidable_lifetime_names,
        clippy::needless_lifetimes,
    )]
    #[automatically_derived]
    impl ::core::convert::From<zip::result::ZipError> for ImportZipError {
        fn from(source: zip::result::ZipError) -> Self {
            ImportZipError::ZipCrate {
                0: source,
            }
        }
    }
    #[allow(
        deprecated,
        unused_qualifications,
        clippy::elidable_lifetime_names,
        clippy::needless_lifetimes,
    )]
    #[automatically_derived]
    impl ::core::convert::From<std::io::Error> for ImportZipError {
        fn from(source: std::io::Error) -> Self {
            ImportZipError::Io { 0: source }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ImportZipError {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                ImportZipError::DoesNotExist(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "DoesNotExist",
                        &__self_0,
                    )
                }
                ImportZipError::ZipCrate(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "ZipCrate",
                        &__self_0,
                    )
                }
                ImportZipError::Io(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Io", &__self_0)
                }
            }
        }
    }
    impl ImportZipError {
        pub fn check_zip_paths(paths: &[impl AsRef<Path>]) -> Result<(), Self> {
            for zp in paths {
                let zp = zp.as_ref();
                if !zp.exists() {
                    return Err(Self::DoesNotExist(zp.to_path_buf()));
                }
            }
            Ok(())
        }
    }
    pub enum DictionaryFileError {
        #[error("failed to deserialize file: `{outpath}`\nreason: {reason}")]
        File { outpath: PathBuf, reason: String },
        #[error("no data in term_bank stream, is the file empty?
         file: {0}")]
        Empty(PathBuf),
        #[error("failed to open file: {outpath}\nreason: {reason}")]
        FailedOpen { outpath: PathBuf, reason: String },
    }
    #[allow(unused_qualifications)]
    #[automatically_derived]
    impl ::thiserror::__private::Error for DictionaryFileError {}
    #[allow(unused_qualifications)]
    #[automatically_derived]
    impl ::core::fmt::Display for DictionaryFileError {
        fn fmt(&self, __formatter: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            use ::thiserror::__private::AsDisplay as _;
            #[allow(unused_variables, deprecated, clippy::used_underscore_binding)]
            match self {
                DictionaryFileError::File { outpath, reason } => {
                    match (outpath.as_display(), reason.as_display()) {
                        (__display_outpath, __display_reason) => {
                            __formatter
                                .write_fmt(
                                    format_args!(
                                        "failed to deserialize file: `{0}`\nreason: {1}",
                                        __display_outpath,
                                        __display_reason,
                                    ),
                                )
                        }
                    }
                }
                DictionaryFileError::Empty(_0) => {
                    match (_0.as_display(),) {
                        (__display0,) => {
                            __formatter
                                .write_fmt(
                                    format_args!(
                                        "no data in term_bank stream, is the file empty?\n         file: {0}",
                                        __display0,
                                    ),
                                )
                        }
                    }
                }
                DictionaryFileError::FailedOpen { outpath, reason } => {
                    match (outpath.as_display(), reason.as_display()) {
                        (__display_outpath, __display_reason) => {
                            __formatter
                                .write_fmt(
                                    format_args!(
                                        "failed to open file: {0}\nreason: {1}",
                                        __display_outpath,
                                        __display_reason,
                                    ),
                                )
                        }
                    }
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for DictionaryFileError {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                DictionaryFileError::File { outpath: __self_0, reason: __self_1 } => {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "File",
                        "outpath",
                        __self_0,
                        "reason",
                        &__self_1,
                    )
                }
                DictionaryFileError::Empty(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Empty",
                        &__self_0,
                    )
                }
                DictionaryFileError::FailedOpen {
                    outpath: __self_0,
                    reason: __self_1,
                } => {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "FailedOpen",
                        "outpath",
                        __self_0,
                        "reason",
                        &__self_1,
                    )
                }
            }
        }
    }
    pub enum ImportError {
        #[error("dictionary file error: {0}")]
        DictionaryFile(#[from] DictionaryFileError),
        #[error("{0}")]
        Zip(#[from] ImportZipError),
        #[error("db err: {0}")]
        Database(#[from] Box<db_type::Error>),
        #[error("io err: {0}")]
        IO(#[from] std::io::Error),
        #[error("json err: {0}")]
        Json(#[from] serde_json::error::Error),
        #[error("thread err: {0}")]
        ThreadErr(#[from] std::thread::AccessError),
        #[error("error at line {0}: {1}")]
        LineErr(u32, Box<ImportError>),
        #[error("json err: {0}")]
        Custom(String),
        #[error("failed to deserialize file: {file}
         reason: {e:#?}")]
        InvalidJson { file: PathBuf, e: Option<String> },
        #[error("failed to create summary: {0}")]
        Summary(#[from] DictionarySummaryError),
    }
    #[allow(unused_qualifications)]
    #[automatically_derived]
    impl ::thiserror::__private::Error for ImportError {
        fn source(
            &self,
        ) -> ::core::option::Option<&(dyn ::thiserror::__private::Error + 'static)> {
            use ::thiserror::__private::AsDynError as _;
            #[allow(deprecated)]
            match self {
                ImportError::DictionaryFile { 0: source, .. } => {
                    ::core::option::Option::Some(source.as_dyn_error())
                }
                ImportError::Zip { 0: source, .. } => {
                    ::core::option::Option::Some(source.as_dyn_error())
                }
                ImportError::Database { 0: source, .. } => {
                    ::core::option::Option::Some(source.as_dyn_error())
                }
                ImportError::IO { 0: source, .. } => {
                    ::core::option::Option::Some(source.as_dyn_error())
                }
                ImportError::Json { 0: source, .. } => {
                    ::core::option::Option::Some(source.as_dyn_error())
                }
                ImportError::ThreadErr { 0: source, .. } => {
                    ::core::option::Option::Some(source.as_dyn_error())
                }
                ImportError::LineErr { .. } => ::core::option::Option::None,
                ImportError::Custom { .. } => ::core::option::Option::None,
                ImportError::InvalidJson { .. } => ::core::option::Option::None,
                ImportError::Summary { 0: source, .. } => {
                    ::core::option::Option::Some(source.as_dyn_error())
                }
            }
        }
    }
    #[allow(unused_qualifications)]
    #[automatically_derived]
    impl ::core::fmt::Display for ImportError {
        fn fmt(&self, __formatter: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            use ::thiserror::__private::AsDisplay as _;
            #[allow(unused_variables, deprecated, clippy::used_underscore_binding)]
            match self {
                ImportError::DictionaryFile(_0) => {
                    match (_0.as_display(),) {
                        (__display0,) => {
                            __formatter
                                .write_fmt(
                                    format_args!("dictionary file error: {0}", __display0),
                                )
                        }
                    }
                }
                ImportError::Zip(_0) => {
                    match (_0.as_display(),) {
                        (__display0,) => {
                            __formatter.write_fmt(format_args!("{0}", __display0))
                        }
                    }
                }
                ImportError::Database(_0) => {
                    match (_0.as_display(),) {
                        (__display0,) => {
                            __formatter
                                .write_fmt(format_args!("db err: {0}", __display0))
                        }
                    }
                }
                ImportError::IO(_0) => {
                    match (_0.as_display(),) {
                        (__display0,) => {
                            __formatter
                                .write_fmt(format_args!("io err: {0}", __display0))
                        }
                    }
                }
                ImportError::Json(_0) => {
                    match (_0.as_display(),) {
                        (__display0,) => {
                            __formatter
                                .write_fmt(format_args!("json err: {0}", __display0))
                        }
                    }
                }
                ImportError::ThreadErr(_0) => {
                    match (_0.as_display(),) {
                        (__display0,) => {
                            __formatter
                                .write_fmt(format_args!("thread err: {0}", __display0))
                        }
                    }
                }
                ImportError::LineErr(_0, _1) => {
                    match (_0.as_display(), _1.as_display()) {
                        (__display0, __display1) => {
                            __formatter
                                .write_fmt(
                                    format_args!(
                                        "error at line {0}: {1}",
                                        __display0,
                                        __display1,
                                    ),
                                )
                        }
                    }
                }
                ImportError::Custom(_0) => {
                    match (_0.as_display(),) {
                        (__display0,) => {
                            __formatter
                                .write_fmt(format_args!("json err: {0}", __display0))
                        }
                    }
                }
                ImportError::InvalidJson { file, e } => {
                    match (file.as_display(), e) {
                        (__display_file, __field_e) => {
                            __formatter
                                .write_fmt(
                                    format_args!(
                                        "failed to deserialize file: {0}\n         reason: {1:#?}",
                                        __display_file,
                                        __field_e,
                                    ),
                                )
                        }
                    }
                }
                ImportError::Summary(_0) => {
                    match (_0.as_display(),) {
                        (__display0,) => {
                            __formatter
                                .write_fmt(
                                    format_args!("failed to create summary: {0}", __display0),
                                )
                        }
                    }
                }
            }
        }
    }
    #[allow(
        deprecated,
        unused_qualifications,
        clippy::elidable_lifetime_names,
        clippy::needless_lifetimes,
    )]
    #[automatically_derived]
    impl ::core::convert::From<DictionaryFileError> for ImportError {
        fn from(source: DictionaryFileError) -> Self {
            ImportError::DictionaryFile {
                0: source,
            }
        }
    }
    #[allow(
        deprecated,
        unused_qualifications,
        clippy::elidable_lifetime_names,
        clippy::needless_lifetimes,
    )]
    #[automatically_derived]
    impl ::core::convert::From<ImportZipError> for ImportError {
        fn from(source: ImportZipError) -> Self {
            ImportError::Zip { 0: source }
        }
    }
    #[allow(
        deprecated,
        unused_qualifications,
        clippy::elidable_lifetime_names,
        clippy::needless_lifetimes,
    )]
    #[automatically_derived]
    impl ::core::convert::From<Box<db_type::Error>> for ImportError {
        fn from(source: Box<db_type::Error>) -> Self {
            ImportError::Database { 0: source }
        }
    }
    #[allow(
        deprecated,
        unused_qualifications,
        clippy::elidable_lifetime_names,
        clippy::needless_lifetimes,
    )]
    #[automatically_derived]
    impl ::core::convert::From<std::io::Error> for ImportError {
        fn from(source: std::io::Error) -> Self {
            ImportError::IO { 0: source }
        }
    }
    #[allow(
        deprecated,
        unused_qualifications,
        clippy::elidable_lifetime_names,
        clippy::needless_lifetimes,
    )]
    #[automatically_derived]
    impl ::core::convert::From<serde_json::error::Error> for ImportError {
        fn from(source: serde_json::error::Error) -> Self {
            ImportError::Json { 0: source }
        }
    }
    #[allow(
        deprecated,
        unused_qualifications,
        clippy::elidable_lifetime_names,
        clippy::needless_lifetimes,
    )]
    #[automatically_derived]
    impl ::core::convert::From<std::thread::AccessError> for ImportError {
        fn from(source: std::thread::AccessError) -> Self {
            ImportError::ThreadErr {
                0: source,
            }
        }
    }
    #[allow(
        deprecated,
        unused_qualifications,
        clippy::elidable_lifetime_names,
        clippy::needless_lifetimes,
    )]
    #[automatically_derived]
    impl ::core::convert::From<DictionarySummaryError> for ImportError {
        fn from(source: DictionarySummaryError) -> Self {
            ImportError::Summary { 0: source }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ImportError {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                ImportError::DictionaryFile(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "DictionaryFile",
                        &__self_0,
                    )
                }
                ImportError::Zip(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Zip",
                        &__self_0,
                    )
                }
                ImportError::Database(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Database",
                        &__self_0,
                    )
                }
                ImportError::IO(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f, "IO", &__self_0)
                }
                ImportError::Json(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Json",
                        &__self_0,
                    )
                }
                ImportError::ThreadErr(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "ThreadErr",
                        &__self_0,
                    )
                }
                ImportError::LineErr(__self_0, __self_1) => {
                    ::core::fmt::Formatter::debug_tuple_field2_finish(
                        f,
                        "LineErr",
                        __self_0,
                        &__self_1,
                    )
                }
                ImportError::Custom(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Custom",
                        &__self_0,
                    )
                }
                ImportError::InvalidJson { file: __self_0, e: __self_1 } => {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "InvalidJson",
                        "file",
                        __self_0,
                        "e",
                        &__self_1,
                    )
                }
                ImportError::Summary(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Summary",
                        &__self_0,
                    )
                }
            }
        }
    }
    impl From<native_db::db_type::Error> for ImportError {
        fn from(err: native_db::db_type::Error) -> Self {
            ImportError::Database(Box::new(err))
        }
    }
    pub enum DBError {
        #[error("db err: {0}")]
        Database(#[from] Box<db_type::Error>),
        #[error("query err: {0}")]
        Query(String),
        #[error("none found err: {0}")]
        NoneFound(String),
        #[error("import err: {0}")]
        Import(#[from] ImportError),
    }
    #[allow(unused_qualifications)]
    #[automatically_derived]
    impl ::thiserror::__private::Error for DBError {
        fn source(
            &self,
        ) -> ::core::option::Option<&(dyn ::thiserror::__private::Error + 'static)> {
            use ::thiserror::__private::AsDynError as _;
            #[allow(deprecated)]
            match self {
                DBError::Database { 0: source, .. } => {
                    ::core::option::Option::Some(source.as_dyn_error())
                }
                DBError::Query { .. } => ::core::option::Option::None,
                DBError::NoneFound { .. } => ::core::option::Option::None,
                DBError::Import { 0: source, .. } => {
                    ::core::option::Option::Some(source.as_dyn_error())
                }
            }
        }
    }
    #[allow(unused_qualifications)]
    #[automatically_derived]
    impl ::core::fmt::Display for DBError {
        fn fmt(&self, __formatter: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            use ::thiserror::__private::AsDisplay as _;
            #[allow(unused_variables, deprecated, clippy::used_underscore_binding)]
            match self {
                DBError::Database(_0) => {
                    match (_0.as_display(),) {
                        (__display0,) => {
                            __formatter
                                .write_fmt(format_args!("db err: {0}", __display0))
                        }
                    }
                }
                DBError::Query(_0) => {
                    match (_0.as_display(),) {
                        (__display0,) => {
                            __formatter
                                .write_fmt(format_args!("query err: {0}", __display0))
                        }
                    }
                }
                DBError::NoneFound(_0) => {
                    match (_0.as_display(),) {
                        (__display0,) => {
                            __formatter
                                .write_fmt(format_args!("none found err: {0}", __display0))
                        }
                    }
                }
                DBError::Import(_0) => {
                    match (_0.as_display(),) {
                        (__display0,) => {
                            __formatter
                                .write_fmt(format_args!("import err: {0}", __display0))
                        }
                    }
                }
            }
        }
    }
    #[allow(
        deprecated,
        unused_qualifications,
        clippy::elidable_lifetime_names,
        clippy::needless_lifetimes,
    )]
    #[automatically_derived]
    impl ::core::convert::From<Box<db_type::Error>> for DBError {
        fn from(source: Box<db_type::Error>) -> Self {
            DBError::Database { 0: source }
        }
    }
    #[allow(
        deprecated,
        unused_qualifications,
        clippy::elidable_lifetime_names,
        clippy::needless_lifetimes,
    )]
    #[automatically_derived]
    impl ::core::convert::From<ImportError> for DBError {
        fn from(source: ImportError) -> Self {
            DBError::Import { 0: source }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for DBError {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                DBError::Database(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Database",
                        &__self_0,
                    )
                }
                DBError::Query(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Query",
                        &__self_0,
                    )
                }
                DBError::NoneFound(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "NoneFound",
                        &__self_0,
                    )
                }
                DBError::Import(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Import",
                        &__self_0,
                    )
                }
            }
        }
    }
    impl From<native_db::db_type::Error> for DBError {
        fn from(err: native_db::db_type::Error) -> Self {
            DBError::Database(Box::new(err))
        }
    }
    impl From<(u32, std::io::Error)> for ImportError {
        fn from(err: (u32, std::io::Error)) -> ImportError {
            ImportError::LineErr(err.0, Box::new(ImportError::from(err.1)))
        }
    }
    impl From<(u32, serde_json::error::Error)> for ImportError {
        fn from(err: (u32, serde_json::error::Error)) -> ImportError {
            ImportError::LineErr(err.0, Box::new(ImportError::from(err.1)))
        }
    }
}
mod freq {}
mod regex_util {
    use fancy_regex::{Captures, Regex};
    use std::sync::LazyLock;
    static MATCH_REPLACEMENT_PATTERN: LazyLock<Regex> = LazyLock::new(|| {
        Regex::new(r"\$(?:\$|&|`|'|(\d\d?)|<([^>]*)>)").unwrap()
    });
    pub fn apply_text_replacement(
        text: &str,
        pattern: &Regex,
        replacement_pattern_str: &str,
        is_global: &bool,
    ) -> String {
        let mut current_text = text.to_string();
        let mut current_pos = 0;
        let mut first_match_done = false;
        loop {
            if !is_global && first_match_done {
                break;
            }
            let captures_opt = pattern.captures(&current_text[current_pos..]).unwrap();
            let captures = match captures_opt {
                Some(caps) => caps,
                None => break,
            };
            let match_text = captures.get(0).unwrap();
            let match_start_index = current_pos + match_text.start();
            let match_end_index = current_pos + match_text.end();
            let actual_replacement = apply_match_replacement(
                replacement_pattern_str,
                &captures,
                &current_text,
            );
            let mut new_text = String::with_capacity(
                current_text.len() - match_text.as_str().len() + actual_replacement.len(),
            );
            new_text.push_str(&current_text[..match_start_index]);
            new_text.push_str(&actual_replacement);
            new_text.push_str(&current_text[match_end_index..]);
            current_text = new_text;
            first_match_done = true;
            current_pos = match_start_index + actual_replacement.len();
            if current_pos >= current_text.len() {
                break;
            }
        }
        current_text
    }
    pub fn apply_match_replacement(
        replacement_pattern_input: &str,
        outer_captures: &Captures,
        original_text_at_match_time: &str,
    ) -> String {
        MATCH_REPLACEMENT_PATTERN
            .replace_all(
                replacement_pattern_input,
                |inner_caps: &Captures| {
                    let g0_match_str = inner_caps.get(0).unwrap().as_str();
                    if let Some(g1_digit_match) = inner_caps.get(1) {
                        let group_index_str = g1_digit_match.as_str();
                        if let Ok(idx) = group_index_str.parse::<usize>() {
                            if idx > 0 && idx < outer_captures.len() {
                                return outer_captures
                                    .get(idx)
                                    .map_or("".to_string(), |m| m.as_str().to_string());
                            }
                        }
                        g0_match_str.to_string()
                    } else if let Some(g2_name_match) = inner_caps.get(2) {
                        let group_name = g2_name_match.as_str();
                        if let Some(named_capture) = outer_captures.name(group_name) {
                            return named_capture.as_str().to_string();
                        }
                        g0_match_str.to_string()
                    } else {
                        let match_start = outer_captures.get(0).unwrap().start();
                        match g0_match_str {
                            "$$" => "$".to_string(),
                            "$&" => outer_captures.get(0).unwrap().as_str().to_string(),
                            "$`" => {
                                original_text_at_match_time[..match_start].to_string()
                            }
                            "$'" => {
                                let match_end = outer_captures.get(0).unwrap().end();
                                original_text_at_match_time[match_end..].to_string()
                            }
                            _ => g0_match_str.to_string(),
                        }
                    }
                },
            )
            .into_owned()
    }
}
pub mod settings {
    use indexmap::IndexMap;
    use indexmap::IndexSet;
    use native_db::native_db;
    use native_db::ToKey;
    use native_model::native_model;
    use native_model::Model;
    use serde::{Deserialize, Serialize};
    use crate::{
        database::dictionary_importer::DictionarySummary,
        translation::FindTermsSortOrder, translator::FindTermsMode,
    };
    pub struct GlobalOptions {
        pub database: GlobalDatabaseOptions,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for GlobalOptions {
        #[inline]
        fn clone(&self) -> GlobalOptions {
            GlobalOptions {
                database: ::core::clone::Clone::clone(&self.database),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for GlobalOptions {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "GlobalOptions",
                "database",
                &&self.database,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for GlobalOptions {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for GlobalOptions {
        #[inline]
        fn eq(&self, other: &GlobalOptions) -> bool {
            self.database == other.database
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for GlobalOptions {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "GlobalOptions",
                    false as usize + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "database",
                    &self.database,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for GlobalOptions {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "database" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"database" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<GlobalOptions>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = GlobalOptions;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct GlobalOptions",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            GlobalDatabaseOptions,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct GlobalOptions with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(GlobalOptions {
                            database: __field0,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            GlobalDatabaseOptions,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "database",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            GlobalDatabaseOptions,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("database")?
                            }
                        };
                        _serde::__private::Ok(GlobalOptions {
                            database: __field0,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["database"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "GlobalOptions",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<GlobalOptions>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for GlobalOptions {
        #[inline]
        fn default() -> GlobalOptions {
            GlobalOptions {
                database: ::core::default::Default::default(),
            }
        }
    }
    pub struct GlobalDatabaseOptions {
        pub prefix_wildcards_supported: bool,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for GlobalDatabaseOptions {
        #[inline]
        fn clone(&self) -> GlobalDatabaseOptions {
            GlobalDatabaseOptions {
                prefix_wildcards_supported: ::core::clone::Clone::clone(
                    &self.prefix_wildcards_supported,
                ),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for GlobalDatabaseOptions {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "GlobalDatabaseOptions",
                "prefix_wildcards_supported",
                &&self.prefix_wildcards_supported,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for GlobalDatabaseOptions {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for GlobalDatabaseOptions {
        #[inline]
        fn eq(&self, other: &GlobalDatabaseOptions) -> bool {
            self.prefix_wildcards_supported == other.prefix_wildcards_supported
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for GlobalDatabaseOptions {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "GlobalDatabaseOptions",
                    false as usize + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "prefix_wildcards_supported",
                    &self.prefix_wildcards_supported,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for GlobalDatabaseOptions {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "prefix_wildcards_supported" => {
                                _serde::__private::Ok(__Field::__field0)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"prefix_wildcards_supported" => {
                                _serde::__private::Ok(__Field::__field0)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<GlobalDatabaseOptions>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = GlobalDatabaseOptions;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct GlobalDatabaseOptions",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct GlobalDatabaseOptions with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(GlobalDatabaseOptions {
                            prefix_wildcards_supported: __field0,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<bool> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "prefix_wildcards_supported",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "prefix_wildcards_supported",
                                )?
                            }
                        };
                        _serde::__private::Ok(GlobalDatabaseOptions {
                            prefix_wildcards_supported: __field0,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["prefix_wildcards_supported"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "GlobalDatabaseOptions",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<GlobalDatabaseOptions>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for GlobalDatabaseOptions {
        #[inline]
        fn default() -> GlobalDatabaseOptions {
            GlobalDatabaseOptions {
                prefix_wildcards_supported: ::core::default::Default::default(),
            }
        }
    }
    /// Global Yomichan Settings.
    pub struct Options {
        #[primary_key]
        id: String,
        pub version: String,
        pub profiles: Vec<Profile>,
        pub current_profile: usize,
        pub global: GlobalOptions,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Options {
        #[inline]
        fn clone(&self) -> Options {
            Options {
                id: ::core::clone::Clone::clone(&self.id),
                version: ::core::clone::Clone::clone(&self.version),
                profiles: ::core::clone::Clone::clone(&self.profiles),
                current_profile: ::core::clone::Clone::clone(&self.current_profile),
                global: ::core::clone::Clone::clone(&self.global),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Options {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "Options",
                "id",
                &self.id,
                "version",
                &self.version,
                "profiles",
                &self.profiles,
                "current_profile",
                &self.current_profile,
                "global",
                &&self.global,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Options {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Options {
        #[inline]
        fn eq(&self, other: &Options) -> bool {
            self.id == other.id && self.version == other.version
                && self.profiles == other.profiles
                && self.current_profile == other.current_profile
                && self.global == other.global
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Options {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "Options",
                    false as usize + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "id",
                    &self.id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "version",
                    &self.version,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "profiles",
                    &self.profiles,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "current_profile",
                    &self.current_profile,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "global",
                    &self.global,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Options {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "id" => _serde::__private::Ok(__Field::__field0),
                            "version" => _serde::__private::Ok(__Field::__field1),
                            "profiles" => _serde::__private::Ok(__Field::__field2),
                            "current_profile" => _serde::__private::Ok(__Field::__field3),
                            "global" => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"id" => _serde::__private::Ok(__Field::__field0),
                            b"version" => _serde::__private::Ok(__Field::__field1),
                            b"profiles" => _serde::__private::Ok(__Field::__field2),
                            b"current_profile" => {
                                _serde::__private::Ok(__Field::__field3)
                            }
                            b"global" => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Options>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Options;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Options",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Options with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Options with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            Vec<Profile>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct Options with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            usize,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct Options with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            GlobalOptions,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct Options with 5 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Options {
                            id: __field0,
                            version: __field1,
                            profiles: __field2,
                            current_profile: __field3,
                            global: __field4,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<Vec<Profile>> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<usize> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<GlobalOptions> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "version",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "profiles",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<Profile>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "current_profile",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<usize>(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("global"),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            GlobalOptions,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("id")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("version")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("profiles")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("current_profile")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("global")?
                            }
                        };
                        _serde::__private::Ok(Options {
                            id: __field0,
                            version: __field1,
                            profiles: __field2,
                            current_profile: __field3,
                            global: __field4,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "id",
                    "version",
                    "profiles",
                    "current_profile",
                    "global",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Options",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Options>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for Options {
        #[inline]
        fn default() -> Options {
            Options {
                id: ::core::default::Default::default(),
                version: ::core::default::Default::default(),
                profiles: ::core::default::Default::default(),
                current_profile: ::core::default::Default::default(),
                global: ::core::default::Default::default(),
            }
        }
    }
    impl native_db::db_type::ToInput for Options {
        fn native_db_bincode_encode_to_vec(
            &self,
        ) -> native_db::db_type::Result<Vec<u8>> {
            native_db::bincode_encode_to_vec(self)
        }
        fn native_db_bincode_decode_from_slice(
            slice: &[u8],
        ) -> native_db::db_type::Result<Self> {
            Ok(native_db::bincode_decode_from_slice(slice)?.0)
        }
        fn native_db_model() -> native_db::Model {
            let mut secondary_tables_name = std::collections::HashSet::new();
            native_db::Model {
                primary_key: native_db::db_type::KeyDefinition::new(
                    Options::native_model_id(),
                    Options::native_model_version(),
                    "id",
                    <String>::key_names(),
                    (),
                ),
                secondary_keys: secondary_tables_name,
            }
        }
        fn native_db_primary_key(&self) -> native_db::db_type::Key {
            (&self.id).to_key()
        }
        fn native_db_secondary_keys(
            &self,
        ) -> std::collections::HashMap<
            native_db::db_type::KeyDefinition<native_db::db_type::KeyOptions>,
            native_db::db_type::KeyEntry,
        > {
            let mut secondary_tables_name = std::collections::HashMap::new();
            secondary_tables_name
        }
    }
    #[allow(non_camel_case_types)]
    pub(crate) enum OptionsKey {}
    impl native_db::db_type::ToKeyDefinition<native_db::db_type::KeyOptions>
    for OptionsKey {
        fn key_definition(
            &self,
        ) -> native_db::db_type::KeyDefinition<native_db::db_type::KeyOptions> {
            match self {
                _ => {
                    ::std::rt::begin_panic("Unknown key");
                }
            }
        }
    }
    impl native_model::Model for Options {
        fn native_model_id() -> u32 {
            20
        }
        fn native_model_id_str() -> &'static str {
            "20"
        }
        fn native_model_version() -> u32 {
            1
        }
        fn native_model_version_str() -> &'static str {
            "1"
        }
        fn native_model_encode_body(
            &self,
        ) -> std::result::Result<Vec<u8>, native_model::EncodeBodyError> {
            use native_model::Encode;
            native_model::bincode_1_3::Bincode::encode(self)
                .map_err(|e| native_model::EncodeBodyError {
                    msg: ::alloc::__export::must_use({
                        let res = ::alloc::fmt::format(format_args!("{0}", e));
                        res
                    }),
                    source: e.into(),
                })
        }
        fn native_model_encode_downgrade_body(
            self,
            version: u32,
        ) -> native_model::Result<Vec<u8>> {
            if version == Self::native_model_version() {
                let result = self.native_model_encode_body()?;
                Ok(result)
            } else if version < Self::native_model_version() {
                Err(native_model::Error::DowngradeNotSupported {
                    from: version,
                    to: Self::native_model_version(),
                })
            } else {
                Err(native_model::Error::DowngradeNotSupported {
                    from: version,
                    to: Self::native_model_version(),
                })
            }
        }
        fn native_model_decode_body(
            data: Vec<u8>,
            id: u32,
        ) -> std::result::Result<Self, native_model::DecodeBodyError> {
            if id != 20 {
                return Err(native_model::DecodeBodyError::MismatchedModelId);
            }
            use native_model::Decode;
            native_model::bincode_1_3::Bincode::decode(data)
                .map_err(|e| native_model::DecodeBodyError::DecodeError {
                    msg: ::alloc::__export::must_use({
                        let res = ::alloc::fmt::format(format_args!("{0}", e));
                        res
                    }),
                    source: e.into(),
                })
        }
        fn native_model_decode_upgrade_body(
            data: Vec<u8>,
            id: u32,
            version: u32,
        ) -> native_model::Result<Self> {
            if version == Self::native_model_version() {
                let result = Self::native_model_decode_body(data, id)?;
                Ok(result)
            } else if version < Self::native_model_version() {
                Err(native_model::Error::UpgradeNotSupported {
                    from: version,
                    to: Self::native_model_version(),
                })
            } else {
                Err(native_model::Error::UpgradeNotSupported {
                    from: version,
                    to: Self::native_model_version(),
                })
            }
        }
    }
    impl Options {
        pub fn new() -> Self {
            Self {
                id: "global_user_options".to_string(),
                version: "0.1.0".to_string(),
                profiles: <[_]>::into_vec(::alloc::boxed::box_new([Profile::default()])),
                current_profile: 0,
                global: GlobalOptions::default(),
            }
        }
        pub fn get_options_mut(&mut self) -> &mut Self {
            self
        }
        pub fn get_current_profile_mut(&mut self) -> &mut Profile {
            let index = self.current_profile;
            &mut self.profiles[index]
        }
        pub fn get_current_profile(&self) -> &Profile {
            let index = self.current_profile;
            &self.profiles[index]
        }
    }
    pub struct Profile {
        pub name: String,
        pub condition_groups: Vec<ProfileConditionGroup>,
        pub options: ProfileOptions,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Profile {
        #[inline]
        fn clone(&self) -> Profile {
            Profile {
                name: ::core::clone::Clone::clone(&self.name),
                condition_groups: ::core::clone::Clone::clone(&self.condition_groups),
                options: ::core::clone::Clone::clone(&self.options),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Profile {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Profile",
                "name",
                &self.name,
                "condition_groups",
                &self.condition_groups,
                "options",
                &&self.options,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Profile {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Profile {
        #[inline]
        fn eq(&self, other: &Profile) -> bool {
            self.name == other.name && self.condition_groups == other.condition_groups
                && self.options == other.options
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Profile {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "Profile",
                    false as usize + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "name",
                    &self.name,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "condition_groups",
                    &self.condition_groups,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "options",
                    &self.options,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Profile {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "name" => _serde::__private::Ok(__Field::__field0),
                            "condition_groups" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            "options" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"name" => _serde::__private::Ok(__Field::__field0),
                            b"condition_groups" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            b"options" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Profile>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Profile;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Profile",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Profile with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            Vec<ProfileConditionGroup>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Profile with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            ProfileOptions,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct Profile with 3 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Profile {
                            name: __field0,
                            condition_groups: __field1,
                            options: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            Vec<ProfileConditionGroup>,
                        > = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<ProfileOptions> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "condition_groups",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<ProfileConditionGroup>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "options",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ProfileOptions,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("name")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("condition_groups")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("options")?
                            }
                        };
                        _serde::__private::Ok(Profile {
                            name: __field0,
                            condition_groups: __field1,
                            options: __field2,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "name",
                    "condition_groups",
                    "options",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Profile",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Profile>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for Profile {
        #[inline]
        fn default() -> Profile {
            Profile {
                name: ::core::default::Default::default(),
                condition_groups: ::core::default::Default::default(),
                options: ::core::default::Default::default(),
            }
        }
    }
    impl Profile {
        pub fn new(
            name: String,
            condition_groups: Vec<ProfileConditionGroup>,
            options: ProfileOptions,
        ) -> Self {
            Self {
                name,
                condition_groups,
                options,
            }
        }
    }
    pub struct ProfileConditionGroup {
        pub conditions: Vec<ProfileCondition>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ProfileConditionGroup {
        #[inline]
        fn clone(&self) -> ProfileConditionGroup {
            ProfileConditionGroup {
                conditions: ::core::clone::Clone::clone(&self.conditions),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ProfileConditionGroup {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "ProfileConditionGroup",
                "conditions",
                &&self.conditions,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ProfileConditionGroup {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ProfileConditionGroup {
        #[inline]
        fn eq(&self, other: &ProfileConditionGroup) -> bool {
            self.conditions == other.conditions
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ProfileConditionGroup {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "ProfileConditionGroup",
                    false as usize + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "conditions",
                    &self.conditions,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ProfileConditionGroup {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "conditions" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"conditions" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ProfileConditionGroup>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ProfileConditionGroup;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct ProfileConditionGroup",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            Vec<ProfileCondition>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct ProfileConditionGroup with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(ProfileConditionGroup {
                            conditions: __field0,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            Vec<ProfileCondition>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "conditions",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<ProfileCondition>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("conditions")?
                            }
                        };
                        _serde::__private::Ok(ProfileConditionGroup {
                            conditions: __field0,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["conditions"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ProfileConditionGroup",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ProfileConditionGroup>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for ProfileConditionGroup {
        #[inline]
        fn default() -> ProfileConditionGroup {
            ProfileConditionGroup {
                conditions: ::core::default::Default::default(),
            }
        }
    }
    /// Profile usage conditions are used to automatically select certain profiles based on context.
    /// For example, different profiles can be used,
    /// depending on the nested level of the popup, or based on the website's URL.
    /// Conditions are organized into groups corresponding to the order in which they are checked.
    /// If all of the conditions in any group of a profile are met, then that profile will be used for that context.
    /// If no conditions are specified, the profile will only be used if it is selected as the default profile.
    pub enum ProfileConditionType {
        #[default]
        PopupLevel,
        Url,
        ModifierKeys,
        Flags,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ProfileConditionType {
        #[inline]
        fn clone(&self) -> ProfileConditionType {
            match self {
                ProfileConditionType::PopupLevel => ProfileConditionType::PopupLevel,
                ProfileConditionType::Url => ProfileConditionType::Url,
                ProfileConditionType::ModifierKeys => ProfileConditionType::ModifierKeys,
                ProfileConditionType::Flags => ProfileConditionType::Flags,
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ProfileConditionType {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    ProfileConditionType::PopupLevel => "PopupLevel",
                    ProfileConditionType::Url => "Url",
                    ProfileConditionType::ModifierKeys => "ModifierKeys",
                    ProfileConditionType::Flags => "Flags",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ProfileConditionType {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ProfileConditionType {
        #[inline]
        fn eq(&self, other: &ProfileConditionType) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ProfileConditionType {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    ProfileConditionType::PopupLevel => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ProfileConditionType",
                            0u32,
                            "PopupLevel",
                        )
                    }
                    ProfileConditionType::Url => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ProfileConditionType",
                            1u32,
                            "Url",
                        )
                    }
                    ProfileConditionType::ModifierKeys => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ProfileConditionType",
                            2u32,
                            "ModifierKeys",
                        )
                    }
                    ProfileConditionType::Flags => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ProfileConditionType",
                            3u32,
                            "Flags",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ProfileConditionType {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 4",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "PopupLevel" => _serde::__private::Ok(__Field::__field0),
                            "Url" => _serde::__private::Ok(__Field::__field1),
                            "ModifierKeys" => _serde::__private::Ok(__Field::__field2),
                            "Flags" => _serde::__private::Ok(__Field::__field3),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"PopupLevel" => _serde::__private::Ok(__Field::__field0),
                            b"Url" => _serde::__private::Ok(__Field::__field1),
                            b"ModifierKeys" => _serde::__private::Ok(__Field::__field2),
                            b"Flags" => _serde::__private::Ok(__Field::__field3),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ProfileConditionType>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ProfileConditionType;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum ProfileConditionType",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(ProfileConditionType::PopupLevel)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(ProfileConditionType::Url)
                            }
                            (__Field::__field2, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(ProfileConditionType::ModifierKeys)
                            }
                            (__Field::__field3, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(ProfileConditionType::Flags)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "PopupLevel",
                    "Url",
                    "ModifierKeys",
                    "Flags",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "ProfileConditionType",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ProfileConditionType>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for ProfileConditionType {
        #[inline]
        fn default() -> ProfileConditionType {
            Self::PopupLevel
        }
    }
    pub struct ProfileCondition {
        pub condition_type: ProfileConditionType,
        pub operator: String,
        pub value: String,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ProfileCondition {
        #[inline]
        fn clone(&self) -> ProfileCondition {
            ProfileCondition {
                condition_type: ::core::clone::Clone::clone(&self.condition_type),
                operator: ::core::clone::Clone::clone(&self.operator),
                value: ::core::clone::Clone::clone(&self.value),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ProfileCondition {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "ProfileCondition",
                "condition_type",
                &self.condition_type,
                "operator",
                &self.operator,
                "value",
                &&self.value,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ProfileCondition {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ProfileCondition {
        #[inline]
        fn eq(&self, other: &ProfileCondition) -> bool {
            self.condition_type == other.condition_type
                && self.operator == other.operator && self.value == other.value
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ProfileCondition {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "ProfileCondition",
                    false as usize + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "condition_type",
                    &self.condition_type,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "operator",
                    &self.operator,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "value",
                    &self.value,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ProfileCondition {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "condition_type" => _serde::__private::Ok(__Field::__field0),
                            "operator" => _serde::__private::Ok(__Field::__field1),
                            "value" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"condition_type" => _serde::__private::Ok(__Field::__field0),
                            b"operator" => _serde::__private::Ok(__Field::__field1),
                            b"value" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ProfileCondition>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ProfileCondition;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct ProfileCondition",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ProfileConditionType,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct ProfileCondition with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct ProfileCondition with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct ProfileCondition with 3 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(ProfileCondition {
                            condition_type: __field0,
                            operator: __field1,
                            value: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            ProfileConditionType,
                        > = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<String> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "condition_type",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ProfileConditionType,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "operator",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("value"),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("condition_type")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("operator")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("value")?
                            }
                        };
                        _serde::__private::Ok(ProfileCondition {
                            condition_type: __field0,
                            operator: __field1,
                            value: __field2,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "condition_type",
                    "operator",
                    "value",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ProfileCondition",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ProfileCondition>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for ProfileCondition {
        #[inline]
        fn default() -> ProfileCondition {
            ProfileCondition {
                condition_type: ::core::default::Default::default(),
                operator: ::core::default::Default::default(),
                value: ::core::default::Default::default(),
            }
        }
    }
    pub struct ProfileOptions {
        pub general: GeneralOptions,
        pub popup_window: PopupWindowOptions,
        pub audio: AudioOptions,
        pub scanning: ScanningOptions,
        pub translation: TranslationOptions,
        pub dictionaries: IndexMap<String, DictionaryOptions>,
        pub parsing: ParsingOptions,
        pub anki: AnkiOptions,
        pub sentence_parsing: SentenceParsingOptions,
        pub inputs: InputsOptions,
        pub clipboard: ClipboardOptions,
        pub accessibility: AccessibilityOptions,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ProfileOptions {
        #[inline]
        fn clone(&self) -> ProfileOptions {
            ProfileOptions {
                general: ::core::clone::Clone::clone(&self.general),
                popup_window: ::core::clone::Clone::clone(&self.popup_window),
                audio: ::core::clone::Clone::clone(&self.audio),
                scanning: ::core::clone::Clone::clone(&self.scanning),
                translation: ::core::clone::Clone::clone(&self.translation),
                dictionaries: ::core::clone::Clone::clone(&self.dictionaries),
                parsing: ::core::clone::Clone::clone(&self.parsing),
                anki: ::core::clone::Clone::clone(&self.anki),
                sentence_parsing: ::core::clone::Clone::clone(&self.sentence_parsing),
                inputs: ::core::clone::Clone::clone(&self.inputs),
                clipboard: ::core::clone::Clone::clone(&self.clipboard),
                accessibility: ::core::clone::Clone::clone(&self.accessibility),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ProfileOptions {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "general",
                "popup_window",
                "audio",
                "scanning",
                "translation",
                "dictionaries",
                "parsing",
                "anki",
                "sentence_parsing",
                "inputs",
                "clipboard",
                "accessibility",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.general,
                &self.popup_window,
                &self.audio,
                &self.scanning,
                &self.translation,
                &self.dictionaries,
                &self.parsing,
                &self.anki,
                &self.sentence_parsing,
                &self.inputs,
                &self.clipboard,
                &&self.accessibility,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "ProfileOptions",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ProfileOptions {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ProfileOptions {
        #[inline]
        fn eq(&self, other: &ProfileOptions) -> bool {
            self.general == other.general && self.popup_window == other.popup_window
                && self.audio == other.audio && self.scanning == other.scanning
                && self.translation == other.translation
                && self.dictionaries == other.dictionaries
                && self.parsing == other.parsing && self.anki == other.anki
                && self.sentence_parsing == other.sentence_parsing
                && self.inputs == other.inputs && self.clipboard == other.clipboard
                && self.accessibility == other.accessibility
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ProfileOptions {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "ProfileOptions",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "general",
                    &self.general,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "popup_window",
                    &self.popup_window,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "audio",
                    &self.audio,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "scanning",
                    &self.scanning,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "translation",
                    &self.translation,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "dictionaries",
                    &self.dictionaries,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "parsing",
                    &self.parsing,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "anki",
                    &self.anki,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "sentence_parsing",
                    &self.sentence_parsing,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "inputs",
                    &self.inputs,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "clipboard",
                    &self.clipboard,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "accessibility",
                    &self.accessibility,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ProfileOptions {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __field8,
                    __field9,
                    __field10,
                    __field11,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            8u64 => _serde::__private::Ok(__Field::__field8),
                            9u64 => _serde::__private::Ok(__Field::__field9),
                            10u64 => _serde::__private::Ok(__Field::__field10),
                            11u64 => _serde::__private::Ok(__Field::__field11),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "general" => _serde::__private::Ok(__Field::__field0),
                            "popup_window" => _serde::__private::Ok(__Field::__field1),
                            "audio" => _serde::__private::Ok(__Field::__field2),
                            "scanning" => _serde::__private::Ok(__Field::__field3),
                            "translation" => _serde::__private::Ok(__Field::__field4),
                            "dictionaries" => _serde::__private::Ok(__Field::__field5),
                            "parsing" => _serde::__private::Ok(__Field::__field6),
                            "anki" => _serde::__private::Ok(__Field::__field7),
                            "sentence_parsing" => {
                                _serde::__private::Ok(__Field::__field8)
                            }
                            "inputs" => _serde::__private::Ok(__Field::__field9),
                            "clipboard" => _serde::__private::Ok(__Field::__field10),
                            "accessibility" => _serde::__private::Ok(__Field::__field11),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"general" => _serde::__private::Ok(__Field::__field0),
                            b"popup_window" => _serde::__private::Ok(__Field::__field1),
                            b"audio" => _serde::__private::Ok(__Field::__field2),
                            b"scanning" => _serde::__private::Ok(__Field::__field3),
                            b"translation" => _serde::__private::Ok(__Field::__field4),
                            b"dictionaries" => _serde::__private::Ok(__Field::__field5),
                            b"parsing" => _serde::__private::Ok(__Field::__field6),
                            b"anki" => _serde::__private::Ok(__Field::__field7),
                            b"sentence_parsing" => {
                                _serde::__private::Ok(__Field::__field8)
                            }
                            b"inputs" => _serde::__private::Ok(__Field::__field9),
                            b"clipboard" => _serde::__private::Ok(__Field::__field10),
                            b"accessibility" => _serde::__private::Ok(__Field::__field11),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ProfileOptions>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ProfileOptions;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct ProfileOptions",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            GeneralOptions,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct ProfileOptions with 12 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            PopupWindowOptions,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct ProfileOptions with 12 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            AudioOptions,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct ProfileOptions with 12 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            ScanningOptions,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct ProfileOptions with 12 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            TranslationOptions,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct ProfileOptions with 12 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            IndexMap<String, DictionaryOptions>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct ProfileOptions with 12 elements",
                                    ),
                                );
                            }
                        };
                        let __field6 = match _serde::de::SeqAccess::next_element::<
                            ParsingOptions,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        6usize,
                                        &"struct ProfileOptions with 12 elements",
                                    ),
                                );
                            }
                        };
                        let __field7 = match _serde::de::SeqAccess::next_element::<
                            AnkiOptions,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        7usize,
                                        &"struct ProfileOptions with 12 elements",
                                    ),
                                );
                            }
                        };
                        let __field8 = match _serde::de::SeqAccess::next_element::<
                            SentenceParsingOptions,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        8usize,
                                        &"struct ProfileOptions with 12 elements",
                                    ),
                                );
                            }
                        };
                        let __field9 = match _serde::de::SeqAccess::next_element::<
                            InputsOptions,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        9usize,
                                        &"struct ProfileOptions with 12 elements",
                                    ),
                                );
                            }
                        };
                        let __field10 = match _serde::de::SeqAccess::next_element::<
                            ClipboardOptions,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        10usize,
                                        &"struct ProfileOptions with 12 elements",
                                    ),
                                );
                            }
                        };
                        let __field11 = match _serde::de::SeqAccess::next_element::<
                            AccessibilityOptions,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        11usize,
                                        &"struct ProfileOptions with 12 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(ProfileOptions {
                            general: __field0,
                            popup_window: __field1,
                            audio: __field2,
                            scanning: __field3,
                            translation: __field4,
                            dictionaries: __field5,
                            parsing: __field6,
                            anki: __field7,
                            sentence_parsing: __field8,
                            inputs: __field9,
                            clipboard: __field10,
                            accessibility: __field11,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<GeneralOptions> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            PopupWindowOptions,
                        > = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<AudioOptions> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<ScanningOptions> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<
                            TranslationOptions,
                        > = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<
                            IndexMap<String, DictionaryOptions>,
                        > = _serde::__private::None;
                        let mut __field6: _serde::__private::Option<ParsingOptions> = _serde::__private::None;
                        let mut __field7: _serde::__private::Option<AnkiOptions> = _serde::__private::None;
                        let mut __field8: _serde::__private::Option<
                            SentenceParsingOptions,
                        > = _serde::__private::None;
                        let mut __field9: _serde::__private::Option<InputsOptions> = _serde::__private::None;
                        let mut __field10: _serde::__private::Option<ClipboardOptions> = _serde::__private::None;
                        let mut __field11: _serde::__private::Option<
                            AccessibilityOptions,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "general",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            GeneralOptions,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "popup_window",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            PopupWindowOptions,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("audio"),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            AudioOptions,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "scanning",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ScanningOptions,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "translation",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            TranslationOptions,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "dictionaries",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            IndexMap<String, DictionaryOptions>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "parsing",
                                            ),
                                        );
                                    }
                                    __field6 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ParsingOptions,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field7 => {
                                    if _serde::__private::Option::is_some(&__field7) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("anki"),
                                        );
                                    }
                                    __field7 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            AnkiOptions,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field8 => {
                                    if _serde::__private::Option::is_some(&__field8) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "sentence_parsing",
                                            ),
                                        );
                                    }
                                    __field8 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            SentenceParsingOptions,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field9 => {
                                    if _serde::__private::Option::is_some(&__field9) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("inputs"),
                                        );
                                    }
                                    __field9 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            InputsOptions,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field10 => {
                                    if _serde::__private::Option::is_some(&__field10) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "clipboard",
                                            ),
                                        );
                                    }
                                    __field10 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ClipboardOptions,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field11 => {
                                    if _serde::__private::Option::is_some(&__field11) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "accessibility",
                                            ),
                                        );
                                    }
                                    __field11 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            AccessibilityOptions,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("general")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("popup_window")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("audio")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("scanning")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("translation")?
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("dictionaries")?
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("parsing")?
                            }
                        };
                        let __field7 = match __field7 {
                            _serde::__private::Some(__field7) => __field7,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("anki")?
                            }
                        };
                        let __field8 = match __field8 {
                            _serde::__private::Some(__field8) => __field8,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("sentence_parsing")?
                            }
                        };
                        let __field9 = match __field9 {
                            _serde::__private::Some(__field9) => __field9,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("inputs")?
                            }
                        };
                        let __field10 = match __field10 {
                            _serde::__private::Some(__field10) => __field10,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("clipboard")?
                            }
                        };
                        let __field11 = match __field11 {
                            _serde::__private::Some(__field11) => __field11,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("accessibility")?
                            }
                        };
                        _serde::__private::Ok(ProfileOptions {
                            general: __field0,
                            popup_window: __field1,
                            audio: __field2,
                            scanning: __field3,
                            translation: __field4,
                            dictionaries: __field5,
                            parsing: __field6,
                            anki: __field7,
                            sentence_parsing: __field8,
                            inputs: __field9,
                            clipboard: __field10,
                            accessibility: __field11,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "general",
                    "popup_window",
                    "audio",
                    "scanning",
                    "translation",
                    "dictionaries",
                    "parsing",
                    "anki",
                    "sentence_parsing",
                    "inputs",
                    "clipboard",
                    "accessibility",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ProfileOptions",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ProfileOptions>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for ProfileOptions {
        #[inline]
        fn default() -> ProfileOptions {
            ProfileOptions {
                general: ::core::default::Default::default(),
                popup_window: ::core::default::Default::default(),
                audio: ::core::default::Default::default(),
                scanning: ::core::default::Default::default(),
                translation: ::core::default::Default::default(),
                dictionaries: ::core::default::Default::default(),
                parsing: ::core::default::Default::default(),
                anki: ::core::default::Default::default(),
                sentence_parsing: ::core::default::Default::default(),
                inputs: ::core::default::Default::default(),
                clipboard: ::core::default::Default::default(),
                accessibility: ::core::default::Default::default(),
            }
        }
    }
    pub struct GeneralOptions {
        pub enable: bool,
        pub language: String,
        pub result_output_mode: FindTermsMode,
        pub debug_info: bool,
        pub max_results: u8,
        pub show_advanced: bool,
        pub font_family: String,
        pub font_size: u8,
        pub line_height: String,
        pub popup_display_mode: PopupDisplayMode,
        pub popup_width: u8,
        pub popup_height: u8,
        pub popup_horizontal_offset: u8,
        pub popup_vertical_offset: u8,
        pub popup_horizontal_offset2: u8,
        pub popup_vertical_offset2: u8,
        pub popup_horizontal_text_position: PopupHorizontalTextPosition,
        pub popup_vertical_text_position: PopupVerticalTextPosition,
        pub popup_scaling_factor: u8,
        pub popup_scale_relative_to_page_zoom: bool,
        pub popup_scale_relative_to_visual_viewport: bool,
        pub show_guide: bool,
        pub enable_context_menu_scan_selected: bool,
        pub compact_tags: bool,
        pub compact_glossaries: bool,
        pub main_dictionary: String,
        pub popup_theme: PopupTheme,
        pub popup_outer_theme: PopupShadow,
        pub custom_popup_css: String,
        pub custom_popup_outer_css: String,
        pub enable_wanakana: bool,
        pub show_pitch_accent_downstep_notation: bool,
        pub show_pitch_accent_position_notation: bool,
        pub show_pitch_accent_graph: bool,
        pub show_iframe_popups_in_root_frame: bool,
        pub use_secure_popup_frame_url: bool,
        pub use_popup_shadow_dom: bool,
        pub use_popup_window: bool,
        pub popup_current_indicator_mode: PopupCurrentIndicatorMode,
        pub popup_action_bar_visibility: PopupActionBarVisibility,
        pub popup_action_bar_location: PopupActionBarLocation,
        pub frequency_display_mode: FrequencyDisplayStyle,
        pub term_display_mode: TermDisplayStyle,
        pub sort_frequency_dictionary: Option<String>,
        pub sort_frequency_dictionary_order: FindTermsSortOrder,
        pub sticky_search_header: bool,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for GeneralOptions {
        #[inline]
        fn clone(&self) -> GeneralOptions {
            GeneralOptions {
                enable: ::core::clone::Clone::clone(&self.enable),
                language: ::core::clone::Clone::clone(&self.language),
                result_output_mode: ::core::clone::Clone::clone(
                    &self.result_output_mode,
                ),
                debug_info: ::core::clone::Clone::clone(&self.debug_info),
                max_results: ::core::clone::Clone::clone(&self.max_results),
                show_advanced: ::core::clone::Clone::clone(&self.show_advanced),
                font_family: ::core::clone::Clone::clone(&self.font_family),
                font_size: ::core::clone::Clone::clone(&self.font_size),
                line_height: ::core::clone::Clone::clone(&self.line_height),
                popup_display_mode: ::core::clone::Clone::clone(
                    &self.popup_display_mode,
                ),
                popup_width: ::core::clone::Clone::clone(&self.popup_width),
                popup_height: ::core::clone::Clone::clone(&self.popup_height),
                popup_horizontal_offset: ::core::clone::Clone::clone(
                    &self.popup_horizontal_offset,
                ),
                popup_vertical_offset: ::core::clone::Clone::clone(
                    &self.popup_vertical_offset,
                ),
                popup_horizontal_offset2: ::core::clone::Clone::clone(
                    &self.popup_horizontal_offset2,
                ),
                popup_vertical_offset2: ::core::clone::Clone::clone(
                    &self.popup_vertical_offset2,
                ),
                popup_horizontal_text_position: ::core::clone::Clone::clone(
                    &self.popup_horizontal_text_position,
                ),
                popup_vertical_text_position: ::core::clone::Clone::clone(
                    &self.popup_vertical_text_position,
                ),
                popup_scaling_factor: ::core::clone::Clone::clone(
                    &self.popup_scaling_factor,
                ),
                popup_scale_relative_to_page_zoom: ::core::clone::Clone::clone(
                    &self.popup_scale_relative_to_page_zoom,
                ),
                popup_scale_relative_to_visual_viewport: ::core::clone::Clone::clone(
                    &self.popup_scale_relative_to_visual_viewport,
                ),
                show_guide: ::core::clone::Clone::clone(&self.show_guide),
                enable_context_menu_scan_selected: ::core::clone::Clone::clone(
                    &self.enable_context_menu_scan_selected,
                ),
                compact_tags: ::core::clone::Clone::clone(&self.compact_tags),
                compact_glossaries: ::core::clone::Clone::clone(
                    &self.compact_glossaries,
                ),
                main_dictionary: ::core::clone::Clone::clone(&self.main_dictionary),
                popup_theme: ::core::clone::Clone::clone(&self.popup_theme),
                popup_outer_theme: ::core::clone::Clone::clone(&self.popup_outer_theme),
                custom_popup_css: ::core::clone::Clone::clone(&self.custom_popup_css),
                custom_popup_outer_css: ::core::clone::Clone::clone(
                    &self.custom_popup_outer_css,
                ),
                enable_wanakana: ::core::clone::Clone::clone(&self.enable_wanakana),
                show_pitch_accent_downstep_notation: ::core::clone::Clone::clone(
                    &self.show_pitch_accent_downstep_notation,
                ),
                show_pitch_accent_position_notation: ::core::clone::Clone::clone(
                    &self.show_pitch_accent_position_notation,
                ),
                show_pitch_accent_graph: ::core::clone::Clone::clone(
                    &self.show_pitch_accent_graph,
                ),
                show_iframe_popups_in_root_frame: ::core::clone::Clone::clone(
                    &self.show_iframe_popups_in_root_frame,
                ),
                use_secure_popup_frame_url: ::core::clone::Clone::clone(
                    &self.use_secure_popup_frame_url,
                ),
                use_popup_shadow_dom: ::core::clone::Clone::clone(
                    &self.use_popup_shadow_dom,
                ),
                use_popup_window: ::core::clone::Clone::clone(&self.use_popup_window),
                popup_current_indicator_mode: ::core::clone::Clone::clone(
                    &self.popup_current_indicator_mode,
                ),
                popup_action_bar_visibility: ::core::clone::Clone::clone(
                    &self.popup_action_bar_visibility,
                ),
                popup_action_bar_location: ::core::clone::Clone::clone(
                    &self.popup_action_bar_location,
                ),
                frequency_display_mode: ::core::clone::Clone::clone(
                    &self.frequency_display_mode,
                ),
                term_display_mode: ::core::clone::Clone::clone(&self.term_display_mode),
                sort_frequency_dictionary: ::core::clone::Clone::clone(
                    &self.sort_frequency_dictionary,
                ),
                sort_frequency_dictionary_order: ::core::clone::Clone::clone(
                    &self.sort_frequency_dictionary_order,
                ),
                sticky_search_header: ::core::clone::Clone::clone(
                    &self.sticky_search_header,
                ),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for GeneralOptions {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "enable",
                "language",
                "result_output_mode",
                "debug_info",
                "max_results",
                "show_advanced",
                "font_family",
                "font_size",
                "line_height",
                "popup_display_mode",
                "popup_width",
                "popup_height",
                "popup_horizontal_offset",
                "popup_vertical_offset",
                "popup_horizontal_offset2",
                "popup_vertical_offset2",
                "popup_horizontal_text_position",
                "popup_vertical_text_position",
                "popup_scaling_factor",
                "popup_scale_relative_to_page_zoom",
                "popup_scale_relative_to_visual_viewport",
                "show_guide",
                "enable_context_menu_scan_selected",
                "compact_tags",
                "compact_glossaries",
                "main_dictionary",
                "popup_theme",
                "popup_outer_theme",
                "custom_popup_css",
                "custom_popup_outer_css",
                "enable_wanakana",
                "show_pitch_accent_downstep_notation",
                "show_pitch_accent_position_notation",
                "show_pitch_accent_graph",
                "show_iframe_popups_in_root_frame",
                "use_secure_popup_frame_url",
                "use_popup_shadow_dom",
                "use_popup_window",
                "popup_current_indicator_mode",
                "popup_action_bar_visibility",
                "popup_action_bar_location",
                "frequency_display_mode",
                "term_display_mode",
                "sort_frequency_dictionary",
                "sort_frequency_dictionary_order",
                "sticky_search_header",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.enable,
                &self.language,
                &self.result_output_mode,
                &self.debug_info,
                &self.max_results,
                &self.show_advanced,
                &self.font_family,
                &self.font_size,
                &self.line_height,
                &self.popup_display_mode,
                &self.popup_width,
                &self.popup_height,
                &self.popup_horizontal_offset,
                &self.popup_vertical_offset,
                &self.popup_horizontal_offset2,
                &self.popup_vertical_offset2,
                &self.popup_horizontal_text_position,
                &self.popup_vertical_text_position,
                &self.popup_scaling_factor,
                &self.popup_scale_relative_to_page_zoom,
                &self.popup_scale_relative_to_visual_viewport,
                &self.show_guide,
                &self.enable_context_menu_scan_selected,
                &self.compact_tags,
                &self.compact_glossaries,
                &self.main_dictionary,
                &self.popup_theme,
                &self.popup_outer_theme,
                &self.custom_popup_css,
                &self.custom_popup_outer_css,
                &self.enable_wanakana,
                &self.show_pitch_accent_downstep_notation,
                &self.show_pitch_accent_position_notation,
                &self.show_pitch_accent_graph,
                &self.show_iframe_popups_in_root_frame,
                &self.use_secure_popup_frame_url,
                &self.use_popup_shadow_dom,
                &self.use_popup_window,
                &self.popup_current_indicator_mode,
                &self.popup_action_bar_visibility,
                &self.popup_action_bar_location,
                &self.frequency_display_mode,
                &self.term_display_mode,
                &self.sort_frequency_dictionary,
                &self.sort_frequency_dictionary_order,
                &&self.sticky_search_header,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "GeneralOptions",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for GeneralOptions {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for GeneralOptions {
        #[inline]
        fn eq(&self, other: &GeneralOptions) -> bool {
            self.enable == other.enable && self.language == other.language
                && self.result_output_mode == other.result_output_mode
                && self.debug_info == other.debug_info
                && self.max_results == other.max_results
                && self.show_advanced == other.show_advanced
                && self.font_family == other.font_family
                && self.font_size == other.font_size
                && self.line_height == other.line_height
                && self.popup_display_mode == other.popup_display_mode
                && self.popup_width == other.popup_width
                && self.popup_height == other.popup_height
                && self.popup_horizontal_offset == other.popup_horizontal_offset
                && self.popup_vertical_offset == other.popup_vertical_offset
                && self.popup_horizontal_offset2 == other.popup_horizontal_offset2
                && self.popup_vertical_offset2 == other.popup_vertical_offset2
                && self.popup_horizontal_text_position
                    == other.popup_horizontal_text_position
                && self.popup_vertical_text_position
                    == other.popup_vertical_text_position
                && self.popup_scaling_factor == other.popup_scaling_factor
                && self.popup_scale_relative_to_page_zoom
                    == other.popup_scale_relative_to_page_zoom
                && self.popup_scale_relative_to_visual_viewport
                    == other.popup_scale_relative_to_visual_viewport
                && self.show_guide == other.show_guide
                && self.enable_context_menu_scan_selected
                    == other.enable_context_menu_scan_selected
                && self.compact_tags == other.compact_tags
                && self.compact_glossaries == other.compact_glossaries
                && self.main_dictionary == other.main_dictionary
                && self.popup_theme == other.popup_theme
                && self.popup_outer_theme == other.popup_outer_theme
                && self.custom_popup_css == other.custom_popup_css
                && self.custom_popup_outer_css == other.custom_popup_outer_css
                && self.enable_wanakana == other.enable_wanakana
                && self.show_pitch_accent_downstep_notation
                    == other.show_pitch_accent_downstep_notation
                && self.show_pitch_accent_position_notation
                    == other.show_pitch_accent_position_notation
                && self.show_pitch_accent_graph == other.show_pitch_accent_graph
                && self.show_iframe_popups_in_root_frame
                    == other.show_iframe_popups_in_root_frame
                && self.use_secure_popup_frame_url == other.use_secure_popup_frame_url
                && self.use_popup_shadow_dom == other.use_popup_shadow_dom
                && self.use_popup_window == other.use_popup_window
                && self.popup_current_indicator_mode
                    == other.popup_current_indicator_mode
                && self.popup_action_bar_visibility == other.popup_action_bar_visibility
                && self.popup_action_bar_location == other.popup_action_bar_location
                && self.frequency_display_mode == other.frequency_display_mode
                && self.term_display_mode == other.term_display_mode
                && self.sort_frequency_dictionary == other.sort_frequency_dictionary
                && self.sort_frequency_dictionary_order
                    == other.sort_frequency_dictionary_order
                && self.sticky_search_header == other.sticky_search_header
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for GeneralOptions {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "GeneralOptions",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1
                        + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1
                        + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1
                        + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "enable",
                    &self.enable,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "language",
                    &self.language,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "result_output_mode",
                    &self.result_output_mode,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "debug_info",
                    &self.debug_info,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "max_results",
                    &self.max_results,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "show_advanced",
                    &self.show_advanced,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "font_family",
                    &self.font_family,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "font_size",
                    &self.font_size,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "line_height",
                    &self.line_height,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "popup_display_mode",
                    &self.popup_display_mode,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "popup_width",
                    &self.popup_width,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "popup_height",
                    &self.popup_height,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "popup_horizontal_offset",
                    &self.popup_horizontal_offset,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "popup_vertical_offset",
                    &self.popup_vertical_offset,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "popup_horizontal_offset2",
                    &self.popup_horizontal_offset2,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "popup_vertical_offset2",
                    &self.popup_vertical_offset2,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "popup_horizontal_text_position",
                    &self.popup_horizontal_text_position,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "popup_vertical_text_position",
                    &self.popup_vertical_text_position,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "popup_scaling_factor",
                    &self.popup_scaling_factor,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "popup_scale_relative_to_page_zoom",
                    &self.popup_scale_relative_to_page_zoom,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "popup_scale_relative_to_visual_viewport",
                    &self.popup_scale_relative_to_visual_viewport,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "show_guide",
                    &self.show_guide,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "enable_context_menu_scan_selected",
                    &self.enable_context_menu_scan_selected,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "compact_tags",
                    &self.compact_tags,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "compact_glossaries",
                    &self.compact_glossaries,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "main_dictionary",
                    &self.main_dictionary,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "popup_theme",
                    &self.popup_theme,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "popup_outer_theme",
                    &self.popup_outer_theme,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "custom_popup_css",
                    &self.custom_popup_css,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "custom_popup_outer_css",
                    &self.custom_popup_outer_css,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "enable_wanakana",
                    &self.enable_wanakana,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "show_pitch_accent_downstep_notation",
                    &self.show_pitch_accent_downstep_notation,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "show_pitch_accent_position_notation",
                    &self.show_pitch_accent_position_notation,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "show_pitch_accent_graph",
                    &self.show_pitch_accent_graph,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "show_iframe_popups_in_root_frame",
                    &self.show_iframe_popups_in_root_frame,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "use_secure_popup_frame_url",
                    &self.use_secure_popup_frame_url,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "use_popup_shadow_dom",
                    &self.use_popup_shadow_dom,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "use_popup_window",
                    &self.use_popup_window,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "popup_current_indicator_mode",
                    &self.popup_current_indicator_mode,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "popup_action_bar_visibility",
                    &self.popup_action_bar_visibility,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "popup_action_bar_location",
                    &self.popup_action_bar_location,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "frequency_display_mode",
                    &self.frequency_display_mode,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "term_display_mode",
                    &self.term_display_mode,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "sort_frequency_dictionary",
                    &self.sort_frequency_dictionary,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "sort_frequency_dictionary_order",
                    &self.sort_frequency_dictionary_order,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "sticky_search_header",
                    &self.sticky_search_header,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for GeneralOptions {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __field8,
                    __field9,
                    __field10,
                    __field11,
                    __field12,
                    __field13,
                    __field14,
                    __field15,
                    __field16,
                    __field17,
                    __field18,
                    __field19,
                    __field20,
                    __field21,
                    __field22,
                    __field23,
                    __field24,
                    __field25,
                    __field26,
                    __field27,
                    __field28,
                    __field29,
                    __field30,
                    __field31,
                    __field32,
                    __field33,
                    __field34,
                    __field35,
                    __field36,
                    __field37,
                    __field38,
                    __field39,
                    __field40,
                    __field41,
                    __field42,
                    __field43,
                    __field44,
                    __field45,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            8u64 => _serde::__private::Ok(__Field::__field8),
                            9u64 => _serde::__private::Ok(__Field::__field9),
                            10u64 => _serde::__private::Ok(__Field::__field10),
                            11u64 => _serde::__private::Ok(__Field::__field11),
                            12u64 => _serde::__private::Ok(__Field::__field12),
                            13u64 => _serde::__private::Ok(__Field::__field13),
                            14u64 => _serde::__private::Ok(__Field::__field14),
                            15u64 => _serde::__private::Ok(__Field::__field15),
                            16u64 => _serde::__private::Ok(__Field::__field16),
                            17u64 => _serde::__private::Ok(__Field::__field17),
                            18u64 => _serde::__private::Ok(__Field::__field18),
                            19u64 => _serde::__private::Ok(__Field::__field19),
                            20u64 => _serde::__private::Ok(__Field::__field20),
                            21u64 => _serde::__private::Ok(__Field::__field21),
                            22u64 => _serde::__private::Ok(__Field::__field22),
                            23u64 => _serde::__private::Ok(__Field::__field23),
                            24u64 => _serde::__private::Ok(__Field::__field24),
                            25u64 => _serde::__private::Ok(__Field::__field25),
                            26u64 => _serde::__private::Ok(__Field::__field26),
                            27u64 => _serde::__private::Ok(__Field::__field27),
                            28u64 => _serde::__private::Ok(__Field::__field28),
                            29u64 => _serde::__private::Ok(__Field::__field29),
                            30u64 => _serde::__private::Ok(__Field::__field30),
                            31u64 => _serde::__private::Ok(__Field::__field31),
                            32u64 => _serde::__private::Ok(__Field::__field32),
                            33u64 => _serde::__private::Ok(__Field::__field33),
                            34u64 => _serde::__private::Ok(__Field::__field34),
                            35u64 => _serde::__private::Ok(__Field::__field35),
                            36u64 => _serde::__private::Ok(__Field::__field36),
                            37u64 => _serde::__private::Ok(__Field::__field37),
                            38u64 => _serde::__private::Ok(__Field::__field38),
                            39u64 => _serde::__private::Ok(__Field::__field39),
                            40u64 => _serde::__private::Ok(__Field::__field40),
                            41u64 => _serde::__private::Ok(__Field::__field41),
                            42u64 => _serde::__private::Ok(__Field::__field42),
                            43u64 => _serde::__private::Ok(__Field::__field43),
                            44u64 => _serde::__private::Ok(__Field::__field44),
                            45u64 => _serde::__private::Ok(__Field::__field45),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "enable" => _serde::__private::Ok(__Field::__field0),
                            "language" => _serde::__private::Ok(__Field::__field1),
                            "result_output_mode" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            "debug_info" => _serde::__private::Ok(__Field::__field3),
                            "max_results" => _serde::__private::Ok(__Field::__field4),
                            "show_advanced" => _serde::__private::Ok(__Field::__field5),
                            "font_family" => _serde::__private::Ok(__Field::__field6),
                            "font_size" => _serde::__private::Ok(__Field::__field7),
                            "line_height" => _serde::__private::Ok(__Field::__field8),
                            "popup_display_mode" => {
                                _serde::__private::Ok(__Field::__field9)
                            }
                            "popup_width" => _serde::__private::Ok(__Field::__field10),
                            "popup_height" => _serde::__private::Ok(__Field::__field11),
                            "popup_horizontal_offset" => {
                                _serde::__private::Ok(__Field::__field12)
                            }
                            "popup_vertical_offset" => {
                                _serde::__private::Ok(__Field::__field13)
                            }
                            "popup_horizontal_offset2" => {
                                _serde::__private::Ok(__Field::__field14)
                            }
                            "popup_vertical_offset2" => {
                                _serde::__private::Ok(__Field::__field15)
                            }
                            "popup_horizontal_text_position" => {
                                _serde::__private::Ok(__Field::__field16)
                            }
                            "popup_vertical_text_position" => {
                                _serde::__private::Ok(__Field::__field17)
                            }
                            "popup_scaling_factor" => {
                                _serde::__private::Ok(__Field::__field18)
                            }
                            "popup_scale_relative_to_page_zoom" => {
                                _serde::__private::Ok(__Field::__field19)
                            }
                            "popup_scale_relative_to_visual_viewport" => {
                                _serde::__private::Ok(__Field::__field20)
                            }
                            "show_guide" => _serde::__private::Ok(__Field::__field21),
                            "enable_context_menu_scan_selected" => {
                                _serde::__private::Ok(__Field::__field22)
                            }
                            "compact_tags" => _serde::__private::Ok(__Field::__field23),
                            "compact_glossaries" => {
                                _serde::__private::Ok(__Field::__field24)
                            }
                            "main_dictionary" => {
                                _serde::__private::Ok(__Field::__field25)
                            }
                            "popup_theme" => _serde::__private::Ok(__Field::__field26),
                            "popup_outer_theme" => {
                                _serde::__private::Ok(__Field::__field27)
                            }
                            "custom_popup_css" => {
                                _serde::__private::Ok(__Field::__field28)
                            }
                            "custom_popup_outer_css" => {
                                _serde::__private::Ok(__Field::__field29)
                            }
                            "enable_wanakana" => {
                                _serde::__private::Ok(__Field::__field30)
                            }
                            "show_pitch_accent_downstep_notation" => {
                                _serde::__private::Ok(__Field::__field31)
                            }
                            "show_pitch_accent_position_notation" => {
                                _serde::__private::Ok(__Field::__field32)
                            }
                            "show_pitch_accent_graph" => {
                                _serde::__private::Ok(__Field::__field33)
                            }
                            "show_iframe_popups_in_root_frame" => {
                                _serde::__private::Ok(__Field::__field34)
                            }
                            "use_secure_popup_frame_url" => {
                                _serde::__private::Ok(__Field::__field35)
                            }
                            "use_popup_shadow_dom" => {
                                _serde::__private::Ok(__Field::__field36)
                            }
                            "use_popup_window" => {
                                _serde::__private::Ok(__Field::__field37)
                            }
                            "popup_current_indicator_mode" => {
                                _serde::__private::Ok(__Field::__field38)
                            }
                            "popup_action_bar_visibility" => {
                                _serde::__private::Ok(__Field::__field39)
                            }
                            "popup_action_bar_location" => {
                                _serde::__private::Ok(__Field::__field40)
                            }
                            "frequency_display_mode" => {
                                _serde::__private::Ok(__Field::__field41)
                            }
                            "term_display_mode" => {
                                _serde::__private::Ok(__Field::__field42)
                            }
                            "sort_frequency_dictionary" => {
                                _serde::__private::Ok(__Field::__field43)
                            }
                            "sort_frequency_dictionary_order" => {
                                _serde::__private::Ok(__Field::__field44)
                            }
                            "sticky_search_header" => {
                                _serde::__private::Ok(__Field::__field45)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"enable" => _serde::__private::Ok(__Field::__field0),
                            b"language" => _serde::__private::Ok(__Field::__field1),
                            b"result_output_mode" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            b"debug_info" => _serde::__private::Ok(__Field::__field3),
                            b"max_results" => _serde::__private::Ok(__Field::__field4),
                            b"show_advanced" => _serde::__private::Ok(__Field::__field5),
                            b"font_family" => _serde::__private::Ok(__Field::__field6),
                            b"font_size" => _serde::__private::Ok(__Field::__field7),
                            b"line_height" => _serde::__private::Ok(__Field::__field8),
                            b"popup_display_mode" => {
                                _serde::__private::Ok(__Field::__field9)
                            }
                            b"popup_width" => _serde::__private::Ok(__Field::__field10),
                            b"popup_height" => _serde::__private::Ok(__Field::__field11),
                            b"popup_horizontal_offset" => {
                                _serde::__private::Ok(__Field::__field12)
                            }
                            b"popup_vertical_offset" => {
                                _serde::__private::Ok(__Field::__field13)
                            }
                            b"popup_horizontal_offset2" => {
                                _serde::__private::Ok(__Field::__field14)
                            }
                            b"popup_vertical_offset2" => {
                                _serde::__private::Ok(__Field::__field15)
                            }
                            b"popup_horizontal_text_position" => {
                                _serde::__private::Ok(__Field::__field16)
                            }
                            b"popup_vertical_text_position" => {
                                _serde::__private::Ok(__Field::__field17)
                            }
                            b"popup_scaling_factor" => {
                                _serde::__private::Ok(__Field::__field18)
                            }
                            b"popup_scale_relative_to_page_zoom" => {
                                _serde::__private::Ok(__Field::__field19)
                            }
                            b"popup_scale_relative_to_visual_viewport" => {
                                _serde::__private::Ok(__Field::__field20)
                            }
                            b"show_guide" => _serde::__private::Ok(__Field::__field21),
                            b"enable_context_menu_scan_selected" => {
                                _serde::__private::Ok(__Field::__field22)
                            }
                            b"compact_tags" => _serde::__private::Ok(__Field::__field23),
                            b"compact_glossaries" => {
                                _serde::__private::Ok(__Field::__field24)
                            }
                            b"main_dictionary" => {
                                _serde::__private::Ok(__Field::__field25)
                            }
                            b"popup_theme" => _serde::__private::Ok(__Field::__field26),
                            b"popup_outer_theme" => {
                                _serde::__private::Ok(__Field::__field27)
                            }
                            b"custom_popup_css" => {
                                _serde::__private::Ok(__Field::__field28)
                            }
                            b"custom_popup_outer_css" => {
                                _serde::__private::Ok(__Field::__field29)
                            }
                            b"enable_wanakana" => {
                                _serde::__private::Ok(__Field::__field30)
                            }
                            b"show_pitch_accent_downstep_notation" => {
                                _serde::__private::Ok(__Field::__field31)
                            }
                            b"show_pitch_accent_position_notation" => {
                                _serde::__private::Ok(__Field::__field32)
                            }
                            b"show_pitch_accent_graph" => {
                                _serde::__private::Ok(__Field::__field33)
                            }
                            b"show_iframe_popups_in_root_frame" => {
                                _serde::__private::Ok(__Field::__field34)
                            }
                            b"use_secure_popup_frame_url" => {
                                _serde::__private::Ok(__Field::__field35)
                            }
                            b"use_popup_shadow_dom" => {
                                _serde::__private::Ok(__Field::__field36)
                            }
                            b"use_popup_window" => {
                                _serde::__private::Ok(__Field::__field37)
                            }
                            b"popup_current_indicator_mode" => {
                                _serde::__private::Ok(__Field::__field38)
                            }
                            b"popup_action_bar_visibility" => {
                                _serde::__private::Ok(__Field::__field39)
                            }
                            b"popup_action_bar_location" => {
                                _serde::__private::Ok(__Field::__field40)
                            }
                            b"frequency_display_mode" => {
                                _serde::__private::Ok(__Field::__field41)
                            }
                            b"term_display_mode" => {
                                _serde::__private::Ok(__Field::__field42)
                            }
                            b"sort_frequency_dictionary" => {
                                _serde::__private::Ok(__Field::__field43)
                            }
                            b"sort_frequency_dictionary_order" => {
                                _serde::__private::Ok(__Field::__field44)
                            }
                            b"sticky_search_header" => {
                                _serde::__private::Ok(__Field::__field45)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<GeneralOptions>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = GeneralOptions;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct GeneralOptions",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct GeneralOptions with 46 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct GeneralOptions with 46 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            FindTermsMode,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct GeneralOptions with 46 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct GeneralOptions with 46 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            u8,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct GeneralOptions with 46 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct GeneralOptions with 46 elements",
                                    ),
                                );
                            }
                        };
                        let __field6 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        6usize,
                                        &"struct GeneralOptions with 46 elements",
                                    ),
                                );
                            }
                        };
                        let __field7 = match _serde::de::SeqAccess::next_element::<
                            u8,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        7usize,
                                        &"struct GeneralOptions with 46 elements",
                                    ),
                                );
                            }
                        };
                        let __field8 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        8usize,
                                        &"struct GeneralOptions with 46 elements",
                                    ),
                                );
                            }
                        };
                        let __field9 = match _serde::de::SeqAccess::next_element::<
                            PopupDisplayMode,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        9usize,
                                        &"struct GeneralOptions with 46 elements",
                                    ),
                                );
                            }
                        };
                        let __field10 = match _serde::de::SeqAccess::next_element::<
                            u8,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        10usize,
                                        &"struct GeneralOptions with 46 elements",
                                    ),
                                );
                            }
                        };
                        let __field11 = match _serde::de::SeqAccess::next_element::<
                            u8,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        11usize,
                                        &"struct GeneralOptions with 46 elements",
                                    ),
                                );
                            }
                        };
                        let __field12 = match _serde::de::SeqAccess::next_element::<
                            u8,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        12usize,
                                        &"struct GeneralOptions with 46 elements",
                                    ),
                                );
                            }
                        };
                        let __field13 = match _serde::de::SeqAccess::next_element::<
                            u8,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        13usize,
                                        &"struct GeneralOptions with 46 elements",
                                    ),
                                );
                            }
                        };
                        let __field14 = match _serde::de::SeqAccess::next_element::<
                            u8,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        14usize,
                                        &"struct GeneralOptions with 46 elements",
                                    ),
                                );
                            }
                        };
                        let __field15 = match _serde::de::SeqAccess::next_element::<
                            u8,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        15usize,
                                        &"struct GeneralOptions with 46 elements",
                                    ),
                                );
                            }
                        };
                        let __field16 = match _serde::de::SeqAccess::next_element::<
                            PopupHorizontalTextPosition,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        16usize,
                                        &"struct GeneralOptions with 46 elements",
                                    ),
                                );
                            }
                        };
                        let __field17 = match _serde::de::SeqAccess::next_element::<
                            PopupVerticalTextPosition,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        17usize,
                                        &"struct GeneralOptions with 46 elements",
                                    ),
                                );
                            }
                        };
                        let __field18 = match _serde::de::SeqAccess::next_element::<
                            u8,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        18usize,
                                        &"struct GeneralOptions with 46 elements",
                                    ),
                                );
                            }
                        };
                        let __field19 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        19usize,
                                        &"struct GeneralOptions with 46 elements",
                                    ),
                                );
                            }
                        };
                        let __field20 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        20usize,
                                        &"struct GeneralOptions with 46 elements",
                                    ),
                                );
                            }
                        };
                        let __field21 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        21usize,
                                        &"struct GeneralOptions with 46 elements",
                                    ),
                                );
                            }
                        };
                        let __field22 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        22usize,
                                        &"struct GeneralOptions with 46 elements",
                                    ),
                                );
                            }
                        };
                        let __field23 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        23usize,
                                        &"struct GeneralOptions with 46 elements",
                                    ),
                                );
                            }
                        };
                        let __field24 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        24usize,
                                        &"struct GeneralOptions with 46 elements",
                                    ),
                                );
                            }
                        };
                        let __field25 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        25usize,
                                        &"struct GeneralOptions with 46 elements",
                                    ),
                                );
                            }
                        };
                        let __field26 = match _serde::de::SeqAccess::next_element::<
                            PopupTheme,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        26usize,
                                        &"struct GeneralOptions with 46 elements",
                                    ),
                                );
                            }
                        };
                        let __field27 = match _serde::de::SeqAccess::next_element::<
                            PopupShadow,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        27usize,
                                        &"struct GeneralOptions with 46 elements",
                                    ),
                                );
                            }
                        };
                        let __field28 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        28usize,
                                        &"struct GeneralOptions with 46 elements",
                                    ),
                                );
                            }
                        };
                        let __field29 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        29usize,
                                        &"struct GeneralOptions with 46 elements",
                                    ),
                                );
                            }
                        };
                        let __field30 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        30usize,
                                        &"struct GeneralOptions with 46 elements",
                                    ),
                                );
                            }
                        };
                        let __field31 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        31usize,
                                        &"struct GeneralOptions with 46 elements",
                                    ),
                                );
                            }
                        };
                        let __field32 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        32usize,
                                        &"struct GeneralOptions with 46 elements",
                                    ),
                                );
                            }
                        };
                        let __field33 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        33usize,
                                        &"struct GeneralOptions with 46 elements",
                                    ),
                                );
                            }
                        };
                        let __field34 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        34usize,
                                        &"struct GeneralOptions with 46 elements",
                                    ),
                                );
                            }
                        };
                        let __field35 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        35usize,
                                        &"struct GeneralOptions with 46 elements",
                                    ),
                                );
                            }
                        };
                        let __field36 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        36usize,
                                        &"struct GeneralOptions with 46 elements",
                                    ),
                                );
                            }
                        };
                        let __field37 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        37usize,
                                        &"struct GeneralOptions with 46 elements",
                                    ),
                                );
                            }
                        };
                        let __field38 = match _serde::de::SeqAccess::next_element::<
                            PopupCurrentIndicatorMode,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        38usize,
                                        &"struct GeneralOptions with 46 elements",
                                    ),
                                );
                            }
                        };
                        let __field39 = match _serde::de::SeqAccess::next_element::<
                            PopupActionBarVisibility,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        39usize,
                                        &"struct GeneralOptions with 46 elements",
                                    ),
                                );
                            }
                        };
                        let __field40 = match _serde::de::SeqAccess::next_element::<
                            PopupActionBarLocation,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        40usize,
                                        &"struct GeneralOptions with 46 elements",
                                    ),
                                );
                            }
                        };
                        let __field41 = match _serde::de::SeqAccess::next_element::<
                            FrequencyDisplayStyle,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        41usize,
                                        &"struct GeneralOptions with 46 elements",
                                    ),
                                );
                            }
                        };
                        let __field42 = match _serde::de::SeqAccess::next_element::<
                            TermDisplayStyle,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        42usize,
                                        &"struct GeneralOptions with 46 elements",
                                    ),
                                );
                            }
                        };
                        let __field43 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        43usize,
                                        &"struct GeneralOptions with 46 elements",
                                    ),
                                );
                            }
                        };
                        let __field44 = match _serde::de::SeqAccess::next_element::<
                            FindTermsSortOrder,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        44usize,
                                        &"struct GeneralOptions with 46 elements",
                                    ),
                                );
                            }
                        };
                        let __field45 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        45usize,
                                        &"struct GeneralOptions with 46 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(GeneralOptions {
                            enable: __field0,
                            language: __field1,
                            result_output_mode: __field2,
                            debug_info: __field3,
                            max_results: __field4,
                            show_advanced: __field5,
                            font_family: __field6,
                            font_size: __field7,
                            line_height: __field8,
                            popup_display_mode: __field9,
                            popup_width: __field10,
                            popup_height: __field11,
                            popup_horizontal_offset: __field12,
                            popup_vertical_offset: __field13,
                            popup_horizontal_offset2: __field14,
                            popup_vertical_offset2: __field15,
                            popup_horizontal_text_position: __field16,
                            popup_vertical_text_position: __field17,
                            popup_scaling_factor: __field18,
                            popup_scale_relative_to_page_zoom: __field19,
                            popup_scale_relative_to_visual_viewport: __field20,
                            show_guide: __field21,
                            enable_context_menu_scan_selected: __field22,
                            compact_tags: __field23,
                            compact_glossaries: __field24,
                            main_dictionary: __field25,
                            popup_theme: __field26,
                            popup_outer_theme: __field27,
                            custom_popup_css: __field28,
                            custom_popup_outer_css: __field29,
                            enable_wanakana: __field30,
                            show_pitch_accent_downstep_notation: __field31,
                            show_pitch_accent_position_notation: __field32,
                            show_pitch_accent_graph: __field33,
                            show_iframe_popups_in_root_frame: __field34,
                            use_secure_popup_frame_url: __field35,
                            use_popup_shadow_dom: __field36,
                            use_popup_window: __field37,
                            popup_current_indicator_mode: __field38,
                            popup_action_bar_visibility: __field39,
                            popup_action_bar_location: __field40,
                            frequency_display_mode: __field41,
                            term_display_mode: __field42,
                            sort_frequency_dictionary: __field43,
                            sort_frequency_dictionary_order: __field44,
                            sticky_search_header: __field45,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<FindTermsMode> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<u8> = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field6: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field7: _serde::__private::Option<u8> = _serde::__private::None;
                        let mut __field8: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field9: _serde::__private::Option<PopupDisplayMode> = _serde::__private::None;
                        let mut __field10: _serde::__private::Option<u8> = _serde::__private::None;
                        let mut __field11: _serde::__private::Option<u8> = _serde::__private::None;
                        let mut __field12: _serde::__private::Option<u8> = _serde::__private::None;
                        let mut __field13: _serde::__private::Option<u8> = _serde::__private::None;
                        let mut __field14: _serde::__private::Option<u8> = _serde::__private::None;
                        let mut __field15: _serde::__private::Option<u8> = _serde::__private::None;
                        let mut __field16: _serde::__private::Option<
                            PopupHorizontalTextPosition,
                        > = _serde::__private::None;
                        let mut __field17: _serde::__private::Option<
                            PopupVerticalTextPosition,
                        > = _serde::__private::None;
                        let mut __field18: _serde::__private::Option<u8> = _serde::__private::None;
                        let mut __field19: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field20: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field21: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field22: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field23: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field24: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field25: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field26: _serde::__private::Option<PopupTheme> = _serde::__private::None;
                        let mut __field27: _serde::__private::Option<PopupShadow> = _serde::__private::None;
                        let mut __field28: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field29: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field30: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field31: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field32: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field33: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field34: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field35: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field36: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field37: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field38: _serde::__private::Option<
                            PopupCurrentIndicatorMode,
                        > = _serde::__private::None;
                        let mut __field39: _serde::__private::Option<
                            PopupActionBarVisibility,
                        > = _serde::__private::None;
                        let mut __field40: _serde::__private::Option<
                            PopupActionBarLocation,
                        > = _serde::__private::None;
                        let mut __field41: _serde::__private::Option<
                            FrequencyDisplayStyle,
                        > = _serde::__private::None;
                        let mut __field42: _serde::__private::Option<TermDisplayStyle> = _serde::__private::None;
                        let mut __field43: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field44: _serde::__private::Option<
                            FindTermsSortOrder,
                        > = _serde::__private::None;
                        let mut __field45: _serde::__private::Option<bool> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("enable"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "language",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "result_output_mode",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            FindTermsMode,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "debug_info",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "max_results",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u8>(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "show_advanced",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "font_family",
                                            ),
                                        );
                                    }
                                    __field6 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field7 => {
                                    if _serde::__private::Option::is_some(&__field7) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "font_size",
                                            ),
                                        );
                                    }
                                    __field7 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u8>(&mut __map)?,
                                    );
                                }
                                __Field::__field8 => {
                                    if _serde::__private::Option::is_some(&__field8) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "line_height",
                                            ),
                                        );
                                    }
                                    __field8 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field9 => {
                                    if _serde::__private::Option::is_some(&__field9) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "popup_display_mode",
                                            ),
                                        );
                                    }
                                    __field9 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            PopupDisplayMode,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field10 => {
                                    if _serde::__private::Option::is_some(&__field10) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "popup_width",
                                            ),
                                        );
                                    }
                                    __field10 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u8>(&mut __map)?,
                                    );
                                }
                                __Field::__field11 => {
                                    if _serde::__private::Option::is_some(&__field11) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "popup_height",
                                            ),
                                        );
                                    }
                                    __field11 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u8>(&mut __map)?,
                                    );
                                }
                                __Field::__field12 => {
                                    if _serde::__private::Option::is_some(&__field12) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "popup_horizontal_offset",
                                            ),
                                        );
                                    }
                                    __field12 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u8>(&mut __map)?,
                                    );
                                }
                                __Field::__field13 => {
                                    if _serde::__private::Option::is_some(&__field13) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "popup_vertical_offset",
                                            ),
                                        );
                                    }
                                    __field13 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u8>(&mut __map)?,
                                    );
                                }
                                __Field::__field14 => {
                                    if _serde::__private::Option::is_some(&__field14) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "popup_horizontal_offset2",
                                            ),
                                        );
                                    }
                                    __field14 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u8>(&mut __map)?,
                                    );
                                }
                                __Field::__field15 => {
                                    if _serde::__private::Option::is_some(&__field15) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "popup_vertical_offset2",
                                            ),
                                        );
                                    }
                                    __field15 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u8>(&mut __map)?,
                                    );
                                }
                                __Field::__field16 => {
                                    if _serde::__private::Option::is_some(&__field16) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "popup_horizontal_text_position",
                                            ),
                                        );
                                    }
                                    __field16 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            PopupHorizontalTextPosition,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field17 => {
                                    if _serde::__private::Option::is_some(&__field17) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "popup_vertical_text_position",
                                            ),
                                        );
                                    }
                                    __field17 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            PopupVerticalTextPosition,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field18 => {
                                    if _serde::__private::Option::is_some(&__field18) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "popup_scaling_factor",
                                            ),
                                        );
                                    }
                                    __field18 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u8>(&mut __map)?,
                                    );
                                }
                                __Field::__field19 => {
                                    if _serde::__private::Option::is_some(&__field19) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "popup_scale_relative_to_page_zoom",
                                            ),
                                        );
                                    }
                                    __field19 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field20 => {
                                    if _serde::__private::Option::is_some(&__field20) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "popup_scale_relative_to_visual_viewport",
                                            ),
                                        );
                                    }
                                    __field20 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field21 => {
                                    if _serde::__private::Option::is_some(&__field21) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "show_guide",
                                            ),
                                        );
                                    }
                                    __field21 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field22 => {
                                    if _serde::__private::Option::is_some(&__field22) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "enable_context_menu_scan_selected",
                                            ),
                                        );
                                    }
                                    __field22 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field23 => {
                                    if _serde::__private::Option::is_some(&__field23) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "compact_tags",
                                            ),
                                        );
                                    }
                                    __field23 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field24 => {
                                    if _serde::__private::Option::is_some(&__field24) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "compact_glossaries",
                                            ),
                                        );
                                    }
                                    __field24 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field25 => {
                                    if _serde::__private::Option::is_some(&__field25) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "main_dictionary",
                                            ),
                                        );
                                    }
                                    __field25 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field26 => {
                                    if _serde::__private::Option::is_some(&__field26) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "popup_theme",
                                            ),
                                        );
                                    }
                                    __field26 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<PopupTheme>(&mut __map)?,
                                    );
                                }
                                __Field::__field27 => {
                                    if _serde::__private::Option::is_some(&__field27) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "popup_outer_theme",
                                            ),
                                        );
                                    }
                                    __field27 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            PopupShadow,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field28 => {
                                    if _serde::__private::Option::is_some(&__field28) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "custom_popup_css",
                                            ),
                                        );
                                    }
                                    __field28 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field29 => {
                                    if _serde::__private::Option::is_some(&__field29) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "custom_popup_outer_css",
                                            ),
                                        );
                                    }
                                    __field29 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field30 => {
                                    if _serde::__private::Option::is_some(&__field30) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "enable_wanakana",
                                            ),
                                        );
                                    }
                                    __field30 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field31 => {
                                    if _serde::__private::Option::is_some(&__field31) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "show_pitch_accent_downstep_notation",
                                            ),
                                        );
                                    }
                                    __field31 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field32 => {
                                    if _serde::__private::Option::is_some(&__field32) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "show_pitch_accent_position_notation",
                                            ),
                                        );
                                    }
                                    __field32 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field33 => {
                                    if _serde::__private::Option::is_some(&__field33) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "show_pitch_accent_graph",
                                            ),
                                        );
                                    }
                                    __field33 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field34 => {
                                    if _serde::__private::Option::is_some(&__field34) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "show_iframe_popups_in_root_frame",
                                            ),
                                        );
                                    }
                                    __field34 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field35 => {
                                    if _serde::__private::Option::is_some(&__field35) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "use_secure_popup_frame_url",
                                            ),
                                        );
                                    }
                                    __field35 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field36 => {
                                    if _serde::__private::Option::is_some(&__field36) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "use_popup_shadow_dom",
                                            ),
                                        );
                                    }
                                    __field36 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field37 => {
                                    if _serde::__private::Option::is_some(&__field37) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "use_popup_window",
                                            ),
                                        );
                                    }
                                    __field37 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field38 => {
                                    if _serde::__private::Option::is_some(&__field38) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "popup_current_indicator_mode",
                                            ),
                                        );
                                    }
                                    __field38 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            PopupCurrentIndicatorMode,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field39 => {
                                    if _serde::__private::Option::is_some(&__field39) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "popup_action_bar_visibility",
                                            ),
                                        );
                                    }
                                    __field39 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            PopupActionBarVisibility,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field40 => {
                                    if _serde::__private::Option::is_some(&__field40) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "popup_action_bar_location",
                                            ),
                                        );
                                    }
                                    __field40 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            PopupActionBarLocation,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field41 => {
                                    if _serde::__private::Option::is_some(&__field41) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "frequency_display_mode",
                                            ),
                                        );
                                    }
                                    __field41 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            FrequencyDisplayStyle,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field42 => {
                                    if _serde::__private::Option::is_some(&__field42) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "term_display_mode",
                                            ),
                                        );
                                    }
                                    __field42 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            TermDisplayStyle,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field43 => {
                                    if _serde::__private::Option::is_some(&__field43) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "sort_frequency_dictionary",
                                            ),
                                        );
                                    }
                                    __field43 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field44 => {
                                    if _serde::__private::Option::is_some(&__field44) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "sort_frequency_dictionary_order",
                                            ),
                                        );
                                    }
                                    __field44 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            FindTermsSortOrder,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field45 => {
                                    if _serde::__private::Option::is_some(&__field45) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "sticky_search_header",
                                            ),
                                        );
                                    }
                                    __field45 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("enable")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("language")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("result_output_mode")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("debug_info")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("max_results")?
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("show_advanced")?
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("font_family")?
                            }
                        };
                        let __field7 = match __field7 {
                            _serde::__private::Some(__field7) => __field7,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("font_size")?
                            }
                        };
                        let __field8 = match __field8 {
                            _serde::__private::Some(__field8) => __field8,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("line_height")?
                            }
                        };
                        let __field9 = match __field9 {
                            _serde::__private::Some(__field9) => __field9,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("popup_display_mode")?
                            }
                        };
                        let __field10 = match __field10 {
                            _serde::__private::Some(__field10) => __field10,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("popup_width")?
                            }
                        };
                        let __field11 = match __field11 {
                            _serde::__private::Some(__field11) => __field11,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("popup_height")?
                            }
                        };
                        let __field12 = match __field12 {
                            _serde::__private::Some(__field12) => __field12,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "popup_horizontal_offset",
                                )?
                            }
                        };
                        let __field13 = match __field13 {
                            _serde::__private::Some(__field13) => __field13,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "popup_vertical_offset",
                                )?
                            }
                        };
                        let __field14 = match __field14 {
                            _serde::__private::Some(__field14) => __field14,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "popup_horizontal_offset2",
                                )?
                            }
                        };
                        let __field15 = match __field15 {
                            _serde::__private::Some(__field15) => __field15,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "popup_vertical_offset2",
                                )?
                            }
                        };
                        let __field16 = match __field16 {
                            _serde::__private::Some(__field16) => __field16,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "popup_horizontal_text_position",
                                )?
                            }
                        };
                        let __field17 = match __field17 {
                            _serde::__private::Some(__field17) => __field17,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "popup_vertical_text_position",
                                )?
                            }
                        };
                        let __field18 = match __field18 {
                            _serde::__private::Some(__field18) => __field18,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "popup_scaling_factor",
                                )?
                            }
                        };
                        let __field19 = match __field19 {
                            _serde::__private::Some(__field19) => __field19,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "popup_scale_relative_to_page_zoom",
                                )?
                            }
                        };
                        let __field20 = match __field20 {
                            _serde::__private::Some(__field20) => __field20,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "popup_scale_relative_to_visual_viewport",
                                )?
                            }
                        };
                        let __field21 = match __field21 {
                            _serde::__private::Some(__field21) => __field21,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("show_guide")?
                            }
                        };
                        let __field22 = match __field22 {
                            _serde::__private::Some(__field22) => __field22,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "enable_context_menu_scan_selected",
                                )?
                            }
                        };
                        let __field23 = match __field23 {
                            _serde::__private::Some(__field23) => __field23,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("compact_tags")?
                            }
                        };
                        let __field24 = match __field24 {
                            _serde::__private::Some(__field24) => __field24,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("compact_glossaries")?
                            }
                        };
                        let __field25 = match __field25 {
                            _serde::__private::Some(__field25) => __field25,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("main_dictionary")?
                            }
                        };
                        let __field26 = match __field26 {
                            _serde::__private::Some(__field26) => __field26,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("popup_theme")?
                            }
                        };
                        let __field27 = match __field27 {
                            _serde::__private::Some(__field27) => __field27,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("popup_outer_theme")?
                            }
                        };
                        let __field28 = match __field28 {
                            _serde::__private::Some(__field28) => __field28,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("custom_popup_css")?
                            }
                        };
                        let __field29 = match __field29 {
                            _serde::__private::Some(__field29) => __field29,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "custom_popup_outer_css",
                                )?
                            }
                        };
                        let __field30 = match __field30 {
                            _serde::__private::Some(__field30) => __field30,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("enable_wanakana")?
                            }
                        };
                        let __field31 = match __field31 {
                            _serde::__private::Some(__field31) => __field31,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "show_pitch_accent_downstep_notation",
                                )?
                            }
                        };
                        let __field32 = match __field32 {
                            _serde::__private::Some(__field32) => __field32,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "show_pitch_accent_position_notation",
                                )?
                            }
                        };
                        let __field33 = match __field33 {
                            _serde::__private::Some(__field33) => __field33,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "show_pitch_accent_graph",
                                )?
                            }
                        };
                        let __field34 = match __field34 {
                            _serde::__private::Some(__field34) => __field34,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "show_iframe_popups_in_root_frame",
                                )?
                            }
                        };
                        let __field35 = match __field35 {
                            _serde::__private::Some(__field35) => __field35,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "use_secure_popup_frame_url",
                                )?
                            }
                        };
                        let __field36 = match __field36 {
                            _serde::__private::Some(__field36) => __field36,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "use_popup_shadow_dom",
                                )?
                            }
                        };
                        let __field37 = match __field37 {
                            _serde::__private::Some(__field37) => __field37,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("use_popup_window")?
                            }
                        };
                        let __field38 = match __field38 {
                            _serde::__private::Some(__field38) => __field38,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "popup_current_indicator_mode",
                                )?
                            }
                        };
                        let __field39 = match __field39 {
                            _serde::__private::Some(__field39) => __field39,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "popup_action_bar_visibility",
                                )?
                            }
                        };
                        let __field40 = match __field40 {
                            _serde::__private::Some(__field40) => __field40,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "popup_action_bar_location",
                                )?
                            }
                        };
                        let __field41 = match __field41 {
                            _serde::__private::Some(__field41) => __field41,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "frequency_display_mode",
                                )?
                            }
                        };
                        let __field42 = match __field42 {
                            _serde::__private::Some(__field42) => __field42,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("term_display_mode")?
                            }
                        };
                        let __field43 = match __field43 {
                            _serde::__private::Some(__field43) => __field43,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "sort_frequency_dictionary",
                                )?
                            }
                        };
                        let __field44 = match __field44 {
                            _serde::__private::Some(__field44) => __field44,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "sort_frequency_dictionary_order",
                                )?
                            }
                        };
                        let __field45 = match __field45 {
                            _serde::__private::Some(__field45) => __field45,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "sticky_search_header",
                                )?
                            }
                        };
                        _serde::__private::Ok(GeneralOptions {
                            enable: __field0,
                            language: __field1,
                            result_output_mode: __field2,
                            debug_info: __field3,
                            max_results: __field4,
                            show_advanced: __field5,
                            font_family: __field6,
                            font_size: __field7,
                            line_height: __field8,
                            popup_display_mode: __field9,
                            popup_width: __field10,
                            popup_height: __field11,
                            popup_horizontal_offset: __field12,
                            popup_vertical_offset: __field13,
                            popup_horizontal_offset2: __field14,
                            popup_vertical_offset2: __field15,
                            popup_horizontal_text_position: __field16,
                            popup_vertical_text_position: __field17,
                            popup_scaling_factor: __field18,
                            popup_scale_relative_to_page_zoom: __field19,
                            popup_scale_relative_to_visual_viewport: __field20,
                            show_guide: __field21,
                            enable_context_menu_scan_selected: __field22,
                            compact_tags: __field23,
                            compact_glossaries: __field24,
                            main_dictionary: __field25,
                            popup_theme: __field26,
                            popup_outer_theme: __field27,
                            custom_popup_css: __field28,
                            custom_popup_outer_css: __field29,
                            enable_wanakana: __field30,
                            show_pitch_accent_downstep_notation: __field31,
                            show_pitch_accent_position_notation: __field32,
                            show_pitch_accent_graph: __field33,
                            show_iframe_popups_in_root_frame: __field34,
                            use_secure_popup_frame_url: __field35,
                            use_popup_shadow_dom: __field36,
                            use_popup_window: __field37,
                            popup_current_indicator_mode: __field38,
                            popup_action_bar_visibility: __field39,
                            popup_action_bar_location: __field40,
                            frequency_display_mode: __field41,
                            term_display_mode: __field42,
                            sort_frequency_dictionary: __field43,
                            sort_frequency_dictionary_order: __field44,
                            sticky_search_header: __field45,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "enable",
                    "language",
                    "result_output_mode",
                    "debug_info",
                    "max_results",
                    "show_advanced",
                    "font_family",
                    "font_size",
                    "line_height",
                    "popup_display_mode",
                    "popup_width",
                    "popup_height",
                    "popup_horizontal_offset",
                    "popup_vertical_offset",
                    "popup_horizontal_offset2",
                    "popup_vertical_offset2",
                    "popup_horizontal_text_position",
                    "popup_vertical_text_position",
                    "popup_scaling_factor",
                    "popup_scale_relative_to_page_zoom",
                    "popup_scale_relative_to_visual_viewport",
                    "show_guide",
                    "enable_context_menu_scan_selected",
                    "compact_tags",
                    "compact_glossaries",
                    "main_dictionary",
                    "popup_theme",
                    "popup_outer_theme",
                    "custom_popup_css",
                    "custom_popup_outer_css",
                    "enable_wanakana",
                    "show_pitch_accent_downstep_notation",
                    "show_pitch_accent_position_notation",
                    "show_pitch_accent_graph",
                    "show_iframe_popups_in_root_frame",
                    "use_secure_popup_frame_url",
                    "use_popup_shadow_dom",
                    "use_popup_window",
                    "popup_current_indicator_mode",
                    "popup_action_bar_visibility",
                    "popup_action_bar_location",
                    "frequency_display_mode",
                    "term_display_mode",
                    "sort_frequency_dictionary",
                    "sort_frequency_dictionary_order",
                    "sticky_search_header",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "GeneralOptions",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<GeneralOptions>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for GeneralOptions {
        #[inline]
        fn default() -> GeneralOptions {
            GeneralOptions {
                enable: ::core::default::Default::default(),
                language: ::core::default::Default::default(),
                result_output_mode: ::core::default::Default::default(),
                debug_info: ::core::default::Default::default(),
                max_results: ::core::default::Default::default(),
                show_advanced: ::core::default::Default::default(),
                font_family: ::core::default::Default::default(),
                font_size: ::core::default::Default::default(),
                line_height: ::core::default::Default::default(),
                popup_display_mode: ::core::default::Default::default(),
                popup_width: ::core::default::Default::default(),
                popup_height: ::core::default::Default::default(),
                popup_horizontal_offset: ::core::default::Default::default(),
                popup_vertical_offset: ::core::default::Default::default(),
                popup_horizontal_offset2: ::core::default::Default::default(),
                popup_vertical_offset2: ::core::default::Default::default(),
                popup_horizontal_text_position: ::core::default::Default::default(),
                popup_vertical_text_position: ::core::default::Default::default(),
                popup_scaling_factor: ::core::default::Default::default(),
                popup_scale_relative_to_page_zoom: ::core::default::Default::default(),
                popup_scale_relative_to_visual_viewport: ::core::default::Default::default(),
                show_guide: ::core::default::Default::default(),
                enable_context_menu_scan_selected: ::core::default::Default::default(),
                compact_tags: ::core::default::Default::default(),
                compact_glossaries: ::core::default::Default::default(),
                main_dictionary: ::core::default::Default::default(),
                popup_theme: ::core::default::Default::default(),
                popup_outer_theme: ::core::default::Default::default(),
                custom_popup_css: ::core::default::Default::default(),
                custom_popup_outer_css: ::core::default::Default::default(),
                enable_wanakana: ::core::default::Default::default(),
                show_pitch_accent_downstep_notation: ::core::default::Default::default(),
                show_pitch_accent_position_notation: ::core::default::Default::default(),
                show_pitch_accent_graph: ::core::default::Default::default(),
                show_iframe_popups_in_root_frame: ::core::default::Default::default(),
                use_secure_popup_frame_url: ::core::default::Default::default(),
                use_popup_shadow_dom: ::core::default::Default::default(),
                use_popup_window: ::core::default::Default::default(),
                popup_current_indicator_mode: ::core::default::Default::default(),
                popup_action_bar_visibility: ::core::default::Default::default(),
                popup_action_bar_location: ::core::default::Default::default(),
                frequency_display_mode: ::core::default::Default::default(),
                term_display_mode: ::core::default::Default::default(),
                sort_frequency_dictionary: ::core::default::Default::default(),
                sort_frequency_dictionary_order: ::core::default::Default::default(),
                sticky_search_header: ::core::default::Default::default(),
            }
        }
    }
    pub struct PopupWindowOptions {
        pub width: u8,
        pub height: u8,
        pub left: u8,
        pub top: u8,
        pub use_left: bool,
        pub use_top: bool,
        pub window_type: PopupWindowType,
        pub window_state: PopupWindowState,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for PopupWindowOptions {
        #[inline]
        fn clone(&self) -> PopupWindowOptions {
            PopupWindowOptions {
                width: ::core::clone::Clone::clone(&self.width),
                height: ::core::clone::Clone::clone(&self.height),
                left: ::core::clone::Clone::clone(&self.left),
                top: ::core::clone::Clone::clone(&self.top),
                use_left: ::core::clone::Clone::clone(&self.use_left),
                use_top: ::core::clone::Clone::clone(&self.use_top),
                window_type: ::core::clone::Clone::clone(&self.window_type),
                window_state: ::core::clone::Clone::clone(&self.window_state),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for PopupWindowOptions {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "width",
                "height",
                "left",
                "top",
                "use_left",
                "use_top",
                "window_type",
                "window_state",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.width,
                &self.height,
                &self.left,
                &self.top,
                &self.use_left,
                &self.use_top,
                &self.window_type,
                &&self.window_state,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "PopupWindowOptions",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for PopupWindowOptions {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for PopupWindowOptions {
        #[inline]
        fn eq(&self, other: &PopupWindowOptions) -> bool {
            self.width == other.width && self.height == other.height
                && self.left == other.left && self.top == other.top
                && self.use_left == other.use_left && self.use_top == other.use_top
                && self.window_type == other.window_type
                && self.window_state == other.window_state
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for PopupWindowOptions {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "PopupWindowOptions",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "width",
                    &self.width,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "height",
                    &self.height,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "left",
                    &self.left,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "top",
                    &self.top,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "use_left",
                    &self.use_left,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "use_top",
                    &self.use_top,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "window_type",
                    &self.window_type,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "window_state",
                    &self.window_state,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for PopupWindowOptions {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "width" => _serde::__private::Ok(__Field::__field0),
                            "height" => _serde::__private::Ok(__Field::__field1),
                            "left" => _serde::__private::Ok(__Field::__field2),
                            "top" => _serde::__private::Ok(__Field::__field3),
                            "use_left" => _serde::__private::Ok(__Field::__field4),
                            "use_top" => _serde::__private::Ok(__Field::__field5),
                            "window_type" => _serde::__private::Ok(__Field::__field6),
                            "window_state" => _serde::__private::Ok(__Field::__field7),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"width" => _serde::__private::Ok(__Field::__field0),
                            b"height" => _serde::__private::Ok(__Field::__field1),
                            b"left" => _serde::__private::Ok(__Field::__field2),
                            b"top" => _serde::__private::Ok(__Field::__field3),
                            b"use_left" => _serde::__private::Ok(__Field::__field4),
                            b"use_top" => _serde::__private::Ok(__Field::__field5),
                            b"window_type" => _serde::__private::Ok(__Field::__field6),
                            b"window_state" => _serde::__private::Ok(__Field::__field7),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<PopupWindowOptions>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = PopupWindowOptions;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct PopupWindowOptions",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            u8,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct PopupWindowOptions with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            u8,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct PopupWindowOptions with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            u8,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct PopupWindowOptions with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            u8,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct PopupWindowOptions with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct PopupWindowOptions with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct PopupWindowOptions with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field6 = match _serde::de::SeqAccess::next_element::<
                            PopupWindowType,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        6usize,
                                        &"struct PopupWindowOptions with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field7 = match _serde::de::SeqAccess::next_element::<
                            PopupWindowState,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        7usize,
                                        &"struct PopupWindowOptions with 8 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(PopupWindowOptions {
                            width: __field0,
                            height: __field1,
                            left: __field2,
                            top: __field3,
                            use_left: __field4,
                            use_top: __field5,
                            window_type: __field6,
                            window_state: __field7,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<u8> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<u8> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<u8> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<u8> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field6: _serde::__private::Option<PopupWindowType> = _serde::__private::None;
                        let mut __field7: _serde::__private::Option<PopupWindowState> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("width"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u8>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("height"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u8>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("left"),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u8>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("top"),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u8>(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "use_left",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "use_top",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "window_type",
                                            ),
                                        );
                                    }
                                    __field6 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            PopupWindowType,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field7 => {
                                    if _serde::__private::Option::is_some(&__field7) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "window_state",
                                            ),
                                        );
                                    }
                                    __field7 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            PopupWindowState,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("width")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("height")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("left")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("top")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("use_left")?
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("use_top")?
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("window_type")?
                            }
                        };
                        let __field7 = match __field7 {
                            _serde::__private::Some(__field7) => __field7,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("window_state")?
                            }
                        };
                        _serde::__private::Ok(PopupWindowOptions {
                            width: __field0,
                            height: __field1,
                            left: __field2,
                            top: __field3,
                            use_left: __field4,
                            use_top: __field5,
                            window_type: __field6,
                            window_state: __field7,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "width",
                    "height",
                    "left",
                    "top",
                    "use_left",
                    "use_top",
                    "window_type",
                    "window_state",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "PopupWindowOptions",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<PopupWindowOptions>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for PopupWindowOptions {
        #[inline]
        fn default() -> PopupWindowOptions {
            PopupWindowOptions {
                width: ::core::default::Default::default(),
                height: ::core::default::Default::default(),
                left: ::core::default::Default::default(),
                top: ::core::default::Default::default(),
                use_left: ::core::default::Default::default(),
                use_top: ::core::default::Default::default(),
                window_type: ::core::default::Default::default(),
                window_state: ::core::default::Default::default(),
            }
        }
    }
    pub struct AudioOptions {
        pub enabled: bool,
        pub volume: u8,
        pub auto_play: bool,
        pub sources: Vec<AudioSourceOptions>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for AudioOptions {
        #[inline]
        fn clone(&self) -> AudioOptions {
            AudioOptions {
                enabled: ::core::clone::Clone::clone(&self.enabled),
                volume: ::core::clone::Clone::clone(&self.volume),
                auto_play: ::core::clone::Clone::clone(&self.auto_play),
                sources: ::core::clone::Clone::clone(&self.sources),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for AudioOptions {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "AudioOptions",
                "enabled",
                &self.enabled,
                "volume",
                &self.volume,
                "auto_play",
                &self.auto_play,
                "sources",
                &&self.sources,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for AudioOptions {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for AudioOptions {
        #[inline]
        fn eq(&self, other: &AudioOptions) -> bool {
            self.enabled == other.enabled && self.volume == other.volume
                && self.auto_play == other.auto_play && self.sources == other.sources
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for AudioOptions {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "AudioOptions",
                    false as usize + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "enabled",
                    &self.enabled,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "volume",
                    &self.volume,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "auto_play",
                    &self.auto_play,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "sources",
                    &self.sources,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for AudioOptions {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "enabled" => _serde::__private::Ok(__Field::__field0),
                            "volume" => _serde::__private::Ok(__Field::__field1),
                            "auto_play" => _serde::__private::Ok(__Field::__field2),
                            "sources" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"enabled" => _serde::__private::Ok(__Field::__field0),
                            b"volume" => _serde::__private::Ok(__Field::__field1),
                            b"auto_play" => _serde::__private::Ok(__Field::__field2),
                            b"sources" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<AudioOptions>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = AudioOptions;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct AudioOptions",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct AudioOptions with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            u8,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct AudioOptions with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct AudioOptions with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            Vec<AudioSourceOptions>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct AudioOptions with 4 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(AudioOptions {
                            enabled: __field0,
                            volume: __field1,
                            auto_play: __field2,
                            sources: __field3,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<u8> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<
                            Vec<AudioSourceOptions>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "enabled",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("volume"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u8>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "auto_play",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "sources",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<AudioSourceOptions>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("enabled")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("volume")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("auto_play")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("sources")?
                            }
                        };
                        _serde::__private::Ok(AudioOptions {
                            enabled: __field0,
                            volume: __field1,
                            auto_play: __field2,
                            sources: __field3,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "enabled",
                    "volume",
                    "auto_play",
                    "sources",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "AudioOptions",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<AudioOptions>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for AudioOptions {
        #[inline]
        fn default() -> AudioOptions {
            AudioOptions {
                enabled: ::core::default::Default::default(),
                volume: ::core::default::Default::default(),
                auto_play: ::core::default::Default::default(),
                sources: ::core::default::Default::default(),
            }
        }
    }
    pub struct AudioSourceOptions {
        pub audio_source_type: AudioSourceType,
        pub url: String,
        pub voice: String,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for AudioSourceOptions {
        #[inline]
        fn clone(&self) -> AudioSourceOptions {
            AudioSourceOptions {
                audio_source_type: ::core::clone::Clone::clone(&self.audio_source_type),
                url: ::core::clone::Clone::clone(&self.url),
                voice: ::core::clone::Clone::clone(&self.voice),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for AudioSourceOptions {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "AudioSourceOptions",
                "audio_source_type",
                &self.audio_source_type,
                "url",
                &self.url,
                "voice",
                &&self.voice,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for AudioSourceOptions {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for AudioSourceOptions {
        #[inline]
        fn eq(&self, other: &AudioSourceOptions) -> bool {
            self.audio_source_type == other.audio_source_type && self.url == other.url
                && self.voice == other.voice
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for AudioSourceOptions {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "AudioSourceOptions",
                    false as usize + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "audio_source_type",
                    &self.audio_source_type,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "url",
                    &self.url,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "voice",
                    &self.voice,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for AudioSourceOptions {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "audio_source_type" => {
                                _serde::__private::Ok(__Field::__field0)
                            }
                            "url" => _serde::__private::Ok(__Field::__field1),
                            "voice" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"audio_source_type" => {
                                _serde::__private::Ok(__Field::__field0)
                            }
                            b"url" => _serde::__private::Ok(__Field::__field1),
                            b"voice" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<AudioSourceOptions>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = AudioSourceOptions;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct AudioSourceOptions",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            AudioSourceType,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct AudioSourceOptions with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct AudioSourceOptions with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct AudioSourceOptions with 3 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(AudioSourceOptions {
                            audio_source_type: __field0,
                            url: __field1,
                            voice: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<AudioSourceType> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<String> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "audio_source_type",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            AudioSourceType,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("url"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("voice"),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("audio_source_type")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("url")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("voice")?
                            }
                        };
                        _serde::__private::Ok(AudioSourceOptions {
                            audio_source_type: __field0,
                            url: __field1,
                            voice: __field2,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "audio_source_type",
                    "url",
                    "voice",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "AudioSourceOptions",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<AudioSourceOptions>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for AudioSourceOptions {
        #[inline]
        fn default() -> AudioSourceOptions {
            AudioSourceOptions {
                audio_source_type: ::core::default::Default::default(),
                url: ::core::default::Default::default(),
                voice: ::core::default::Default::default(),
            }
        }
    }
    pub struct ScanningOptions {
        pub inputs: Vec<ScanningInput>,
        pub prevent_middle_mouse: ScanningPreventMiddleMouseOptions,
        pub touch_input_enabled: bool,
        pub pointer_events_enabled: bool,
        pub select_text: bool,
        pub alphanumeric: bool,
        pub auto_hide_results: bool,
        pub delay: u8,
        pub hide_delay: u8,
        pub length: u8,
        pub deep_dom_scan: bool,
        pub popup_nesting_max_depth: u8,
        pub enable_popup_search: bool,
        pub enable_on_popup_expressions: bool,
        pub enable_on_search_page: bool,
        pub enable_search_tags: bool,
        pub layout_aware_scan: bool,
        pub match_type_prefix: bool,
        pub hide_popup_on_cursor_exit: bool,
        pub hide_popup_on_cursor_exit_delay: u8,
        pub normalize_css_zoom: bool,
        pub scan_alt_text: bool,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ScanningOptions {
        #[inline]
        fn clone(&self) -> ScanningOptions {
            ScanningOptions {
                inputs: ::core::clone::Clone::clone(&self.inputs),
                prevent_middle_mouse: ::core::clone::Clone::clone(
                    &self.prevent_middle_mouse,
                ),
                touch_input_enabled: ::core::clone::Clone::clone(
                    &self.touch_input_enabled,
                ),
                pointer_events_enabled: ::core::clone::Clone::clone(
                    &self.pointer_events_enabled,
                ),
                select_text: ::core::clone::Clone::clone(&self.select_text),
                alphanumeric: ::core::clone::Clone::clone(&self.alphanumeric),
                auto_hide_results: ::core::clone::Clone::clone(&self.auto_hide_results),
                delay: ::core::clone::Clone::clone(&self.delay),
                hide_delay: ::core::clone::Clone::clone(&self.hide_delay),
                length: ::core::clone::Clone::clone(&self.length),
                deep_dom_scan: ::core::clone::Clone::clone(&self.deep_dom_scan),
                popup_nesting_max_depth: ::core::clone::Clone::clone(
                    &self.popup_nesting_max_depth,
                ),
                enable_popup_search: ::core::clone::Clone::clone(
                    &self.enable_popup_search,
                ),
                enable_on_popup_expressions: ::core::clone::Clone::clone(
                    &self.enable_on_popup_expressions,
                ),
                enable_on_search_page: ::core::clone::Clone::clone(
                    &self.enable_on_search_page,
                ),
                enable_search_tags: ::core::clone::Clone::clone(
                    &self.enable_search_tags,
                ),
                layout_aware_scan: ::core::clone::Clone::clone(&self.layout_aware_scan),
                match_type_prefix: ::core::clone::Clone::clone(&self.match_type_prefix),
                hide_popup_on_cursor_exit: ::core::clone::Clone::clone(
                    &self.hide_popup_on_cursor_exit,
                ),
                hide_popup_on_cursor_exit_delay: ::core::clone::Clone::clone(
                    &self.hide_popup_on_cursor_exit_delay,
                ),
                normalize_css_zoom: ::core::clone::Clone::clone(
                    &self.normalize_css_zoom,
                ),
                scan_alt_text: ::core::clone::Clone::clone(&self.scan_alt_text),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ScanningOptions {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "inputs",
                "prevent_middle_mouse",
                "touch_input_enabled",
                "pointer_events_enabled",
                "select_text",
                "alphanumeric",
                "auto_hide_results",
                "delay",
                "hide_delay",
                "length",
                "deep_dom_scan",
                "popup_nesting_max_depth",
                "enable_popup_search",
                "enable_on_popup_expressions",
                "enable_on_search_page",
                "enable_search_tags",
                "layout_aware_scan",
                "match_type_prefix",
                "hide_popup_on_cursor_exit",
                "hide_popup_on_cursor_exit_delay",
                "normalize_css_zoom",
                "scan_alt_text",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.inputs,
                &self.prevent_middle_mouse,
                &self.touch_input_enabled,
                &self.pointer_events_enabled,
                &self.select_text,
                &self.alphanumeric,
                &self.auto_hide_results,
                &self.delay,
                &self.hide_delay,
                &self.length,
                &self.deep_dom_scan,
                &self.popup_nesting_max_depth,
                &self.enable_popup_search,
                &self.enable_on_popup_expressions,
                &self.enable_on_search_page,
                &self.enable_search_tags,
                &self.layout_aware_scan,
                &self.match_type_prefix,
                &self.hide_popup_on_cursor_exit,
                &self.hide_popup_on_cursor_exit_delay,
                &self.normalize_css_zoom,
                &&self.scan_alt_text,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "ScanningOptions",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ScanningOptions {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ScanningOptions {
        #[inline]
        fn eq(&self, other: &ScanningOptions) -> bool {
            self.inputs == other.inputs
                && self.prevent_middle_mouse == other.prevent_middle_mouse
                && self.touch_input_enabled == other.touch_input_enabled
                && self.pointer_events_enabled == other.pointer_events_enabled
                && self.select_text == other.select_text
                && self.alphanumeric == other.alphanumeric
                && self.auto_hide_results == other.auto_hide_results
                && self.delay == other.delay && self.hide_delay == other.hide_delay
                && self.length == other.length
                && self.deep_dom_scan == other.deep_dom_scan
                && self.popup_nesting_max_depth == other.popup_nesting_max_depth
                && self.enable_popup_search == other.enable_popup_search
                && self.enable_on_popup_expressions == other.enable_on_popup_expressions
                && self.enable_on_search_page == other.enable_on_search_page
                && self.enable_search_tags == other.enable_search_tags
                && self.layout_aware_scan == other.layout_aware_scan
                && self.match_type_prefix == other.match_type_prefix
                && self.hide_popup_on_cursor_exit == other.hide_popup_on_cursor_exit
                && self.hide_popup_on_cursor_exit_delay
                    == other.hide_popup_on_cursor_exit_delay
                && self.normalize_css_zoom == other.normalize_css_zoom
                && self.scan_alt_text == other.scan_alt_text
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ScanningOptions {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "ScanningOptions",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1
                        + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "inputs",
                    &self.inputs,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "prevent_middle_mouse",
                    &self.prevent_middle_mouse,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "touch_input_enabled",
                    &self.touch_input_enabled,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "pointer_events_enabled",
                    &self.pointer_events_enabled,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "select_text",
                    &self.select_text,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "alphanumeric",
                    &self.alphanumeric,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "auto_hide_results",
                    &self.auto_hide_results,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "delay",
                    &self.delay,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "hide_delay",
                    &self.hide_delay,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "length",
                    &self.length,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "deep_dom_scan",
                    &self.deep_dom_scan,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "popup_nesting_max_depth",
                    &self.popup_nesting_max_depth,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "enable_popup_search",
                    &self.enable_popup_search,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "enable_on_popup_expressions",
                    &self.enable_on_popup_expressions,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "enable_on_search_page",
                    &self.enable_on_search_page,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "enable_search_tags",
                    &self.enable_search_tags,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "layout_aware_scan",
                    &self.layout_aware_scan,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "match_type_prefix",
                    &self.match_type_prefix,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "hide_popup_on_cursor_exit",
                    &self.hide_popup_on_cursor_exit,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "hide_popup_on_cursor_exit_delay",
                    &self.hide_popup_on_cursor_exit_delay,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "normalize_css_zoom",
                    &self.normalize_css_zoom,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "scan_alt_text",
                    &self.scan_alt_text,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ScanningOptions {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __field8,
                    __field9,
                    __field10,
                    __field11,
                    __field12,
                    __field13,
                    __field14,
                    __field15,
                    __field16,
                    __field17,
                    __field18,
                    __field19,
                    __field20,
                    __field21,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            8u64 => _serde::__private::Ok(__Field::__field8),
                            9u64 => _serde::__private::Ok(__Field::__field9),
                            10u64 => _serde::__private::Ok(__Field::__field10),
                            11u64 => _serde::__private::Ok(__Field::__field11),
                            12u64 => _serde::__private::Ok(__Field::__field12),
                            13u64 => _serde::__private::Ok(__Field::__field13),
                            14u64 => _serde::__private::Ok(__Field::__field14),
                            15u64 => _serde::__private::Ok(__Field::__field15),
                            16u64 => _serde::__private::Ok(__Field::__field16),
                            17u64 => _serde::__private::Ok(__Field::__field17),
                            18u64 => _serde::__private::Ok(__Field::__field18),
                            19u64 => _serde::__private::Ok(__Field::__field19),
                            20u64 => _serde::__private::Ok(__Field::__field20),
                            21u64 => _serde::__private::Ok(__Field::__field21),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "inputs" => _serde::__private::Ok(__Field::__field0),
                            "prevent_middle_mouse" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            "touch_input_enabled" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            "pointer_events_enabled" => {
                                _serde::__private::Ok(__Field::__field3)
                            }
                            "select_text" => _serde::__private::Ok(__Field::__field4),
                            "alphanumeric" => _serde::__private::Ok(__Field::__field5),
                            "auto_hide_results" => {
                                _serde::__private::Ok(__Field::__field6)
                            }
                            "delay" => _serde::__private::Ok(__Field::__field7),
                            "hide_delay" => _serde::__private::Ok(__Field::__field8),
                            "length" => _serde::__private::Ok(__Field::__field9),
                            "deep_dom_scan" => _serde::__private::Ok(__Field::__field10),
                            "popup_nesting_max_depth" => {
                                _serde::__private::Ok(__Field::__field11)
                            }
                            "enable_popup_search" => {
                                _serde::__private::Ok(__Field::__field12)
                            }
                            "enable_on_popup_expressions" => {
                                _serde::__private::Ok(__Field::__field13)
                            }
                            "enable_on_search_page" => {
                                _serde::__private::Ok(__Field::__field14)
                            }
                            "enable_search_tags" => {
                                _serde::__private::Ok(__Field::__field15)
                            }
                            "layout_aware_scan" => {
                                _serde::__private::Ok(__Field::__field16)
                            }
                            "match_type_prefix" => {
                                _serde::__private::Ok(__Field::__field17)
                            }
                            "hide_popup_on_cursor_exit" => {
                                _serde::__private::Ok(__Field::__field18)
                            }
                            "hide_popup_on_cursor_exit_delay" => {
                                _serde::__private::Ok(__Field::__field19)
                            }
                            "normalize_css_zoom" => {
                                _serde::__private::Ok(__Field::__field20)
                            }
                            "scan_alt_text" => _serde::__private::Ok(__Field::__field21),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"inputs" => _serde::__private::Ok(__Field::__field0),
                            b"prevent_middle_mouse" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            b"touch_input_enabled" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            b"pointer_events_enabled" => {
                                _serde::__private::Ok(__Field::__field3)
                            }
                            b"select_text" => _serde::__private::Ok(__Field::__field4),
                            b"alphanumeric" => _serde::__private::Ok(__Field::__field5),
                            b"auto_hide_results" => {
                                _serde::__private::Ok(__Field::__field6)
                            }
                            b"delay" => _serde::__private::Ok(__Field::__field7),
                            b"hide_delay" => _serde::__private::Ok(__Field::__field8),
                            b"length" => _serde::__private::Ok(__Field::__field9),
                            b"deep_dom_scan" => _serde::__private::Ok(__Field::__field10),
                            b"popup_nesting_max_depth" => {
                                _serde::__private::Ok(__Field::__field11)
                            }
                            b"enable_popup_search" => {
                                _serde::__private::Ok(__Field::__field12)
                            }
                            b"enable_on_popup_expressions" => {
                                _serde::__private::Ok(__Field::__field13)
                            }
                            b"enable_on_search_page" => {
                                _serde::__private::Ok(__Field::__field14)
                            }
                            b"enable_search_tags" => {
                                _serde::__private::Ok(__Field::__field15)
                            }
                            b"layout_aware_scan" => {
                                _serde::__private::Ok(__Field::__field16)
                            }
                            b"match_type_prefix" => {
                                _serde::__private::Ok(__Field::__field17)
                            }
                            b"hide_popup_on_cursor_exit" => {
                                _serde::__private::Ok(__Field::__field18)
                            }
                            b"hide_popup_on_cursor_exit_delay" => {
                                _serde::__private::Ok(__Field::__field19)
                            }
                            b"normalize_css_zoom" => {
                                _serde::__private::Ok(__Field::__field20)
                            }
                            b"scan_alt_text" => _serde::__private::Ok(__Field::__field21),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ScanningOptions>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ScanningOptions;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct ScanningOptions",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            Vec<ScanningInput>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct ScanningOptions with 22 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            ScanningPreventMiddleMouseOptions,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct ScanningOptions with 22 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct ScanningOptions with 22 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct ScanningOptions with 22 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct ScanningOptions with 22 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct ScanningOptions with 22 elements",
                                    ),
                                );
                            }
                        };
                        let __field6 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        6usize,
                                        &"struct ScanningOptions with 22 elements",
                                    ),
                                );
                            }
                        };
                        let __field7 = match _serde::de::SeqAccess::next_element::<
                            u8,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        7usize,
                                        &"struct ScanningOptions with 22 elements",
                                    ),
                                );
                            }
                        };
                        let __field8 = match _serde::de::SeqAccess::next_element::<
                            u8,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        8usize,
                                        &"struct ScanningOptions with 22 elements",
                                    ),
                                );
                            }
                        };
                        let __field9 = match _serde::de::SeqAccess::next_element::<
                            u8,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        9usize,
                                        &"struct ScanningOptions with 22 elements",
                                    ),
                                );
                            }
                        };
                        let __field10 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        10usize,
                                        &"struct ScanningOptions with 22 elements",
                                    ),
                                );
                            }
                        };
                        let __field11 = match _serde::de::SeqAccess::next_element::<
                            u8,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        11usize,
                                        &"struct ScanningOptions with 22 elements",
                                    ),
                                );
                            }
                        };
                        let __field12 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        12usize,
                                        &"struct ScanningOptions with 22 elements",
                                    ),
                                );
                            }
                        };
                        let __field13 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        13usize,
                                        &"struct ScanningOptions with 22 elements",
                                    ),
                                );
                            }
                        };
                        let __field14 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        14usize,
                                        &"struct ScanningOptions with 22 elements",
                                    ),
                                );
                            }
                        };
                        let __field15 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        15usize,
                                        &"struct ScanningOptions with 22 elements",
                                    ),
                                );
                            }
                        };
                        let __field16 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        16usize,
                                        &"struct ScanningOptions with 22 elements",
                                    ),
                                );
                            }
                        };
                        let __field17 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        17usize,
                                        &"struct ScanningOptions with 22 elements",
                                    ),
                                );
                            }
                        };
                        let __field18 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        18usize,
                                        &"struct ScanningOptions with 22 elements",
                                    ),
                                );
                            }
                        };
                        let __field19 = match _serde::de::SeqAccess::next_element::<
                            u8,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        19usize,
                                        &"struct ScanningOptions with 22 elements",
                                    ),
                                );
                            }
                        };
                        let __field20 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        20usize,
                                        &"struct ScanningOptions with 22 elements",
                                    ),
                                );
                            }
                        };
                        let __field21 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        21usize,
                                        &"struct ScanningOptions with 22 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(ScanningOptions {
                            inputs: __field0,
                            prevent_middle_mouse: __field1,
                            touch_input_enabled: __field2,
                            pointer_events_enabled: __field3,
                            select_text: __field4,
                            alphanumeric: __field5,
                            auto_hide_results: __field6,
                            delay: __field7,
                            hide_delay: __field8,
                            length: __field9,
                            deep_dom_scan: __field10,
                            popup_nesting_max_depth: __field11,
                            enable_popup_search: __field12,
                            enable_on_popup_expressions: __field13,
                            enable_on_search_page: __field14,
                            enable_search_tags: __field15,
                            layout_aware_scan: __field16,
                            match_type_prefix: __field17,
                            hide_popup_on_cursor_exit: __field18,
                            hide_popup_on_cursor_exit_delay: __field19,
                            normalize_css_zoom: __field20,
                            scan_alt_text: __field21,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            Vec<ScanningInput>,
                        > = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            ScanningPreventMiddleMouseOptions,
                        > = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field6: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field7: _serde::__private::Option<u8> = _serde::__private::None;
                        let mut __field8: _serde::__private::Option<u8> = _serde::__private::None;
                        let mut __field9: _serde::__private::Option<u8> = _serde::__private::None;
                        let mut __field10: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field11: _serde::__private::Option<u8> = _serde::__private::None;
                        let mut __field12: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field13: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field14: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field15: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field16: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field17: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field18: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field19: _serde::__private::Option<u8> = _serde::__private::None;
                        let mut __field20: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field21: _serde::__private::Option<bool> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("inputs"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<ScanningInput>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "prevent_middle_mouse",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ScanningPreventMiddleMouseOptions,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "touch_input_enabled",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "pointer_events_enabled",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "select_text",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "alphanumeric",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "auto_hide_results",
                                            ),
                                        );
                                    }
                                    __field6 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field7 => {
                                    if _serde::__private::Option::is_some(&__field7) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("delay"),
                                        );
                                    }
                                    __field7 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u8>(&mut __map)?,
                                    );
                                }
                                __Field::__field8 => {
                                    if _serde::__private::Option::is_some(&__field8) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "hide_delay",
                                            ),
                                        );
                                    }
                                    __field8 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u8>(&mut __map)?,
                                    );
                                }
                                __Field::__field9 => {
                                    if _serde::__private::Option::is_some(&__field9) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("length"),
                                        );
                                    }
                                    __field9 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u8>(&mut __map)?,
                                    );
                                }
                                __Field::__field10 => {
                                    if _serde::__private::Option::is_some(&__field10) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "deep_dom_scan",
                                            ),
                                        );
                                    }
                                    __field10 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field11 => {
                                    if _serde::__private::Option::is_some(&__field11) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "popup_nesting_max_depth",
                                            ),
                                        );
                                    }
                                    __field11 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u8>(&mut __map)?,
                                    );
                                }
                                __Field::__field12 => {
                                    if _serde::__private::Option::is_some(&__field12) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "enable_popup_search",
                                            ),
                                        );
                                    }
                                    __field12 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field13 => {
                                    if _serde::__private::Option::is_some(&__field13) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "enable_on_popup_expressions",
                                            ),
                                        );
                                    }
                                    __field13 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field14 => {
                                    if _serde::__private::Option::is_some(&__field14) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "enable_on_search_page",
                                            ),
                                        );
                                    }
                                    __field14 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field15 => {
                                    if _serde::__private::Option::is_some(&__field15) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "enable_search_tags",
                                            ),
                                        );
                                    }
                                    __field15 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field16 => {
                                    if _serde::__private::Option::is_some(&__field16) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "layout_aware_scan",
                                            ),
                                        );
                                    }
                                    __field16 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field17 => {
                                    if _serde::__private::Option::is_some(&__field17) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "match_type_prefix",
                                            ),
                                        );
                                    }
                                    __field17 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field18 => {
                                    if _serde::__private::Option::is_some(&__field18) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "hide_popup_on_cursor_exit",
                                            ),
                                        );
                                    }
                                    __field18 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field19 => {
                                    if _serde::__private::Option::is_some(&__field19) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "hide_popup_on_cursor_exit_delay",
                                            ),
                                        );
                                    }
                                    __field19 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u8>(&mut __map)?,
                                    );
                                }
                                __Field::__field20 => {
                                    if _serde::__private::Option::is_some(&__field20) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "normalize_css_zoom",
                                            ),
                                        );
                                    }
                                    __field20 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field21 => {
                                    if _serde::__private::Option::is_some(&__field21) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "scan_alt_text",
                                            ),
                                        );
                                    }
                                    __field21 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("inputs")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "prevent_middle_mouse",
                                )?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("touch_input_enabled")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "pointer_events_enabled",
                                )?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("select_text")?
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("alphanumeric")?
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("auto_hide_results")?
                            }
                        };
                        let __field7 = match __field7 {
                            _serde::__private::Some(__field7) => __field7,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("delay")?
                            }
                        };
                        let __field8 = match __field8 {
                            _serde::__private::Some(__field8) => __field8,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("hide_delay")?
                            }
                        };
                        let __field9 = match __field9 {
                            _serde::__private::Some(__field9) => __field9,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("length")?
                            }
                        };
                        let __field10 = match __field10 {
                            _serde::__private::Some(__field10) => __field10,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("deep_dom_scan")?
                            }
                        };
                        let __field11 = match __field11 {
                            _serde::__private::Some(__field11) => __field11,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "popup_nesting_max_depth",
                                )?
                            }
                        };
                        let __field12 = match __field12 {
                            _serde::__private::Some(__field12) => __field12,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("enable_popup_search")?
                            }
                        };
                        let __field13 = match __field13 {
                            _serde::__private::Some(__field13) => __field13,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "enable_on_popup_expressions",
                                )?
                            }
                        };
                        let __field14 = match __field14 {
                            _serde::__private::Some(__field14) => __field14,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "enable_on_search_page",
                                )?
                            }
                        };
                        let __field15 = match __field15 {
                            _serde::__private::Some(__field15) => __field15,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("enable_search_tags")?
                            }
                        };
                        let __field16 = match __field16 {
                            _serde::__private::Some(__field16) => __field16,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("layout_aware_scan")?
                            }
                        };
                        let __field17 = match __field17 {
                            _serde::__private::Some(__field17) => __field17,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("match_type_prefix")?
                            }
                        };
                        let __field18 = match __field18 {
                            _serde::__private::Some(__field18) => __field18,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "hide_popup_on_cursor_exit",
                                )?
                            }
                        };
                        let __field19 = match __field19 {
                            _serde::__private::Some(__field19) => __field19,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "hide_popup_on_cursor_exit_delay",
                                )?
                            }
                        };
                        let __field20 = match __field20 {
                            _serde::__private::Some(__field20) => __field20,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("normalize_css_zoom")?
                            }
                        };
                        let __field21 = match __field21 {
                            _serde::__private::Some(__field21) => __field21,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("scan_alt_text")?
                            }
                        };
                        _serde::__private::Ok(ScanningOptions {
                            inputs: __field0,
                            prevent_middle_mouse: __field1,
                            touch_input_enabled: __field2,
                            pointer_events_enabled: __field3,
                            select_text: __field4,
                            alphanumeric: __field5,
                            auto_hide_results: __field6,
                            delay: __field7,
                            hide_delay: __field8,
                            length: __field9,
                            deep_dom_scan: __field10,
                            popup_nesting_max_depth: __field11,
                            enable_popup_search: __field12,
                            enable_on_popup_expressions: __field13,
                            enable_on_search_page: __field14,
                            enable_search_tags: __field15,
                            layout_aware_scan: __field16,
                            match_type_prefix: __field17,
                            hide_popup_on_cursor_exit: __field18,
                            hide_popup_on_cursor_exit_delay: __field19,
                            normalize_css_zoom: __field20,
                            scan_alt_text: __field21,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "inputs",
                    "prevent_middle_mouse",
                    "touch_input_enabled",
                    "pointer_events_enabled",
                    "select_text",
                    "alphanumeric",
                    "auto_hide_results",
                    "delay",
                    "hide_delay",
                    "length",
                    "deep_dom_scan",
                    "popup_nesting_max_depth",
                    "enable_popup_search",
                    "enable_on_popup_expressions",
                    "enable_on_search_page",
                    "enable_search_tags",
                    "layout_aware_scan",
                    "match_type_prefix",
                    "hide_popup_on_cursor_exit",
                    "hide_popup_on_cursor_exit_delay",
                    "normalize_css_zoom",
                    "scan_alt_text",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ScanningOptions",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ScanningOptions>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for ScanningOptions {
        #[inline]
        fn default() -> ScanningOptions {
            ScanningOptions {
                inputs: ::core::default::Default::default(),
                prevent_middle_mouse: ::core::default::Default::default(),
                touch_input_enabled: ::core::default::Default::default(),
                pointer_events_enabled: ::core::default::Default::default(),
                select_text: ::core::default::Default::default(),
                alphanumeric: ::core::default::Default::default(),
                auto_hide_results: ::core::default::Default::default(),
                delay: ::core::default::Default::default(),
                hide_delay: ::core::default::Default::default(),
                length: ::core::default::Default::default(),
                deep_dom_scan: ::core::default::Default::default(),
                popup_nesting_max_depth: ::core::default::Default::default(),
                enable_popup_search: ::core::default::Default::default(),
                enable_on_popup_expressions: ::core::default::Default::default(),
                enable_on_search_page: ::core::default::Default::default(),
                enable_search_tags: ::core::default::Default::default(),
                layout_aware_scan: ::core::default::Default::default(),
                match_type_prefix: ::core::default::Default::default(),
                hide_popup_on_cursor_exit: ::core::default::Default::default(),
                hide_popup_on_cursor_exit_delay: ::core::default::Default::default(),
                normalize_css_zoom: ::core::default::Default::default(),
                scan_alt_text: ::core::default::Default::default(),
            }
        }
    }
    pub struct ScanningInput {
        pub include: String,
        pub exclude: String,
        pub types: ScanningInputTypes,
        pub options: ScanningInputOptions,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ScanningInput {
        #[inline]
        fn clone(&self) -> ScanningInput {
            ScanningInput {
                include: ::core::clone::Clone::clone(&self.include),
                exclude: ::core::clone::Clone::clone(&self.exclude),
                types: ::core::clone::Clone::clone(&self.types),
                options: ::core::clone::Clone::clone(&self.options),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ScanningInput {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "ScanningInput",
                "include",
                &self.include,
                "exclude",
                &self.exclude,
                "types",
                &self.types,
                "options",
                &&self.options,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ScanningInput {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ScanningInput {
        #[inline]
        fn eq(&self, other: &ScanningInput) -> bool {
            self.include == other.include && self.exclude == other.exclude
                && self.types == other.types && self.options == other.options
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ScanningInput {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "ScanningInput",
                    false as usize + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "include",
                    &self.include,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "exclude",
                    &self.exclude,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "types",
                    &self.types,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "options",
                    &self.options,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ScanningInput {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "include" => _serde::__private::Ok(__Field::__field0),
                            "exclude" => _serde::__private::Ok(__Field::__field1),
                            "types" => _serde::__private::Ok(__Field::__field2),
                            "options" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"include" => _serde::__private::Ok(__Field::__field0),
                            b"exclude" => _serde::__private::Ok(__Field::__field1),
                            b"types" => _serde::__private::Ok(__Field::__field2),
                            b"options" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ScanningInput>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ScanningInput;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct ScanningInput",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct ScanningInput with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct ScanningInput with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            ScanningInputTypes,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct ScanningInput with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            ScanningInputOptions,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct ScanningInput with 4 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(ScanningInput {
                            include: __field0,
                            exclude: __field1,
                            types: __field2,
                            options: __field3,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<
                            ScanningInputTypes,
                        > = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<
                            ScanningInputOptions,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "include",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "exclude",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("types"),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ScanningInputTypes,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "options",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ScanningInputOptions,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("include")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("exclude")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("types")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("options")?
                            }
                        };
                        _serde::__private::Ok(ScanningInput {
                            include: __field0,
                            exclude: __field1,
                            types: __field2,
                            options: __field3,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "include",
                    "exclude",
                    "types",
                    "options",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ScanningInput",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ScanningInput>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for ScanningInput {
        #[inline]
        fn default() -> ScanningInput {
            ScanningInput {
                include: ::core::default::Default::default(),
                exclude: ::core::default::Default::default(),
                types: ::core::default::Default::default(),
                options: ::core::default::Default::default(),
            }
        }
    }
    pub struct ScanningInputTypes {
        pub mouse: bool,
        pub touch: bool,
        pub pen: bool,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ScanningInputTypes {
        #[inline]
        fn clone(&self) -> ScanningInputTypes {
            ScanningInputTypes {
                mouse: ::core::clone::Clone::clone(&self.mouse),
                touch: ::core::clone::Clone::clone(&self.touch),
                pen: ::core::clone::Clone::clone(&self.pen),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ScanningInputTypes {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "ScanningInputTypes",
                "mouse",
                &self.mouse,
                "touch",
                &self.touch,
                "pen",
                &&self.pen,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ScanningInputTypes {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ScanningInputTypes {
        #[inline]
        fn eq(&self, other: &ScanningInputTypes) -> bool {
            self.mouse == other.mouse && self.touch == other.touch
                && self.pen == other.pen
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ScanningInputTypes {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "ScanningInputTypes",
                    false as usize + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "mouse",
                    &self.mouse,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "touch",
                    &self.touch,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "pen",
                    &self.pen,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ScanningInputTypes {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "mouse" => _serde::__private::Ok(__Field::__field0),
                            "touch" => _serde::__private::Ok(__Field::__field1),
                            "pen" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"mouse" => _serde::__private::Ok(__Field::__field0),
                            b"touch" => _serde::__private::Ok(__Field::__field1),
                            b"pen" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ScanningInputTypes>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ScanningInputTypes;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct ScanningInputTypes",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct ScanningInputTypes with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct ScanningInputTypes with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct ScanningInputTypes with 3 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(ScanningInputTypes {
                            mouse: __field0,
                            touch: __field1,
                            pen: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<bool> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("mouse"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("touch"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("pen"),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("mouse")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("touch")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("pen")?
                            }
                        };
                        _serde::__private::Ok(ScanningInputTypes {
                            mouse: __field0,
                            touch: __field1,
                            pen: __field2,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["mouse", "touch", "pen"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ScanningInputTypes",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ScanningInputTypes>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for ScanningInputTypes {
        #[inline]
        fn default() -> ScanningInputTypes {
            ScanningInputTypes {
                mouse: ::core::default::Default::default(),
                touch: ::core::default::Default::default(),
                pen: ::core::default::Default::default(),
            }
        }
    }
    pub struct ScanningInputOptions {
        pub show_advanced: bool,
        pub search_terms: bool,
        pub search_kanji: bool,
        pub scan_on_touch_move: bool,
        pub scan_on_touch_press: bool,
        pub scan_on_touch_release: bool,
        pub scan_on_touch_tap: bool,
        pub scan_on_pen_move: bool,
        pub scan_on_pen_hover: bool,
        pub scan_on_pen_release_hover: bool,
        pub scan_on_pen_press: bool,
        pub scan_on_pen_release: bool,
        pub prevent_touch_scrolling: bool,
        pub prevent_pen_scrolling: bool,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ScanningInputOptions {
        #[inline]
        fn clone(&self) -> ScanningInputOptions {
            ScanningInputOptions {
                show_advanced: ::core::clone::Clone::clone(&self.show_advanced),
                search_terms: ::core::clone::Clone::clone(&self.search_terms),
                search_kanji: ::core::clone::Clone::clone(&self.search_kanji),
                scan_on_touch_move: ::core::clone::Clone::clone(
                    &self.scan_on_touch_move,
                ),
                scan_on_touch_press: ::core::clone::Clone::clone(
                    &self.scan_on_touch_press,
                ),
                scan_on_touch_release: ::core::clone::Clone::clone(
                    &self.scan_on_touch_release,
                ),
                scan_on_touch_tap: ::core::clone::Clone::clone(&self.scan_on_touch_tap),
                scan_on_pen_move: ::core::clone::Clone::clone(&self.scan_on_pen_move),
                scan_on_pen_hover: ::core::clone::Clone::clone(&self.scan_on_pen_hover),
                scan_on_pen_release_hover: ::core::clone::Clone::clone(
                    &self.scan_on_pen_release_hover,
                ),
                scan_on_pen_press: ::core::clone::Clone::clone(&self.scan_on_pen_press),
                scan_on_pen_release: ::core::clone::Clone::clone(
                    &self.scan_on_pen_release,
                ),
                prevent_touch_scrolling: ::core::clone::Clone::clone(
                    &self.prevent_touch_scrolling,
                ),
                prevent_pen_scrolling: ::core::clone::Clone::clone(
                    &self.prevent_pen_scrolling,
                ),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ScanningInputOptions {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "show_advanced",
                "search_terms",
                "search_kanji",
                "scan_on_touch_move",
                "scan_on_touch_press",
                "scan_on_touch_release",
                "scan_on_touch_tap",
                "scan_on_pen_move",
                "scan_on_pen_hover",
                "scan_on_pen_release_hover",
                "scan_on_pen_press",
                "scan_on_pen_release",
                "prevent_touch_scrolling",
                "prevent_pen_scrolling",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.show_advanced,
                &self.search_terms,
                &self.search_kanji,
                &self.scan_on_touch_move,
                &self.scan_on_touch_press,
                &self.scan_on_touch_release,
                &self.scan_on_touch_tap,
                &self.scan_on_pen_move,
                &self.scan_on_pen_hover,
                &self.scan_on_pen_release_hover,
                &self.scan_on_pen_press,
                &self.scan_on_pen_release,
                &self.prevent_touch_scrolling,
                &&self.prevent_pen_scrolling,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "ScanningInputOptions",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ScanningInputOptions {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ScanningInputOptions {
        #[inline]
        fn eq(&self, other: &ScanningInputOptions) -> bool {
            self.show_advanced == other.show_advanced
                && self.search_terms == other.search_terms
                && self.search_kanji == other.search_kanji
                && self.scan_on_touch_move == other.scan_on_touch_move
                && self.scan_on_touch_press == other.scan_on_touch_press
                && self.scan_on_touch_release == other.scan_on_touch_release
                && self.scan_on_touch_tap == other.scan_on_touch_tap
                && self.scan_on_pen_move == other.scan_on_pen_move
                && self.scan_on_pen_hover == other.scan_on_pen_hover
                && self.scan_on_pen_release_hover == other.scan_on_pen_release_hover
                && self.scan_on_pen_press == other.scan_on_pen_press
                && self.scan_on_pen_release == other.scan_on_pen_release
                && self.prevent_touch_scrolling == other.prevent_touch_scrolling
                && self.prevent_pen_scrolling == other.prevent_pen_scrolling
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ScanningInputOptions {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "ScanningInputOptions",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1
                        + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "show_advanced",
                    &self.show_advanced,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "search_terms",
                    &self.search_terms,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "search_kanji",
                    &self.search_kanji,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "scan_on_touch_move",
                    &self.scan_on_touch_move,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "scan_on_touch_press",
                    &self.scan_on_touch_press,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "scan_on_touch_release",
                    &self.scan_on_touch_release,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "scan_on_touch_tap",
                    &self.scan_on_touch_tap,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "scan_on_pen_move",
                    &self.scan_on_pen_move,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "scan_on_pen_hover",
                    &self.scan_on_pen_hover,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "scan_on_pen_release_hover",
                    &self.scan_on_pen_release_hover,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "scan_on_pen_press",
                    &self.scan_on_pen_press,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "scan_on_pen_release",
                    &self.scan_on_pen_release,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "prevent_touch_scrolling",
                    &self.prevent_touch_scrolling,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "prevent_pen_scrolling",
                    &self.prevent_pen_scrolling,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ScanningInputOptions {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __field8,
                    __field9,
                    __field10,
                    __field11,
                    __field12,
                    __field13,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            8u64 => _serde::__private::Ok(__Field::__field8),
                            9u64 => _serde::__private::Ok(__Field::__field9),
                            10u64 => _serde::__private::Ok(__Field::__field10),
                            11u64 => _serde::__private::Ok(__Field::__field11),
                            12u64 => _serde::__private::Ok(__Field::__field12),
                            13u64 => _serde::__private::Ok(__Field::__field13),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "show_advanced" => _serde::__private::Ok(__Field::__field0),
                            "search_terms" => _serde::__private::Ok(__Field::__field1),
                            "search_kanji" => _serde::__private::Ok(__Field::__field2),
                            "scan_on_touch_move" => {
                                _serde::__private::Ok(__Field::__field3)
                            }
                            "scan_on_touch_press" => {
                                _serde::__private::Ok(__Field::__field4)
                            }
                            "scan_on_touch_release" => {
                                _serde::__private::Ok(__Field::__field5)
                            }
                            "scan_on_touch_tap" => {
                                _serde::__private::Ok(__Field::__field6)
                            }
                            "scan_on_pen_move" => {
                                _serde::__private::Ok(__Field::__field7)
                            }
                            "scan_on_pen_hover" => {
                                _serde::__private::Ok(__Field::__field8)
                            }
                            "scan_on_pen_release_hover" => {
                                _serde::__private::Ok(__Field::__field9)
                            }
                            "scan_on_pen_press" => {
                                _serde::__private::Ok(__Field::__field10)
                            }
                            "scan_on_pen_release" => {
                                _serde::__private::Ok(__Field::__field11)
                            }
                            "prevent_touch_scrolling" => {
                                _serde::__private::Ok(__Field::__field12)
                            }
                            "prevent_pen_scrolling" => {
                                _serde::__private::Ok(__Field::__field13)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"show_advanced" => _serde::__private::Ok(__Field::__field0),
                            b"search_terms" => _serde::__private::Ok(__Field::__field1),
                            b"search_kanji" => _serde::__private::Ok(__Field::__field2),
                            b"scan_on_touch_move" => {
                                _serde::__private::Ok(__Field::__field3)
                            }
                            b"scan_on_touch_press" => {
                                _serde::__private::Ok(__Field::__field4)
                            }
                            b"scan_on_touch_release" => {
                                _serde::__private::Ok(__Field::__field5)
                            }
                            b"scan_on_touch_tap" => {
                                _serde::__private::Ok(__Field::__field6)
                            }
                            b"scan_on_pen_move" => {
                                _serde::__private::Ok(__Field::__field7)
                            }
                            b"scan_on_pen_hover" => {
                                _serde::__private::Ok(__Field::__field8)
                            }
                            b"scan_on_pen_release_hover" => {
                                _serde::__private::Ok(__Field::__field9)
                            }
                            b"scan_on_pen_press" => {
                                _serde::__private::Ok(__Field::__field10)
                            }
                            b"scan_on_pen_release" => {
                                _serde::__private::Ok(__Field::__field11)
                            }
                            b"prevent_touch_scrolling" => {
                                _serde::__private::Ok(__Field::__field12)
                            }
                            b"prevent_pen_scrolling" => {
                                _serde::__private::Ok(__Field::__field13)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ScanningInputOptions>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ScanningInputOptions;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct ScanningInputOptions",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct ScanningInputOptions with 14 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct ScanningInputOptions with 14 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct ScanningInputOptions with 14 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct ScanningInputOptions with 14 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct ScanningInputOptions with 14 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct ScanningInputOptions with 14 elements",
                                    ),
                                );
                            }
                        };
                        let __field6 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        6usize,
                                        &"struct ScanningInputOptions with 14 elements",
                                    ),
                                );
                            }
                        };
                        let __field7 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        7usize,
                                        &"struct ScanningInputOptions with 14 elements",
                                    ),
                                );
                            }
                        };
                        let __field8 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        8usize,
                                        &"struct ScanningInputOptions with 14 elements",
                                    ),
                                );
                            }
                        };
                        let __field9 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        9usize,
                                        &"struct ScanningInputOptions with 14 elements",
                                    ),
                                );
                            }
                        };
                        let __field10 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        10usize,
                                        &"struct ScanningInputOptions with 14 elements",
                                    ),
                                );
                            }
                        };
                        let __field11 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        11usize,
                                        &"struct ScanningInputOptions with 14 elements",
                                    ),
                                );
                            }
                        };
                        let __field12 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        12usize,
                                        &"struct ScanningInputOptions with 14 elements",
                                    ),
                                );
                            }
                        };
                        let __field13 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        13usize,
                                        &"struct ScanningInputOptions with 14 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(ScanningInputOptions {
                            show_advanced: __field0,
                            search_terms: __field1,
                            search_kanji: __field2,
                            scan_on_touch_move: __field3,
                            scan_on_touch_press: __field4,
                            scan_on_touch_release: __field5,
                            scan_on_touch_tap: __field6,
                            scan_on_pen_move: __field7,
                            scan_on_pen_hover: __field8,
                            scan_on_pen_release_hover: __field9,
                            scan_on_pen_press: __field10,
                            scan_on_pen_release: __field11,
                            prevent_touch_scrolling: __field12,
                            prevent_pen_scrolling: __field13,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field6: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field7: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field8: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field9: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field10: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field11: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field12: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field13: _serde::__private::Option<bool> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "show_advanced",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "search_terms",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "search_kanji",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "scan_on_touch_move",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "scan_on_touch_press",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "scan_on_touch_release",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "scan_on_touch_tap",
                                            ),
                                        );
                                    }
                                    __field6 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field7 => {
                                    if _serde::__private::Option::is_some(&__field7) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "scan_on_pen_move",
                                            ),
                                        );
                                    }
                                    __field7 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field8 => {
                                    if _serde::__private::Option::is_some(&__field8) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "scan_on_pen_hover",
                                            ),
                                        );
                                    }
                                    __field8 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field9 => {
                                    if _serde::__private::Option::is_some(&__field9) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "scan_on_pen_release_hover",
                                            ),
                                        );
                                    }
                                    __field9 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field10 => {
                                    if _serde::__private::Option::is_some(&__field10) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "scan_on_pen_press",
                                            ),
                                        );
                                    }
                                    __field10 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field11 => {
                                    if _serde::__private::Option::is_some(&__field11) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "scan_on_pen_release",
                                            ),
                                        );
                                    }
                                    __field11 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field12 => {
                                    if _serde::__private::Option::is_some(&__field12) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "prevent_touch_scrolling",
                                            ),
                                        );
                                    }
                                    __field12 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field13 => {
                                    if _serde::__private::Option::is_some(&__field13) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "prevent_pen_scrolling",
                                            ),
                                        );
                                    }
                                    __field13 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("show_advanced")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("search_terms")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("search_kanji")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("scan_on_touch_move")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("scan_on_touch_press")?
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "scan_on_touch_release",
                                )?
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("scan_on_touch_tap")?
                            }
                        };
                        let __field7 = match __field7 {
                            _serde::__private::Some(__field7) => __field7,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("scan_on_pen_move")?
                            }
                        };
                        let __field8 = match __field8 {
                            _serde::__private::Some(__field8) => __field8,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("scan_on_pen_hover")?
                            }
                        };
                        let __field9 = match __field9 {
                            _serde::__private::Some(__field9) => __field9,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "scan_on_pen_release_hover",
                                )?
                            }
                        };
                        let __field10 = match __field10 {
                            _serde::__private::Some(__field10) => __field10,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("scan_on_pen_press")?
                            }
                        };
                        let __field11 = match __field11 {
                            _serde::__private::Some(__field11) => __field11,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("scan_on_pen_release")?
                            }
                        };
                        let __field12 = match __field12 {
                            _serde::__private::Some(__field12) => __field12,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "prevent_touch_scrolling",
                                )?
                            }
                        };
                        let __field13 = match __field13 {
                            _serde::__private::Some(__field13) => __field13,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "prevent_pen_scrolling",
                                )?
                            }
                        };
                        _serde::__private::Ok(ScanningInputOptions {
                            show_advanced: __field0,
                            search_terms: __field1,
                            search_kanji: __field2,
                            scan_on_touch_move: __field3,
                            scan_on_touch_press: __field4,
                            scan_on_touch_release: __field5,
                            scan_on_touch_tap: __field6,
                            scan_on_pen_move: __field7,
                            scan_on_pen_hover: __field8,
                            scan_on_pen_release_hover: __field9,
                            scan_on_pen_press: __field10,
                            scan_on_pen_release: __field11,
                            prevent_touch_scrolling: __field12,
                            prevent_pen_scrolling: __field13,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "show_advanced",
                    "search_terms",
                    "search_kanji",
                    "scan_on_touch_move",
                    "scan_on_touch_press",
                    "scan_on_touch_release",
                    "scan_on_touch_tap",
                    "scan_on_pen_move",
                    "scan_on_pen_hover",
                    "scan_on_pen_release_hover",
                    "scan_on_pen_press",
                    "scan_on_pen_release",
                    "prevent_touch_scrolling",
                    "prevent_pen_scrolling",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ScanningInputOptions",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ScanningInputOptions>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for ScanningInputOptions {
        #[inline]
        fn default() -> ScanningInputOptions {
            ScanningInputOptions {
                show_advanced: ::core::default::Default::default(),
                search_terms: ::core::default::Default::default(),
                search_kanji: ::core::default::Default::default(),
                scan_on_touch_move: ::core::default::Default::default(),
                scan_on_touch_press: ::core::default::Default::default(),
                scan_on_touch_release: ::core::default::Default::default(),
                scan_on_touch_tap: ::core::default::Default::default(),
                scan_on_pen_move: ::core::default::Default::default(),
                scan_on_pen_hover: ::core::default::Default::default(),
                scan_on_pen_release_hover: ::core::default::Default::default(),
                scan_on_pen_press: ::core::default::Default::default(),
                scan_on_pen_release: ::core::default::Default::default(),
                prevent_touch_scrolling: ::core::default::Default::default(),
                prevent_pen_scrolling: ::core::default::Default::default(),
            }
        }
    }
    pub struct ScanningPreventMiddleMouseOptions {
        pub on_web_pages: bool,
        pub on_popup_pages: bool,
        pub on_search_pages: bool,
        pub on_search_query: bool,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ScanningPreventMiddleMouseOptions {
        #[inline]
        fn clone(&self) -> ScanningPreventMiddleMouseOptions {
            ScanningPreventMiddleMouseOptions {
                on_web_pages: ::core::clone::Clone::clone(&self.on_web_pages),
                on_popup_pages: ::core::clone::Clone::clone(&self.on_popup_pages),
                on_search_pages: ::core::clone::Clone::clone(&self.on_search_pages),
                on_search_query: ::core::clone::Clone::clone(&self.on_search_query),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ScanningPreventMiddleMouseOptions {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "ScanningPreventMiddleMouseOptions",
                "on_web_pages",
                &self.on_web_pages,
                "on_popup_pages",
                &self.on_popup_pages,
                "on_search_pages",
                &self.on_search_pages,
                "on_search_query",
                &&self.on_search_query,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ScanningPreventMiddleMouseOptions {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ScanningPreventMiddleMouseOptions {
        #[inline]
        fn eq(&self, other: &ScanningPreventMiddleMouseOptions) -> bool {
            self.on_web_pages == other.on_web_pages
                && self.on_popup_pages == other.on_popup_pages
                && self.on_search_pages == other.on_search_pages
                && self.on_search_query == other.on_search_query
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ScanningPreventMiddleMouseOptions {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "ScanningPreventMiddleMouseOptions",
                    false as usize + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "on_web_pages",
                    &self.on_web_pages,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "on_popup_pages",
                    &self.on_popup_pages,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "on_search_pages",
                    &self.on_search_pages,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "on_search_query",
                    &self.on_search_query,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ScanningPreventMiddleMouseOptions {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "on_web_pages" => _serde::__private::Ok(__Field::__field0),
                            "on_popup_pages" => _serde::__private::Ok(__Field::__field1),
                            "on_search_pages" => _serde::__private::Ok(__Field::__field2),
                            "on_search_query" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"on_web_pages" => _serde::__private::Ok(__Field::__field0),
                            b"on_popup_pages" => _serde::__private::Ok(__Field::__field1),
                            b"on_search_pages" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            b"on_search_query" => {
                                _serde::__private::Ok(__Field::__field3)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<
                        ScanningPreventMiddleMouseOptions,
                    >,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ScanningPreventMiddleMouseOptions;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct ScanningPreventMiddleMouseOptions",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct ScanningPreventMiddleMouseOptions with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct ScanningPreventMiddleMouseOptions with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct ScanningPreventMiddleMouseOptions with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct ScanningPreventMiddleMouseOptions with 4 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(ScanningPreventMiddleMouseOptions {
                            on_web_pages: __field0,
                            on_popup_pages: __field1,
                            on_search_pages: __field2,
                            on_search_query: __field3,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<bool> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "on_web_pages",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "on_popup_pages",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "on_search_pages",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "on_search_query",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("on_web_pages")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("on_popup_pages")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("on_search_pages")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("on_search_query")?
                            }
                        };
                        _serde::__private::Ok(ScanningPreventMiddleMouseOptions {
                            on_web_pages: __field0,
                            on_popup_pages: __field1,
                            on_search_pages: __field2,
                            on_search_query: __field3,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "on_web_pages",
                    "on_popup_pages",
                    "on_search_pages",
                    "on_search_query",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ScanningPreventMiddleMouseOptions",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            ScanningPreventMiddleMouseOptions,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for ScanningPreventMiddleMouseOptions {
        #[inline]
        fn default() -> ScanningPreventMiddleMouseOptions {
            ScanningPreventMiddleMouseOptions {
                on_web_pages: ::core::default::Default::default(),
                on_popup_pages: ::core::default::Default::default(),
                on_search_pages: ::core::default::Default::default(),
                on_search_query: ::core::default::Default::default(),
            }
        }
    }
    pub struct TranslationOptions {
        pub convert_half_width_characters: TranslationConvertType,
        pub convert_numeric_characters: TranslationConvertType,
        pub alphabetic_to_hiragana: TranslationConvertType,
        pub convert_hiragana_to_katakana: TranslationConvertType,
        pub convert_katakana_to_hiragana: TranslationConvertType,
        pub collapse_emphatic_sequences: TranslationCollapseEmphaticSequences,
        pub text_replacements: TranslationTextReplacementOptions,
        pub search_resolution: SearchResolution,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TranslationOptions {
        #[inline]
        fn clone(&self) -> TranslationOptions {
            TranslationOptions {
                convert_half_width_characters: ::core::clone::Clone::clone(
                    &self.convert_half_width_characters,
                ),
                convert_numeric_characters: ::core::clone::Clone::clone(
                    &self.convert_numeric_characters,
                ),
                alphabetic_to_hiragana: ::core::clone::Clone::clone(
                    &self.alphabetic_to_hiragana,
                ),
                convert_hiragana_to_katakana: ::core::clone::Clone::clone(
                    &self.convert_hiragana_to_katakana,
                ),
                convert_katakana_to_hiragana: ::core::clone::Clone::clone(
                    &self.convert_katakana_to_hiragana,
                ),
                collapse_emphatic_sequences: ::core::clone::Clone::clone(
                    &self.collapse_emphatic_sequences,
                ),
                text_replacements: ::core::clone::Clone::clone(&self.text_replacements),
                search_resolution: ::core::clone::Clone::clone(&self.search_resolution),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TranslationOptions {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "convert_half_width_characters",
                "convert_numeric_characters",
                "alphabetic_to_hiragana",
                "convert_hiragana_to_katakana",
                "convert_katakana_to_hiragana",
                "collapse_emphatic_sequences",
                "text_replacements",
                "search_resolution",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.convert_half_width_characters,
                &self.convert_numeric_characters,
                &self.alphabetic_to_hiragana,
                &self.convert_hiragana_to_katakana,
                &self.convert_katakana_to_hiragana,
                &self.collapse_emphatic_sequences,
                &self.text_replacements,
                &&self.search_resolution,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "TranslationOptions",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TranslationOptions {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TranslationOptions {
        #[inline]
        fn eq(&self, other: &TranslationOptions) -> bool {
            self.convert_half_width_characters == other.convert_half_width_characters
                && self.convert_numeric_characters == other.convert_numeric_characters
                && self.alphabetic_to_hiragana == other.alphabetic_to_hiragana
                && self.convert_hiragana_to_katakana
                    == other.convert_hiragana_to_katakana
                && self.convert_katakana_to_hiragana
                    == other.convert_katakana_to_hiragana
                && self.collapse_emphatic_sequences == other.collapse_emphatic_sequences
                && self.text_replacements == other.text_replacements
                && self.search_resolution == other.search_resolution
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TranslationOptions {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "TranslationOptions",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "convert_half_width_characters",
                    &self.convert_half_width_characters,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "convert_numeric_characters",
                    &self.convert_numeric_characters,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "alphabetic_to_hiragana",
                    &self.alphabetic_to_hiragana,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "convert_hiragana_to_katakana",
                    &self.convert_hiragana_to_katakana,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "convert_katakana_to_hiragana",
                    &self.convert_katakana_to_hiragana,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "collapse_emphatic_sequences",
                    &self.collapse_emphatic_sequences,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "text_replacements",
                    &self.text_replacements,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "search_resolution",
                    &self.search_resolution,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TranslationOptions {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "convert_half_width_characters" => {
                                _serde::__private::Ok(__Field::__field0)
                            }
                            "convert_numeric_characters" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            "alphabetic_to_hiragana" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            "convert_hiragana_to_katakana" => {
                                _serde::__private::Ok(__Field::__field3)
                            }
                            "convert_katakana_to_hiragana" => {
                                _serde::__private::Ok(__Field::__field4)
                            }
                            "collapse_emphatic_sequences" => {
                                _serde::__private::Ok(__Field::__field5)
                            }
                            "text_replacements" => {
                                _serde::__private::Ok(__Field::__field6)
                            }
                            "search_resolution" => {
                                _serde::__private::Ok(__Field::__field7)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"convert_half_width_characters" => {
                                _serde::__private::Ok(__Field::__field0)
                            }
                            b"convert_numeric_characters" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            b"alphabetic_to_hiragana" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            b"convert_hiragana_to_katakana" => {
                                _serde::__private::Ok(__Field::__field3)
                            }
                            b"convert_katakana_to_hiragana" => {
                                _serde::__private::Ok(__Field::__field4)
                            }
                            b"collapse_emphatic_sequences" => {
                                _serde::__private::Ok(__Field::__field5)
                            }
                            b"text_replacements" => {
                                _serde::__private::Ok(__Field::__field6)
                            }
                            b"search_resolution" => {
                                _serde::__private::Ok(__Field::__field7)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<TranslationOptions>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TranslationOptions;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct TranslationOptions",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            TranslationConvertType,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct TranslationOptions with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            TranslationConvertType,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct TranslationOptions with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            TranslationConvertType,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct TranslationOptions with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            TranslationConvertType,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct TranslationOptions with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            TranslationConvertType,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct TranslationOptions with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            TranslationCollapseEmphaticSequences,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct TranslationOptions with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field6 = match _serde::de::SeqAccess::next_element::<
                            TranslationTextReplacementOptions,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        6usize,
                                        &"struct TranslationOptions with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field7 = match _serde::de::SeqAccess::next_element::<
                            SearchResolution,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        7usize,
                                        &"struct TranslationOptions with 8 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(TranslationOptions {
                            convert_half_width_characters: __field0,
                            convert_numeric_characters: __field1,
                            alphabetic_to_hiragana: __field2,
                            convert_hiragana_to_katakana: __field3,
                            convert_katakana_to_hiragana: __field4,
                            collapse_emphatic_sequences: __field5,
                            text_replacements: __field6,
                            search_resolution: __field7,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            TranslationConvertType,
                        > = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            TranslationConvertType,
                        > = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<
                            TranslationConvertType,
                        > = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<
                            TranslationConvertType,
                        > = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<
                            TranslationConvertType,
                        > = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<
                            TranslationCollapseEmphaticSequences,
                        > = _serde::__private::None;
                        let mut __field6: _serde::__private::Option<
                            TranslationTextReplacementOptions,
                        > = _serde::__private::None;
                        let mut __field7: _serde::__private::Option<SearchResolution> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "convert_half_width_characters",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            TranslationConvertType,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "convert_numeric_characters",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            TranslationConvertType,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "alphabetic_to_hiragana",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            TranslationConvertType,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "convert_hiragana_to_katakana",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            TranslationConvertType,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "convert_katakana_to_hiragana",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            TranslationConvertType,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "collapse_emphatic_sequences",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            TranslationCollapseEmphaticSequences,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "text_replacements",
                                            ),
                                        );
                                    }
                                    __field6 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            TranslationTextReplacementOptions,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field7 => {
                                    if _serde::__private::Option::is_some(&__field7) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "search_resolution",
                                            ),
                                        );
                                    }
                                    __field7 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            SearchResolution,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "convert_half_width_characters",
                                )?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "convert_numeric_characters",
                                )?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "alphabetic_to_hiragana",
                                )?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "convert_hiragana_to_katakana",
                                )?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "convert_katakana_to_hiragana",
                                )?
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "collapse_emphatic_sequences",
                                )?
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("text_replacements")?
                            }
                        };
                        let __field7 = match __field7 {
                            _serde::__private::Some(__field7) => __field7,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("search_resolution")?
                            }
                        };
                        _serde::__private::Ok(TranslationOptions {
                            convert_half_width_characters: __field0,
                            convert_numeric_characters: __field1,
                            alphabetic_to_hiragana: __field2,
                            convert_hiragana_to_katakana: __field3,
                            convert_katakana_to_hiragana: __field4,
                            collapse_emphatic_sequences: __field5,
                            text_replacements: __field6,
                            search_resolution: __field7,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "convert_half_width_characters",
                    "convert_numeric_characters",
                    "alphabetic_to_hiragana",
                    "convert_hiragana_to_katakana",
                    "convert_katakana_to_hiragana",
                    "collapse_emphatic_sequences",
                    "text_replacements",
                    "search_resolution",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "TranslationOptions",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<TranslationOptions>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for TranslationOptions {
        #[inline]
        fn default() -> TranslationOptions {
            TranslationOptions {
                convert_half_width_characters: ::core::default::Default::default(),
                convert_numeric_characters: ::core::default::Default::default(),
                alphabetic_to_hiragana: ::core::default::Default::default(),
                convert_hiragana_to_katakana: ::core::default::Default::default(),
                convert_katakana_to_hiragana: ::core::default::Default::default(),
                collapse_emphatic_sequences: ::core::default::Default::default(),
                text_replacements: ::core::default::Default::default(),
                search_resolution: ::core::default::Default::default(),
            }
        }
    }
    /// # Example
    ///
    /// `Letter`: A dog  _"A dog"_ | _"A do"_ | _"A d"_ | _"A"_.
    ///
    /// `Word`: A dog  _"A dog"_ | _"A"_.
    pub enum SearchResolution {
        #[default]
        Letter,
        Word,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for SearchResolution {
        #[inline]
        fn clone(&self) -> SearchResolution {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for SearchResolution {}
    #[automatically_derived]
    impl ::core::fmt::Debug for SearchResolution {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    SearchResolution::Letter => "Letter",
                    SearchResolution::Word => "Word",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for SearchResolution {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for SearchResolution {
        #[inline]
        fn eq(&self, other: &SearchResolution) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for SearchResolution {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    SearchResolution::Letter => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SearchResolution",
                            0u32,
                            "Letter",
                        )
                    }
                    SearchResolution::Word => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SearchResolution",
                            1u32,
                            "Word",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for SearchResolution {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 2",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Letter" => _serde::__private::Ok(__Field::__field0),
                            "Word" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Letter" => _serde::__private::Ok(__Field::__field0),
                            b"Word" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<SearchResolution>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = SearchResolution;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum SearchResolution",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(SearchResolution::Letter)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(SearchResolution::Word)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["Letter", "Word"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "SearchResolution",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<SearchResolution>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for SearchResolution {
        #[inline]
        fn default() -> SearchResolution {
            Self::Letter
        }
    }
    pub struct TranslationTextReplacementOptions {
        pub search_original: bool,
        pub groups: Vec<Vec<TranslationTextReplacementGroup>>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TranslationTextReplacementOptions {
        #[inline]
        fn clone(&self) -> TranslationTextReplacementOptions {
            TranslationTextReplacementOptions {
                search_original: ::core::clone::Clone::clone(&self.search_original),
                groups: ::core::clone::Clone::clone(&self.groups),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TranslationTextReplacementOptions {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "TranslationTextReplacementOptions",
                "search_original",
                &self.search_original,
                "groups",
                &&self.groups,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TranslationTextReplacementOptions {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TranslationTextReplacementOptions {
        #[inline]
        fn eq(&self, other: &TranslationTextReplacementOptions) -> bool {
            self.search_original == other.search_original && self.groups == other.groups
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TranslationTextReplacementOptions {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "TranslationTextReplacementOptions",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "search_original",
                    &self.search_original,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "groups",
                    &self.groups,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TranslationTextReplacementOptions {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "search_original" => _serde::__private::Ok(__Field::__field0),
                            "groups" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"search_original" => {
                                _serde::__private::Ok(__Field::__field0)
                            }
                            b"groups" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<
                        TranslationTextReplacementOptions,
                    >,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TranslationTextReplacementOptions;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct TranslationTextReplacementOptions",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct TranslationTextReplacementOptions with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            Vec<Vec<TranslationTextReplacementGroup>>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct TranslationTextReplacementOptions with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(TranslationTextReplacementOptions {
                            search_original: __field0,
                            groups: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            Vec<Vec<TranslationTextReplacementGroup>>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "search_original",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("groups"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<Vec<TranslationTextReplacementGroup>>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("search_original")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("groups")?
                            }
                        };
                        _serde::__private::Ok(TranslationTextReplacementOptions {
                            search_original: __field0,
                            groups: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["search_original", "groups"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "TranslationTextReplacementOptions",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            TranslationTextReplacementOptions,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for TranslationTextReplacementOptions {
        #[inline]
        fn default() -> TranslationTextReplacementOptions {
            TranslationTextReplacementOptions {
                search_original: ::core::default::Default::default(),
                groups: ::core::default::Default::default(),
            }
        }
    }
    pub struct TranslationTextReplacementGroup {
        pub pattern: String,
        pub ignore_case: bool,
        pub replacement: String,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TranslationTextReplacementGroup {
        #[inline]
        fn clone(&self) -> TranslationTextReplacementGroup {
            TranslationTextReplacementGroup {
                pattern: ::core::clone::Clone::clone(&self.pattern),
                ignore_case: ::core::clone::Clone::clone(&self.ignore_case),
                replacement: ::core::clone::Clone::clone(&self.replacement),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TranslationTextReplacementGroup {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "TranslationTextReplacementGroup",
                "pattern",
                &self.pattern,
                "ignore_case",
                &self.ignore_case,
                "replacement",
                &&self.replacement,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TranslationTextReplacementGroup {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TranslationTextReplacementGroup {
        #[inline]
        fn eq(&self, other: &TranslationTextReplacementGroup) -> bool {
            self.pattern == other.pattern && self.ignore_case == other.ignore_case
                && self.replacement == other.replacement
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TranslationTextReplacementGroup {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "TranslationTextReplacementGroup",
                    false as usize + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "pattern",
                    &self.pattern,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "ignore_case",
                    &self.ignore_case,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "replacement",
                    &self.replacement,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TranslationTextReplacementGroup {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "pattern" => _serde::__private::Ok(__Field::__field0),
                            "ignore_case" => _serde::__private::Ok(__Field::__field1),
                            "replacement" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"pattern" => _serde::__private::Ok(__Field::__field0),
                            b"ignore_case" => _serde::__private::Ok(__Field::__field1),
                            b"replacement" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<
                        TranslationTextReplacementGroup,
                    >,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TranslationTextReplacementGroup;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct TranslationTextReplacementGroup",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct TranslationTextReplacementGroup with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct TranslationTextReplacementGroup with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct TranslationTextReplacementGroup with 3 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(TranslationTextReplacementGroup {
                            pattern: __field0,
                            ignore_case: __field1,
                            replacement: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<String> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "pattern",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "ignore_case",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "replacement",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("pattern")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("ignore_case")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("replacement")?
                            }
                        };
                        _serde::__private::Ok(TranslationTextReplacementGroup {
                            pattern: __field0,
                            ignore_case: __field1,
                            replacement: __field2,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "pattern",
                    "ignore_case",
                    "replacement",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "TranslationTextReplacementGroup",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            TranslationTextReplacementGroup,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for TranslationTextReplacementGroup {
        #[inline]
        fn default() -> TranslationTextReplacementGroup {
            TranslationTextReplacementGroup {
                pattern: ::core::default::Default::default(),
                ignore_case: ::core::default::Default::default(),
                replacement: ::core::default::Default::default(),
            }
        }
    }
    pub struct DictionaryOptions {
        /// The title of the dictionary.
        pub name: String,
        pub alias: String,
        /// Whether or not the dictionary will be used.
        pub enabled: bool,
        /// If you have two dictionaries, `Dict 1` and `Dict 2`:
        /// - Set the [`ResultOutputMode`] to `Group` results for the main dictionary entry.
        /// - Choose `Dict 1` as the main dictionary for merged mode.
        /// - Enable `allow_secondary_searches` on `Dict 2`.
        ///   _(Can be enabled for multiple dictionaries)_.
        ///
        /// Yomichan_rs will now first perform an _initial_ lookup in `Dict 1`, fetching the grouped definition.
        /// It will then use the headwords from `Dict 1`to perform a secondary lookup in `Dict 2`,
        /// merging the two dictionary's definitions.
        pub allow_secondary_searches: bool,
        /// Dictionary definitions can be collapsed if they exceed a certain line count,
        /// which may be useful for dictionaries with long definitions. There are five different modes:
        ///
        /// By default, the number of lines shown for a definition is 3.
        /// This can be configured by adjusting the Custom CSS `styles`;
        ///
        /// _(Value can be a unitless integer or decimal number)_.
        pub definitions_collapsible: DictionaryDefinitionsCollapsible,
        /// When deinflecting words, only dictionary entries whose POS
        /// matches that expected by the deinflector will be shown.
        pub parts_of_speech_filter: bool,
        /// Deinflections from this dictionary will be used.
        pub use_deinflections: bool,
        /// # Example
        ///
        /// ```
        /// /* Globally set the line count */
        /// :root {
        /// --collapsible-definition-line-count: 2;
        /// }
        ///
        /// /* Set the line count for a specific dictionary */
        /// .definition-item[data-dictionary='JMdict'] {
        /// --collapsible-definition-line-count: 2;
        /// }
        ///
        /// /* Spoiler-like functionality, use with Force collapsed mode */
        /// .definition-item[data-dictionary='JMdict'] .definition-item-inner.collapsible.collapsed {
        /// color: #000000;
        /// background-color: #000000;
        /// }
        /// ```
        pub styles: Option<String>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for DictionaryOptions {
        #[inline]
        fn clone(&self) -> DictionaryOptions {
            DictionaryOptions {
                name: ::core::clone::Clone::clone(&self.name),
                alias: ::core::clone::Clone::clone(&self.alias),
                enabled: ::core::clone::Clone::clone(&self.enabled),
                allow_secondary_searches: ::core::clone::Clone::clone(
                    &self.allow_secondary_searches,
                ),
                definitions_collapsible: ::core::clone::Clone::clone(
                    &self.definitions_collapsible,
                ),
                parts_of_speech_filter: ::core::clone::Clone::clone(
                    &self.parts_of_speech_filter,
                ),
                use_deinflections: ::core::clone::Clone::clone(&self.use_deinflections),
                styles: ::core::clone::Clone::clone(&self.styles),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for DictionaryOptions {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "name",
                "alias",
                "enabled",
                "allow_secondary_searches",
                "definitions_collapsible",
                "parts_of_speech_filter",
                "use_deinflections",
                "styles",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.name,
                &self.alias,
                &self.enabled,
                &self.allow_secondary_searches,
                &self.definitions_collapsible,
                &self.parts_of_speech_filter,
                &self.use_deinflections,
                &&self.styles,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "DictionaryOptions",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for DictionaryOptions {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for DictionaryOptions {
        #[inline]
        fn eq(&self, other: &DictionaryOptions) -> bool {
            self.name == other.name && self.alias == other.alias
                && self.enabled == other.enabled
                && self.allow_secondary_searches == other.allow_secondary_searches
                && self.definitions_collapsible == other.definitions_collapsible
                && self.parts_of_speech_filter == other.parts_of_speech_filter
                && self.use_deinflections == other.use_deinflections
                && self.styles == other.styles
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for DictionaryOptions {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<String>;
            let _: ::core::cmp::AssertParamIsEq<bool>;
            let _: ::core::cmp::AssertParamIsEq<DictionaryDefinitionsCollapsible>;
            let _: ::core::cmp::AssertParamIsEq<Option<String>>;
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for DictionaryOptions {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.name, state);
            ::core::hash::Hash::hash(&self.alias, state);
            ::core::hash::Hash::hash(&self.enabled, state);
            ::core::hash::Hash::hash(&self.allow_secondary_searches, state);
            ::core::hash::Hash::hash(&self.definitions_collapsible, state);
            ::core::hash::Hash::hash(&self.parts_of_speech_filter, state);
            ::core::hash::Hash::hash(&self.use_deinflections, state);
            ::core::hash::Hash::hash(&self.styles, state)
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for DictionaryOptions {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "DictionaryOptions",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "name",
                    &self.name,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "alias",
                    &self.alias,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "enabled",
                    &self.enabled,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "allow_secondary_searches",
                    &self.allow_secondary_searches,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "definitions_collapsible",
                    &self.definitions_collapsible,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "parts_of_speech_filter",
                    &self.parts_of_speech_filter,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "use_deinflections",
                    &self.use_deinflections,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "styles",
                    &self.styles,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for DictionaryOptions {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "name" => _serde::__private::Ok(__Field::__field0),
                            "alias" => _serde::__private::Ok(__Field::__field1),
                            "enabled" => _serde::__private::Ok(__Field::__field2),
                            "allow_secondary_searches" => {
                                _serde::__private::Ok(__Field::__field3)
                            }
                            "definitions_collapsible" => {
                                _serde::__private::Ok(__Field::__field4)
                            }
                            "parts_of_speech_filter" => {
                                _serde::__private::Ok(__Field::__field5)
                            }
                            "use_deinflections" => {
                                _serde::__private::Ok(__Field::__field6)
                            }
                            "styles" => _serde::__private::Ok(__Field::__field7),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"name" => _serde::__private::Ok(__Field::__field0),
                            b"alias" => _serde::__private::Ok(__Field::__field1),
                            b"enabled" => _serde::__private::Ok(__Field::__field2),
                            b"allow_secondary_searches" => {
                                _serde::__private::Ok(__Field::__field3)
                            }
                            b"definitions_collapsible" => {
                                _serde::__private::Ok(__Field::__field4)
                            }
                            b"parts_of_speech_filter" => {
                                _serde::__private::Ok(__Field::__field5)
                            }
                            b"use_deinflections" => {
                                _serde::__private::Ok(__Field::__field6)
                            }
                            b"styles" => _serde::__private::Ok(__Field::__field7),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<DictionaryOptions>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = DictionaryOptions;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct DictionaryOptions",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct DictionaryOptions with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct DictionaryOptions with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct DictionaryOptions with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct DictionaryOptions with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            DictionaryDefinitionsCollapsible,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct DictionaryOptions with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct DictionaryOptions with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field6 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        6usize,
                                        &"struct DictionaryOptions with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field7 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        7usize,
                                        &"struct DictionaryOptions with 8 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(DictionaryOptions {
                            name: __field0,
                            alias: __field1,
                            enabled: __field2,
                            allow_secondary_searches: __field3,
                            definitions_collapsible: __field4,
                            parts_of_speech_filter: __field5,
                            use_deinflections: __field6,
                            styles: __field7,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<
                            DictionaryDefinitionsCollapsible,
                        > = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field6: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field7: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("alias"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "enabled",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "allow_secondary_searches",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "definitions_collapsible",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            DictionaryDefinitionsCollapsible,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "parts_of_speech_filter",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "use_deinflections",
                                            ),
                                        );
                                    }
                                    __field6 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field7 => {
                                    if _serde::__private::Option::is_some(&__field7) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("styles"),
                                        );
                                    }
                                    __field7 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("name")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("alias")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("enabled")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "allow_secondary_searches",
                                )?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "definitions_collapsible",
                                )?
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "parts_of_speech_filter",
                                )?
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("use_deinflections")?
                            }
                        };
                        let __field7 = match __field7 {
                            _serde::__private::Some(__field7) => __field7,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("styles")?
                            }
                        };
                        _serde::__private::Ok(DictionaryOptions {
                            name: __field0,
                            alias: __field1,
                            enabled: __field2,
                            allow_secondary_searches: __field3,
                            definitions_collapsible: __field4,
                            parts_of_speech_filter: __field5,
                            use_deinflections: __field6,
                            styles: __field7,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "name",
                    "alias",
                    "enabled",
                    "allow_secondary_searches",
                    "definitions_collapsible",
                    "parts_of_speech_filter",
                    "use_deinflections",
                    "styles",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "DictionaryOptions",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<DictionaryOptions>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    impl DictionaryOptions {
        pub fn new(settings: &Options, dict_name: String) -> Self {
            let profile = settings.get_current_profile();
            let p_len = profile.options.dictionaries.len();
            DictionaryOptions {
                name: dict_name.clone(),
                alias: dict_name,
                enabled: true,
                allow_secondary_searches: false,
                definitions_collapsible: DictionaryDefinitionsCollapsible::Expanded,
                parts_of_speech_filter: false,
                use_deinflections: true,
                styles: None,
            }
        }
    }
    pub struct ParsingOptions {
        pub enable_scanning_parser: bool,
        pub enable_mecab_parser: bool,
        pub selected_parser: Option<String>,
        pub term_spacing: bool,
        pub reading_mode: ParsingReadingMode,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ParsingOptions {
        #[inline]
        fn clone(&self) -> ParsingOptions {
            ParsingOptions {
                enable_scanning_parser: ::core::clone::Clone::clone(
                    &self.enable_scanning_parser,
                ),
                enable_mecab_parser: ::core::clone::Clone::clone(
                    &self.enable_mecab_parser,
                ),
                selected_parser: ::core::clone::Clone::clone(&self.selected_parser),
                term_spacing: ::core::clone::Clone::clone(&self.term_spacing),
                reading_mode: ::core::clone::Clone::clone(&self.reading_mode),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ParsingOptions {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "ParsingOptions",
                "enable_scanning_parser",
                &self.enable_scanning_parser,
                "enable_mecab_parser",
                &self.enable_mecab_parser,
                "selected_parser",
                &self.selected_parser,
                "term_spacing",
                &self.term_spacing,
                "reading_mode",
                &&self.reading_mode,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ParsingOptions {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ParsingOptions {
        #[inline]
        fn eq(&self, other: &ParsingOptions) -> bool {
            self.enable_scanning_parser == other.enable_scanning_parser
                && self.enable_mecab_parser == other.enable_mecab_parser
                && self.selected_parser == other.selected_parser
                && self.term_spacing == other.term_spacing
                && self.reading_mode == other.reading_mode
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ParsingOptions {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "ParsingOptions",
                    false as usize + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "enable_scanning_parser",
                    &self.enable_scanning_parser,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "enable_mecab_parser",
                    &self.enable_mecab_parser,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "selected_parser",
                    &self.selected_parser,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "term_spacing",
                    &self.term_spacing,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "reading_mode",
                    &self.reading_mode,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ParsingOptions {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "enable_scanning_parser" => {
                                _serde::__private::Ok(__Field::__field0)
                            }
                            "enable_mecab_parser" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            "selected_parser" => _serde::__private::Ok(__Field::__field2),
                            "term_spacing" => _serde::__private::Ok(__Field::__field3),
                            "reading_mode" => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"enable_scanning_parser" => {
                                _serde::__private::Ok(__Field::__field0)
                            }
                            b"enable_mecab_parser" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            b"selected_parser" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            b"term_spacing" => _serde::__private::Ok(__Field::__field3),
                            b"reading_mode" => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ParsingOptions>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ParsingOptions;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct ParsingOptions",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct ParsingOptions with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct ParsingOptions with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct ParsingOptions with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct ParsingOptions with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            ParsingReadingMode,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct ParsingOptions with 5 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(ParsingOptions {
                            enable_scanning_parser: __field0,
                            enable_mecab_parser: __field1,
                            selected_parser: __field2,
                            term_spacing: __field3,
                            reading_mode: __field4,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<
                            ParsingReadingMode,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "enable_scanning_parser",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "enable_mecab_parser",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "selected_parser",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "term_spacing",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "reading_mode",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ParsingReadingMode,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "enable_scanning_parser",
                                )?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("enable_mecab_parser")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("selected_parser")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("term_spacing")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("reading_mode")?
                            }
                        };
                        _serde::__private::Ok(ParsingOptions {
                            enable_scanning_parser: __field0,
                            enable_mecab_parser: __field1,
                            selected_parser: __field2,
                            term_spacing: __field3,
                            reading_mode: __field4,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "enable_scanning_parser",
                    "enable_mecab_parser",
                    "selected_parser",
                    "term_spacing",
                    "reading_mode",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ParsingOptions",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ParsingOptions>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for ParsingOptions {
        #[inline]
        fn default() -> ParsingOptions {
            ParsingOptions {
                enable_scanning_parser: ::core::default::Default::default(),
                enable_mecab_parser: ::core::default::Default::default(),
                selected_parser: ::core::default::Default::default(),
                term_spacing: ::core::default::Default::default(),
                reading_mode: ::core::default::Default::default(),
            }
        }
    }
    pub struct AnkiOptions {
        pub enable: bool,
        pub server: String,
        pub tags: Vec<String>,
        pub screenshot: AnkiScreenshotOptions,
        pub terms: AnkiNoteOptions,
        pub kanji: AnkiNoteOptions,
        pub duplicate_scope: AnkiDuplicateScope,
        pub duplicate_scope_check_all_models: bool,
        pub duplicate_behavior: AnkiDuplicateBehavior,
        pub check_for_duplicates: bool,
        pub field_templates: Vec<String>,
        pub suspend_new_cards: bool,
        pub display_tags: AnkiDisplayTags,
        pub note_gui_mode: AnkiNoteGuiMode,
        pub api_key: String,
        /// The maximum time _(in milliseconds)_ before an idle download will be cancelled;
        /// 0 = no limit.
        ///
        /// Audio files can be downloaded from remote servers when creating Anki cards,
        /// and sometimes these downloads can stall due to server or internet connectivity issues.
        /// When this setting has a non-zero value, if a download has stalled for longer
        /// than the time specified, the download will be cancelled.
        pub download_timeout: u32,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for AnkiOptions {
        #[inline]
        fn clone(&self) -> AnkiOptions {
            AnkiOptions {
                enable: ::core::clone::Clone::clone(&self.enable),
                server: ::core::clone::Clone::clone(&self.server),
                tags: ::core::clone::Clone::clone(&self.tags),
                screenshot: ::core::clone::Clone::clone(&self.screenshot),
                terms: ::core::clone::Clone::clone(&self.terms),
                kanji: ::core::clone::Clone::clone(&self.kanji),
                duplicate_scope: ::core::clone::Clone::clone(&self.duplicate_scope),
                duplicate_scope_check_all_models: ::core::clone::Clone::clone(
                    &self.duplicate_scope_check_all_models,
                ),
                duplicate_behavior: ::core::clone::Clone::clone(
                    &self.duplicate_behavior,
                ),
                check_for_duplicates: ::core::clone::Clone::clone(
                    &self.check_for_duplicates,
                ),
                field_templates: ::core::clone::Clone::clone(&self.field_templates),
                suspend_new_cards: ::core::clone::Clone::clone(&self.suspend_new_cards),
                display_tags: ::core::clone::Clone::clone(&self.display_tags),
                note_gui_mode: ::core::clone::Clone::clone(&self.note_gui_mode),
                api_key: ::core::clone::Clone::clone(&self.api_key),
                download_timeout: ::core::clone::Clone::clone(&self.download_timeout),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for AnkiOptions {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "enable",
                "server",
                "tags",
                "screenshot",
                "terms",
                "kanji",
                "duplicate_scope",
                "duplicate_scope_check_all_models",
                "duplicate_behavior",
                "check_for_duplicates",
                "field_templates",
                "suspend_new_cards",
                "display_tags",
                "note_gui_mode",
                "api_key",
                "download_timeout",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.enable,
                &self.server,
                &self.tags,
                &self.screenshot,
                &self.terms,
                &self.kanji,
                &self.duplicate_scope,
                &self.duplicate_scope_check_all_models,
                &self.duplicate_behavior,
                &self.check_for_duplicates,
                &self.field_templates,
                &self.suspend_new_cards,
                &self.display_tags,
                &self.note_gui_mode,
                &self.api_key,
                &&self.download_timeout,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "AnkiOptions",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for AnkiOptions {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for AnkiOptions {
        #[inline]
        fn eq(&self, other: &AnkiOptions) -> bool {
            self.enable == other.enable && self.server == other.server
                && self.tags == other.tags && self.screenshot == other.screenshot
                && self.terms == other.terms && self.kanji == other.kanji
                && self.duplicate_scope == other.duplicate_scope
                && self.duplicate_scope_check_all_models
                    == other.duplicate_scope_check_all_models
                && self.duplicate_behavior == other.duplicate_behavior
                && self.check_for_duplicates == other.check_for_duplicates
                && self.field_templates == other.field_templates
                && self.suspend_new_cards == other.suspend_new_cards
                && self.display_tags == other.display_tags
                && self.note_gui_mode == other.note_gui_mode
                && self.api_key == other.api_key
                && self.download_timeout == other.download_timeout
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for AnkiOptions {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "AnkiOptions",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1
                        + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "enable",
                    &self.enable,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "server",
                    &self.server,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "tags",
                    &self.tags,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "screenshot",
                    &self.screenshot,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "terms",
                    &self.terms,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "kanji",
                    &self.kanji,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "duplicate_scope",
                    &self.duplicate_scope,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "duplicate_scope_check_all_models",
                    &self.duplicate_scope_check_all_models,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "duplicate_behavior",
                    &self.duplicate_behavior,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "check_for_duplicates",
                    &self.check_for_duplicates,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "field_templates",
                    &self.field_templates,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "suspend_new_cards",
                    &self.suspend_new_cards,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "display_tags",
                    &self.display_tags,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "note_gui_mode",
                    &self.note_gui_mode,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "api_key",
                    &self.api_key,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "download_timeout",
                    &self.download_timeout,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for AnkiOptions {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __field8,
                    __field9,
                    __field10,
                    __field11,
                    __field12,
                    __field13,
                    __field14,
                    __field15,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            8u64 => _serde::__private::Ok(__Field::__field8),
                            9u64 => _serde::__private::Ok(__Field::__field9),
                            10u64 => _serde::__private::Ok(__Field::__field10),
                            11u64 => _serde::__private::Ok(__Field::__field11),
                            12u64 => _serde::__private::Ok(__Field::__field12),
                            13u64 => _serde::__private::Ok(__Field::__field13),
                            14u64 => _serde::__private::Ok(__Field::__field14),
                            15u64 => _serde::__private::Ok(__Field::__field15),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "enable" => _serde::__private::Ok(__Field::__field0),
                            "server" => _serde::__private::Ok(__Field::__field1),
                            "tags" => _serde::__private::Ok(__Field::__field2),
                            "screenshot" => _serde::__private::Ok(__Field::__field3),
                            "terms" => _serde::__private::Ok(__Field::__field4),
                            "kanji" => _serde::__private::Ok(__Field::__field5),
                            "duplicate_scope" => _serde::__private::Ok(__Field::__field6),
                            "duplicate_scope_check_all_models" => {
                                _serde::__private::Ok(__Field::__field7)
                            }
                            "duplicate_behavior" => {
                                _serde::__private::Ok(__Field::__field8)
                            }
                            "check_for_duplicates" => {
                                _serde::__private::Ok(__Field::__field9)
                            }
                            "field_templates" => {
                                _serde::__private::Ok(__Field::__field10)
                            }
                            "suspend_new_cards" => {
                                _serde::__private::Ok(__Field::__field11)
                            }
                            "display_tags" => _serde::__private::Ok(__Field::__field12),
                            "note_gui_mode" => _serde::__private::Ok(__Field::__field13),
                            "api_key" => _serde::__private::Ok(__Field::__field14),
                            "download_timeout" => {
                                _serde::__private::Ok(__Field::__field15)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"enable" => _serde::__private::Ok(__Field::__field0),
                            b"server" => _serde::__private::Ok(__Field::__field1),
                            b"tags" => _serde::__private::Ok(__Field::__field2),
                            b"screenshot" => _serde::__private::Ok(__Field::__field3),
                            b"terms" => _serde::__private::Ok(__Field::__field4),
                            b"kanji" => _serde::__private::Ok(__Field::__field5),
                            b"duplicate_scope" => {
                                _serde::__private::Ok(__Field::__field6)
                            }
                            b"duplicate_scope_check_all_models" => {
                                _serde::__private::Ok(__Field::__field7)
                            }
                            b"duplicate_behavior" => {
                                _serde::__private::Ok(__Field::__field8)
                            }
                            b"check_for_duplicates" => {
                                _serde::__private::Ok(__Field::__field9)
                            }
                            b"field_templates" => {
                                _serde::__private::Ok(__Field::__field10)
                            }
                            b"suspend_new_cards" => {
                                _serde::__private::Ok(__Field::__field11)
                            }
                            b"display_tags" => _serde::__private::Ok(__Field::__field12),
                            b"note_gui_mode" => _serde::__private::Ok(__Field::__field13),
                            b"api_key" => _serde::__private::Ok(__Field::__field14),
                            b"download_timeout" => {
                                _serde::__private::Ok(__Field::__field15)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<AnkiOptions>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = AnkiOptions;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct AnkiOptions",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct AnkiOptions with 16 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct AnkiOptions with 16 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            Vec<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct AnkiOptions with 16 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            AnkiScreenshotOptions,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct AnkiOptions with 16 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            AnkiNoteOptions,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct AnkiOptions with 16 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            AnkiNoteOptions,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct AnkiOptions with 16 elements",
                                    ),
                                );
                            }
                        };
                        let __field6 = match _serde::de::SeqAccess::next_element::<
                            AnkiDuplicateScope,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        6usize,
                                        &"struct AnkiOptions with 16 elements",
                                    ),
                                );
                            }
                        };
                        let __field7 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        7usize,
                                        &"struct AnkiOptions with 16 elements",
                                    ),
                                );
                            }
                        };
                        let __field8 = match _serde::de::SeqAccess::next_element::<
                            AnkiDuplicateBehavior,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        8usize,
                                        &"struct AnkiOptions with 16 elements",
                                    ),
                                );
                            }
                        };
                        let __field9 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        9usize,
                                        &"struct AnkiOptions with 16 elements",
                                    ),
                                );
                            }
                        };
                        let __field10 = match _serde::de::SeqAccess::next_element::<
                            Vec<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        10usize,
                                        &"struct AnkiOptions with 16 elements",
                                    ),
                                );
                            }
                        };
                        let __field11 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        11usize,
                                        &"struct AnkiOptions with 16 elements",
                                    ),
                                );
                            }
                        };
                        let __field12 = match _serde::de::SeqAccess::next_element::<
                            AnkiDisplayTags,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        12usize,
                                        &"struct AnkiOptions with 16 elements",
                                    ),
                                );
                            }
                        };
                        let __field13 = match _serde::de::SeqAccess::next_element::<
                            AnkiNoteGuiMode,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        13usize,
                                        &"struct AnkiOptions with 16 elements",
                                    ),
                                );
                            }
                        };
                        let __field14 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        14usize,
                                        &"struct AnkiOptions with 16 elements",
                                    ),
                                );
                            }
                        };
                        let __field15 = match _serde::de::SeqAccess::next_element::<
                            u32,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        15usize,
                                        &"struct AnkiOptions with 16 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(AnkiOptions {
                            enable: __field0,
                            server: __field1,
                            tags: __field2,
                            screenshot: __field3,
                            terms: __field4,
                            kanji: __field5,
                            duplicate_scope: __field6,
                            duplicate_scope_check_all_models: __field7,
                            duplicate_behavior: __field8,
                            check_for_duplicates: __field9,
                            field_templates: __field10,
                            suspend_new_cards: __field11,
                            display_tags: __field12,
                            note_gui_mode: __field13,
                            api_key: __field14,
                            download_timeout: __field15,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<Vec<String>> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<
                            AnkiScreenshotOptions,
                        > = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<AnkiNoteOptions> = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<AnkiNoteOptions> = _serde::__private::None;
                        let mut __field6: _serde::__private::Option<
                            AnkiDuplicateScope,
                        > = _serde::__private::None;
                        let mut __field7: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field8: _serde::__private::Option<
                            AnkiDuplicateBehavior,
                        > = _serde::__private::None;
                        let mut __field9: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field10: _serde::__private::Option<Vec<String>> = _serde::__private::None;
                        let mut __field11: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field12: _serde::__private::Option<AnkiDisplayTags> = _serde::__private::None;
                        let mut __field13: _serde::__private::Option<AnkiNoteGuiMode> = _serde::__private::None;
                        let mut __field14: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field15: _serde::__private::Option<u32> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("enable"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("server"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("tags"),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "screenshot",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            AnkiScreenshotOptions,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("terms"),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            AnkiNoteOptions,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("kanji"),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            AnkiNoteOptions,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "duplicate_scope",
                                            ),
                                        );
                                    }
                                    __field6 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            AnkiDuplicateScope,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field7 => {
                                    if _serde::__private::Option::is_some(&__field7) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "duplicate_scope_check_all_models",
                                            ),
                                        );
                                    }
                                    __field7 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field8 => {
                                    if _serde::__private::Option::is_some(&__field8) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "duplicate_behavior",
                                            ),
                                        );
                                    }
                                    __field8 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            AnkiDuplicateBehavior,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field9 => {
                                    if _serde::__private::Option::is_some(&__field9) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "check_for_duplicates",
                                            ),
                                        );
                                    }
                                    __field9 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field10 => {
                                    if _serde::__private::Option::is_some(&__field10) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "field_templates",
                                            ),
                                        );
                                    }
                                    __field10 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field11 => {
                                    if _serde::__private::Option::is_some(&__field11) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "suspend_new_cards",
                                            ),
                                        );
                                    }
                                    __field11 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field12 => {
                                    if _serde::__private::Option::is_some(&__field12) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "display_tags",
                                            ),
                                        );
                                    }
                                    __field12 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            AnkiDisplayTags,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field13 => {
                                    if _serde::__private::Option::is_some(&__field13) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "note_gui_mode",
                                            ),
                                        );
                                    }
                                    __field13 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            AnkiNoteGuiMode,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field14 => {
                                    if _serde::__private::Option::is_some(&__field14) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "api_key",
                                            ),
                                        );
                                    }
                                    __field14 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field15 => {
                                    if _serde::__private::Option::is_some(&__field15) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "download_timeout",
                                            ),
                                        );
                                    }
                                    __field15 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u32>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("enable")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("server")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("tags")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("screenshot")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("terms")?
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("kanji")?
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("duplicate_scope")?
                            }
                        };
                        let __field7 = match __field7 {
                            _serde::__private::Some(__field7) => __field7,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "duplicate_scope_check_all_models",
                                )?
                            }
                        };
                        let __field8 = match __field8 {
                            _serde::__private::Some(__field8) => __field8,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("duplicate_behavior")?
                            }
                        };
                        let __field9 = match __field9 {
                            _serde::__private::Some(__field9) => __field9,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "check_for_duplicates",
                                )?
                            }
                        };
                        let __field10 = match __field10 {
                            _serde::__private::Some(__field10) => __field10,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("field_templates")?
                            }
                        };
                        let __field11 = match __field11 {
                            _serde::__private::Some(__field11) => __field11,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("suspend_new_cards")?
                            }
                        };
                        let __field12 = match __field12 {
                            _serde::__private::Some(__field12) => __field12,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("display_tags")?
                            }
                        };
                        let __field13 = match __field13 {
                            _serde::__private::Some(__field13) => __field13,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("note_gui_mode")?
                            }
                        };
                        let __field14 = match __field14 {
                            _serde::__private::Some(__field14) => __field14,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("api_key")?
                            }
                        };
                        let __field15 = match __field15 {
                            _serde::__private::Some(__field15) => __field15,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("download_timeout")?
                            }
                        };
                        _serde::__private::Ok(AnkiOptions {
                            enable: __field0,
                            server: __field1,
                            tags: __field2,
                            screenshot: __field3,
                            terms: __field4,
                            kanji: __field5,
                            duplicate_scope: __field6,
                            duplicate_scope_check_all_models: __field7,
                            duplicate_behavior: __field8,
                            check_for_duplicates: __field9,
                            field_templates: __field10,
                            suspend_new_cards: __field11,
                            display_tags: __field12,
                            note_gui_mode: __field13,
                            api_key: __field14,
                            download_timeout: __field15,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "enable",
                    "server",
                    "tags",
                    "screenshot",
                    "terms",
                    "kanji",
                    "duplicate_scope",
                    "duplicate_scope_check_all_models",
                    "duplicate_behavior",
                    "check_for_duplicates",
                    "field_templates",
                    "suspend_new_cards",
                    "display_tags",
                    "note_gui_mode",
                    "api_key",
                    "download_timeout",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "AnkiOptions",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<AnkiOptions>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for AnkiOptions {
        #[inline]
        fn default() -> AnkiOptions {
            AnkiOptions {
                enable: ::core::default::Default::default(),
                server: ::core::default::Default::default(),
                tags: ::core::default::Default::default(),
                screenshot: ::core::default::Default::default(),
                terms: ::core::default::Default::default(),
                kanji: ::core::default::Default::default(),
                duplicate_scope: ::core::default::Default::default(),
                duplicate_scope_check_all_models: ::core::default::Default::default(),
                duplicate_behavior: ::core::default::Default::default(),
                check_for_duplicates: ::core::default::Default::default(),
                field_templates: ::core::default::Default::default(),
                suspend_new_cards: ::core::default::Default::default(),
                display_tags: ::core::default::Default::default(),
                note_gui_mode: ::core::default::Default::default(),
                api_key: ::core::default::Default::default(),
                download_timeout: ::core::default::Default::default(),
            }
        }
    }
    pub struct AnkiScreenshotOptions {
        pub format: AnkiScreenshotFormat,
        pub quality: u8,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for AnkiScreenshotOptions {
        #[inline]
        fn clone(&self) -> AnkiScreenshotOptions {
            AnkiScreenshotOptions {
                format: ::core::clone::Clone::clone(&self.format),
                quality: ::core::clone::Clone::clone(&self.quality),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for AnkiScreenshotOptions {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "AnkiScreenshotOptions",
                "format",
                &self.format,
                "quality",
                &&self.quality,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for AnkiScreenshotOptions {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for AnkiScreenshotOptions {
        #[inline]
        fn eq(&self, other: &AnkiScreenshotOptions) -> bool {
            self.format == other.format && self.quality == other.quality
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for AnkiScreenshotOptions {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "AnkiScreenshotOptions",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "format",
                    &self.format,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "quality",
                    &self.quality,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for AnkiScreenshotOptions {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "format" => _serde::__private::Ok(__Field::__field0),
                            "quality" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"format" => _serde::__private::Ok(__Field::__field0),
                            b"quality" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<AnkiScreenshotOptions>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = AnkiScreenshotOptions;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct AnkiScreenshotOptions",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            AnkiScreenshotFormat,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct AnkiScreenshotOptions with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            u8,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct AnkiScreenshotOptions with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(AnkiScreenshotOptions {
                            format: __field0,
                            quality: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            AnkiScreenshotFormat,
                        > = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<u8> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("format"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            AnkiScreenshotFormat,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "quality",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u8>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("format")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("quality")?
                            }
                        };
                        _serde::__private::Ok(AnkiScreenshotOptions {
                            format: __field0,
                            quality: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["format", "quality"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "AnkiScreenshotOptions",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<AnkiScreenshotOptions>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for AnkiScreenshotOptions {
        #[inline]
        fn default() -> AnkiScreenshotOptions {
            AnkiScreenshotOptions {
                format: ::core::default::Default::default(),
                quality: ::core::default::Default::default(),
            }
        }
    }
    pub struct AnkiNoteOptions {
        pub deck: String,
        pub model: String,
        pub fields: AnkiNoteFields,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for AnkiNoteOptions {
        #[inline]
        fn clone(&self) -> AnkiNoteOptions {
            AnkiNoteOptions {
                deck: ::core::clone::Clone::clone(&self.deck),
                model: ::core::clone::Clone::clone(&self.model),
                fields: ::core::clone::Clone::clone(&self.fields),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for AnkiNoteOptions {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "AnkiNoteOptions",
                "deck",
                &self.deck,
                "model",
                &self.model,
                "fields",
                &&self.fields,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for AnkiNoteOptions {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for AnkiNoteOptions {
        #[inline]
        fn eq(&self, other: &AnkiNoteOptions) -> bool {
            self.deck == other.deck && self.model == other.model
                && self.fields == other.fields
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for AnkiNoteOptions {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "AnkiNoteOptions",
                    false as usize + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "deck",
                    &self.deck,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "model",
                    &self.model,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "fields",
                    &self.fields,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for AnkiNoteOptions {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "deck" => _serde::__private::Ok(__Field::__field0),
                            "model" => _serde::__private::Ok(__Field::__field1),
                            "fields" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"deck" => _serde::__private::Ok(__Field::__field0),
                            b"model" => _serde::__private::Ok(__Field::__field1),
                            b"fields" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<AnkiNoteOptions>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = AnkiNoteOptions;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct AnkiNoteOptions",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct AnkiNoteOptions with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct AnkiNoteOptions with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            AnkiNoteFields,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct AnkiNoteOptions with 3 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(AnkiNoteOptions {
                            deck: __field0,
                            model: __field1,
                            fields: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<AnkiNoteFields> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("deck"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("model"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("fields"),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            AnkiNoteFields,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("deck")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("model")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("fields")?
                            }
                        };
                        _serde::__private::Ok(AnkiNoteOptions {
                            deck: __field0,
                            model: __field1,
                            fields: __field2,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["deck", "model", "fields"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "AnkiNoteOptions",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<AnkiNoteOptions>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for AnkiNoteOptions {
        #[inline]
        fn default() -> AnkiNoteOptions {
            AnkiNoteOptions {
                deck: ::core::default::Default::default(),
                model: ::core::default::Default::default(),
                fields: ::core::default::Default::default(),
            }
        }
    }
    pub type AnkiNoteFields = IndexMap<String, String>;
    pub struct SentenceParsingOptions {
        /// Adjust how many characters are bidirectionally scanned to form a sentence.
        pub scan_extent: u16,
        pub termination_character_mode: SentenceTerminationCharacterMode,
        pub termination_characters: Vec<SentenceParsingTerminationCharacterOption>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for SentenceParsingOptions {
        #[inline]
        fn clone(&self) -> SentenceParsingOptions {
            SentenceParsingOptions {
                scan_extent: ::core::clone::Clone::clone(&self.scan_extent),
                termination_character_mode: ::core::clone::Clone::clone(
                    &self.termination_character_mode,
                ),
                termination_characters: ::core::clone::Clone::clone(
                    &self.termination_characters,
                ),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for SentenceParsingOptions {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "SentenceParsingOptions",
                "scan_extent",
                &self.scan_extent,
                "termination_character_mode",
                &self.termination_character_mode,
                "termination_characters",
                &&self.termination_characters,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for SentenceParsingOptions {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for SentenceParsingOptions {
        #[inline]
        fn eq(&self, other: &SentenceParsingOptions) -> bool {
            self.scan_extent == other.scan_extent
                && self.termination_character_mode == other.termination_character_mode
                && self.termination_characters == other.termination_characters
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for SentenceParsingOptions {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "SentenceParsingOptions",
                    false as usize + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "scan_extent",
                    &self.scan_extent,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "termination_character_mode",
                    &self.termination_character_mode,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "termination_characters",
                    &self.termination_characters,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for SentenceParsingOptions {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "scan_extent" => _serde::__private::Ok(__Field::__field0),
                            "termination_character_mode" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            "termination_characters" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"scan_extent" => _serde::__private::Ok(__Field::__field0),
                            b"termination_character_mode" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            b"termination_characters" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<SentenceParsingOptions>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = SentenceParsingOptions;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct SentenceParsingOptions",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            u16,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct SentenceParsingOptions with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            SentenceTerminationCharacterMode,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct SentenceParsingOptions with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            Vec<SentenceParsingTerminationCharacterOption>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct SentenceParsingOptions with 3 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(SentenceParsingOptions {
                            scan_extent: __field0,
                            termination_character_mode: __field1,
                            termination_characters: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<u16> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            SentenceTerminationCharacterMode,
                        > = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<
                            Vec<SentenceParsingTerminationCharacterOption>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "scan_extent",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u16>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "termination_character_mode",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            SentenceTerminationCharacterMode,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "termination_characters",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<SentenceParsingTerminationCharacterOption>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("scan_extent")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "termination_character_mode",
                                )?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "termination_characters",
                                )?
                            }
                        };
                        _serde::__private::Ok(SentenceParsingOptions {
                            scan_extent: __field0,
                            termination_character_mode: __field1,
                            termination_characters: __field2,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "scan_extent",
                    "termination_character_mode",
                    "termination_characters",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "SentenceParsingOptions",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<SentenceParsingOptions>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for SentenceParsingOptions {
        #[inline]
        fn default() -> SentenceParsingOptions {
            SentenceParsingOptions {
                scan_extent: ::core::default::Default::default(),
                termination_character_mode: ::core::default::Default::default(),
                termination_characters: ::core::default::Default::default(),
            }
        }
    }
    pub struct SentenceParsingTerminationCharacterOption {
        pub enabled: bool,
        pub character1: String,
        pub character2: Option<String>,
        pub include_character_at_start: bool,
        pub include_character_at_end: bool,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for SentenceParsingTerminationCharacterOption {
        #[inline]
        fn clone(&self) -> SentenceParsingTerminationCharacterOption {
            SentenceParsingTerminationCharacterOption {
                enabled: ::core::clone::Clone::clone(&self.enabled),
                character1: ::core::clone::Clone::clone(&self.character1),
                character2: ::core::clone::Clone::clone(&self.character2),
                include_character_at_start: ::core::clone::Clone::clone(
                    &self.include_character_at_start,
                ),
                include_character_at_end: ::core::clone::Clone::clone(
                    &self.include_character_at_end,
                ),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for SentenceParsingTerminationCharacterOption {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "SentenceParsingTerminationCharacterOption",
                "enabled",
                &self.enabled,
                "character1",
                &self.character1,
                "character2",
                &self.character2,
                "include_character_at_start",
                &self.include_character_at_start,
                "include_character_at_end",
                &&self.include_character_at_end,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq
    for SentenceParsingTerminationCharacterOption {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for SentenceParsingTerminationCharacterOption {
        #[inline]
        fn eq(&self, other: &SentenceParsingTerminationCharacterOption) -> bool {
            self.enabled == other.enabled && self.character1 == other.character1
                && self.character2 == other.character2
                && self.include_character_at_start == other.include_character_at_start
                && self.include_character_at_end == other.include_character_at_end
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for SentenceParsingTerminationCharacterOption {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "SentenceParsingTerminationCharacterOption",
                    false as usize + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "enabled",
                    &self.enabled,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "character1",
                    &self.character1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "character2",
                    &self.character2,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "include_character_at_start",
                    &self.include_character_at_start,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "include_character_at_end",
                    &self.include_character_at_end,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de>
        for SentenceParsingTerminationCharacterOption {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "enabled" => _serde::__private::Ok(__Field::__field0),
                            "character1" => _serde::__private::Ok(__Field::__field1),
                            "character2" => _serde::__private::Ok(__Field::__field2),
                            "include_character_at_start" => {
                                _serde::__private::Ok(__Field::__field3)
                            }
                            "include_character_at_end" => {
                                _serde::__private::Ok(__Field::__field4)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"enabled" => _serde::__private::Ok(__Field::__field0),
                            b"character1" => _serde::__private::Ok(__Field::__field1),
                            b"character2" => _serde::__private::Ok(__Field::__field2),
                            b"include_character_at_start" => {
                                _serde::__private::Ok(__Field::__field3)
                            }
                            b"include_character_at_end" => {
                                _serde::__private::Ok(__Field::__field4)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<
                        SentenceParsingTerminationCharacterOption,
                    >,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = SentenceParsingTerminationCharacterOption;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct SentenceParsingTerminationCharacterOption",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct SentenceParsingTerminationCharacterOption with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct SentenceParsingTerminationCharacterOption with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct SentenceParsingTerminationCharacterOption with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct SentenceParsingTerminationCharacterOption with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct SentenceParsingTerminationCharacterOption with 5 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(SentenceParsingTerminationCharacterOption {
                            enabled: __field0,
                            character1: __field1,
                            character2: __field2,
                            include_character_at_start: __field3,
                            include_character_at_end: __field4,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<bool> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "enabled",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "character1",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "character2",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "include_character_at_start",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "include_character_at_end",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("enabled")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("character1")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("character2")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "include_character_at_start",
                                )?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "include_character_at_end",
                                )?
                            }
                        };
                        _serde::__private::Ok(SentenceParsingTerminationCharacterOption {
                            enabled: __field0,
                            character1: __field1,
                            character2: __field2,
                            include_character_at_start: __field3,
                            include_character_at_end: __field4,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "enabled",
                    "character1",
                    "character2",
                    "include_character_at_start",
                    "include_character_at_end",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "SentenceParsingTerminationCharacterOption",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            SentenceParsingTerminationCharacterOption,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for SentenceParsingTerminationCharacterOption {
        #[inline]
        fn default() -> SentenceParsingTerminationCharacterOption {
            SentenceParsingTerminationCharacterOption {
                enabled: ::core::default::Default::default(),
                character1: ::core::default::Default::default(),
                character2: ::core::default::Default::default(),
                include_character_at_start: ::core::default::Default::default(),
                include_character_at_end: ::core::default::Default::default(),
            }
        }
    }
    pub struct InputsOptions {
        pub hotkeys: Vec<InputsHotkeyOptions>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for InputsOptions {
        #[inline]
        fn clone(&self) -> InputsOptions {
            InputsOptions {
                hotkeys: ::core::clone::Clone::clone(&self.hotkeys),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for InputsOptions {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "InputsOptions",
                "hotkeys",
                &&self.hotkeys,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for InputsOptions {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for InputsOptions {
        #[inline]
        fn eq(&self, other: &InputsOptions) -> bool {
            self.hotkeys == other.hotkeys
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for InputsOptions {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "InputsOptions",
                    false as usize + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "hotkeys",
                    &self.hotkeys,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for InputsOptions {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "hotkeys" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"hotkeys" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<InputsOptions>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = InputsOptions;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct InputsOptions",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            Vec<InputsHotkeyOptions>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct InputsOptions with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(InputsOptions { hotkeys: __field0 })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            Vec<InputsHotkeyOptions>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "hotkeys",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<InputsHotkeyOptions>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("hotkeys")?
                            }
                        };
                        _serde::__private::Ok(InputsOptions { hotkeys: __field0 })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["hotkeys"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "InputsOptions",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<InputsOptions>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for InputsOptions {
        #[inline]
        fn default() -> InputsOptions {
            InputsOptions {
                hotkeys: ::core::default::Default::default(),
            }
        }
    }
    pub struct InputsHotkeyOptions {
        pub action: String,
        pub argument: String,
        pub key: Option<String>,
        pub modifiers: Vec<InputsHotkeyModifier>,
        pub scopes: Vec<InputsHotkeyScope>,
        pub enabled: bool,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for InputsHotkeyOptions {
        #[inline]
        fn clone(&self) -> InputsHotkeyOptions {
            InputsHotkeyOptions {
                action: ::core::clone::Clone::clone(&self.action),
                argument: ::core::clone::Clone::clone(&self.argument),
                key: ::core::clone::Clone::clone(&self.key),
                modifiers: ::core::clone::Clone::clone(&self.modifiers),
                scopes: ::core::clone::Clone::clone(&self.scopes),
                enabled: ::core::clone::Clone::clone(&self.enabled),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for InputsHotkeyOptions {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "action",
                "argument",
                "key",
                "modifiers",
                "scopes",
                "enabled",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.action,
                &self.argument,
                &self.key,
                &self.modifiers,
                &self.scopes,
                &&self.enabled,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "InputsHotkeyOptions",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for InputsHotkeyOptions {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for InputsHotkeyOptions {
        #[inline]
        fn eq(&self, other: &InputsHotkeyOptions) -> bool {
            self.action == other.action && self.argument == other.argument
                && self.key == other.key && self.modifiers == other.modifiers
                && self.scopes == other.scopes && self.enabled == other.enabled
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for InputsHotkeyOptions {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "InputsHotkeyOptions",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "action",
                    &self.action,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "argument",
                    &self.argument,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "key",
                    &self.key,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "modifiers",
                    &self.modifiers,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "scopes",
                    &self.scopes,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "enabled",
                    &self.enabled,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for InputsHotkeyOptions {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "action" => _serde::__private::Ok(__Field::__field0),
                            "argument" => _serde::__private::Ok(__Field::__field1),
                            "key" => _serde::__private::Ok(__Field::__field2),
                            "modifiers" => _serde::__private::Ok(__Field::__field3),
                            "scopes" => _serde::__private::Ok(__Field::__field4),
                            "enabled" => _serde::__private::Ok(__Field::__field5),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"action" => _serde::__private::Ok(__Field::__field0),
                            b"argument" => _serde::__private::Ok(__Field::__field1),
                            b"key" => _serde::__private::Ok(__Field::__field2),
                            b"modifiers" => _serde::__private::Ok(__Field::__field3),
                            b"scopes" => _serde::__private::Ok(__Field::__field4),
                            b"enabled" => _serde::__private::Ok(__Field::__field5),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<InputsHotkeyOptions>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = InputsHotkeyOptions;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct InputsHotkeyOptions",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct InputsHotkeyOptions with 6 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct InputsHotkeyOptions with 6 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct InputsHotkeyOptions with 6 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            Vec<InputsHotkeyModifier>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct InputsHotkeyOptions with 6 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            Vec<InputsHotkeyScope>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct InputsHotkeyOptions with 6 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct InputsHotkeyOptions with 6 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(InputsHotkeyOptions {
                            action: __field0,
                            argument: __field1,
                            key: __field2,
                            modifiers: __field3,
                            scopes: __field4,
                            enabled: __field5,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<
                            Vec<InputsHotkeyModifier>,
                        > = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<
                            Vec<InputsHotkeyScope>,
                        > = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<bool> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("action"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "argument",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("key"),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "modifiers",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<InputsHotkeyModifier>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("scopes"),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<InputsHotkeyScope>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "enabled",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("action")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("argument")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("key")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("modifiers")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("scopes")?
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("enabled")?
                            }
                        };
                        _serde::__private::Ok(InputsHotkeyOptions {
                            action: __field0,
                            argument: __field1,
                            key: __field2,
                            modifiers: __field3,
                            scopes: __field4,
                            enabled: __field5,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "action",
                    "argument",
                    "key",
                    "modifiers",
                    "scopes",
                    "enabled",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "InputsHotkeyOptions",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<InputsHotkeyOptions>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for InputsHotkeyOptions {
        #[inline]
        fn default() -> InputsHotkeyOptions {
            InputsHotkeyOptions {
                action: ::core::default::Default::default(),
                argument: ::core::default::Default::default(),
                key: ::core::default::Default::default(),
                modifiers: ::core::default::Default::default(),
                scopes: ::core::default::Default::default(),
                enabled: ::core::default::Default::default(),
            }
        }
    }
    pub struct ClipboardOptions {
        pub enable_background_monitor: bool,
        pub enable_search_page_monitor: bool,
        pub auto_search_content: bool,
        /// Limit the number of characters used when searching clipboard text.
        pub maximum_search_length: u16,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ClipboardOptions {
        #[inline]
        fn clone(&self) -> ClipboardOptions {
            ClipboardOptions {
                enable_background_monitor: ::core::clone::Clone::clone(
                    &self.enable_background_monitor,
                ),
                enable_search_page_monitor: ::core::clone::Clone::clone(
                    &self.enable_search_page_monitor,
                ),
                auto_search_content: ::core::clone::Clone::clone(
                    &self.auto_search_content,
                ),
                maximum_search_length: ::core::clone::Clone::clone(
                    &self.maximum_search_length,
                ),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ClipboardOptions {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "ClipboardOptions",
                "enable_background_monitor",
                &self.enable_background_monitor,
                "enable_search_page_monitor",
                &self.enable_search_page_monitor,
                "auto_search_content",
                &self.auto_search_content,
                "maximum_search_length",
                &&self.maximum_search_length,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ClipboardOptions {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ClipboardOptions {
        #[inline]
        fn eq(&self, other: &ClipboardOptions) -> bool {
            self.enable_background_monitor == other.enable_background_monitor
                && self.enable_search_page_monitor == other.enable_search_page_monitor
                && self.auto_search_content == other.auto_search_content
                && self.maximum_search_length == other.maximum_search_length
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ClipboardOptions {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "ClipboardOptions",
                    false as usize + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "enable_background_monitor",
                    &self.enable_background_monitor,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "enable_search_page_monitor",
                    &self.enable_search_page_monitor,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "auto_search_content",
                    &self.auto_search_content,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "maximum_search_length",
                    &self.maximum_search_length,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ClipboardOptions {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "enable_background_monitor" => {
                                _serde::__private::Ok(__Field::__field0)
                            }
                            "enable_search_page_monitor" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            "auto_search_content" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            "maximum_search_length" => {
                                _serde::__private::Ok(__Field::__field3)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"enable_background_monitor" => {
                                _serde::__private::Ok(__Field::__field0)
                            }
                            b"enable_search_page_monitor" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            b"auto_search_content" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            b"maximum_search_length" => {
                                _serde::__private::Ok(__Field::__field3)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ClipboardOptions>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ClipboardOptions;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct ClipboardOptions",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct ClipboardOptions with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct ClipboardOptions with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct ClipboardOptions with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            u16,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct ClipboardOptions with 4 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(ClipboardOptions {
                            enable_background_monitor: __field0,
                            enable_search_page_monitor: __field1,
                            auto_search_content: __field2,
                            maximum_search_length: __field3,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<u16> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "enable_background_monitor",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "enable_search_page_monitor",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "auto_search_content",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "maximum_search_length",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u16>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "enable_background_monitor",
                                )?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "enable_search_page_monitor",
                                )?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("auto_search_content")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "maximum_search_length",
                                )?
                            }
                        };
                        _serde::__private::Ok(ClipboardOptions {
                            enable_background_monitor: __field0,
                            enable_search_page_monitor: __field1,
                            auto_search_content: __field2,
                            maximum_search_length: __field3,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "enable_background_monitor",
                    "enable_search_page_monitor",
                    "auto_search_content",
                    "maximum_search_length",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ClipboardOptions",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ClipboardOptions>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for ClipboardOptions {
        #[inline]
        fn default() -> ClipboardOptions {
            ClipboardOptions {
                enable_background_monitor: ::core::default::Default::default(),
                enable_search_page_monitor: ::core::default::Default::default(),
                auto_search_content: ::core::default::Default::default(),
                maximum_search_length: ::core::default::Default::default(),
            }
        }
    }
    pub struct AccessibilityOptions {
        pub force_google_docs_html_rendering: bool,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for AccessibilityOptions {
        #[inline]
        fn clone(&self) -> AccessibilityOptions {
            AccessibilityOptions {
                force_google_docs_html_rendering: ::core::clone::Clone::clone(
                    &self.force_google_docs_html_rendering,
                ),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for AccessibilityOptions {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "AccessibilityOptions",
                "force_google_docs_html_rendering",
                &&self.force_google_docs_html_rendering,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for AccessibilityOptions {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for AccessibilityOptions {
        #[inline]
        fn eq(&self, other: &AccessibilityOptions) -> bool {
            self.force_google_docs_html_rendering
                == other.force_google_docs_html_rendering
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for AccessibilityOptions {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "AccessibilityOptions",
                    false as usize + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "force_google_docs_html_rendering",
                    &self.force_google_docs_html_rendering,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for AccessibilityOptions {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "force_google_docs_html_rendering" => {
                                _serde::__private::Ok(__Field::__field0)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"force_google_docs_html_rendering" => {
                                _serde::__private::Ok(__Field::__field0)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<AccessibilityOptions>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = AccessibilityOptions;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct AccessibilityOptions",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct AccessibilityOptions with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(AccessibilityOptions {
                            force_google_docs_html_rendering: __field0,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<bool> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "force_google_docs_html_rendering",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "force_google_docs_html_rendering",
                                )?
                            }
                        };
                        _serde::__private::Ok(AccessibilityOptions {
                            force_google_docs_html_rendering: __field0,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "force_google_docs_html_rendering",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "AccessibilityOptions",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<AccessibilityOptions>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for AccessibilityOptions {
        #[inline]
        fn default() -> AccessibilityOptions {
            AccessibilityOptions {
                force_google_docs_html_rendering: ::core::default::Default::default(),
            }
        }
    }
    pub struct PreventMiddleMouseOptions {
        pub on_web_pages: bool,
        pub on_popup_pages: bool,
        pub on_search_pages: bool,
        pub on_search_query: bool,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for PreventMiddleMouseOptions {
        #[inline]
        fn clone(&self) -> PreventMiddleMouseOptions {
            PreventMiddleMouseOptions {
                on_web_pages: ::core::clone::Clone::clone(&self.on_web_pages),
                on_popup_pages: ::core::clone::Clone::clone(&self.on_popup_pages),
                on_search_pages: ::core::clone::Clone::clone(&self.on_search_pages),
                on_search_query: ::core::clone::Clone::clone(&self.on_search_query),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for PreventMiddleMouseOptions {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "PreventMiddleMouseOptions",
                "on_web_pages",
                &self.on_web_pages,
                "on_popup_pages",
                &self.on_popup_pages,
                "on_search_pages",
                &self.on_search_pages,
                "on_search_query",
                &&self.on_search_query,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for PreventMiddleMouseOptions {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for PreventMiddleMouseOptions {
        #[inline]
        fn eq(&self, other: &PreventMiddleMouseOptions) -> bool {
            self.on_web_pages == other.on_web_pages
                && self.on_popup_pages == other.on_popup_pages
                && self.on_search_pages == other.on_search_pages
                && self.on_search_query == other.on_search_query
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for PreventMiddleMouseOptions {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "PreventMiddleMouseOptions",
                    false as usize + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "on_web_pages",
                    &self.on_web_pages,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "on_popup_pages",
                    &self.on_popup_pages,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "on_search_pages",
                    &self.on_search_pages,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "on_search_query",
                    &self.on_search_query,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for PreventMiddleMouseOptions {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "on_web_pages" => _serde::__private::Ok(__Field::__field0),
                            "on_popup_pages" => _serde::__private::Ok(__Field::__field1),
                            "on_search_pages" => _serde::__private::Ok(__Field::__field2),
                            "on_search_query" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"on_web_pages" => _serde::__private::Ok(__Field::__field0),
                            b"on_popup_pages" => _serde::__private::Ok(__Field::__field1),
                            b"on_search_pages" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            b"on_search_query" => {
                                _serde::__private::Ok(__Field::__field3)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<PreventMiddleMouseOptions>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = PreventMiddleMouseOptions;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct PreventMiddleMouseOptions",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct PreventMiddleMouseOptions with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct PreventMiddleMouseOptions with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct PreventMiddleMouseOptions with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct PreventMiddleMouseOptions with 4 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(PreventMiddleMouseOptions {
                            on_web_pages: __field0,
                            on_popup_pages: __field1,
                            on_search_pages: __field2,
                            on_search_query: __field3,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<bool> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "on_web_pages",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "on_popup_pages",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "on_search_pages",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "on_search_query",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("on_web_pages")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("on_popup_pages")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("on_search_pages")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("on_search_query")?
                            }
                        };
                        _serde::__private::Ok(PreventMiddleMouseOptions {
                            on_web_pages: __field0,
                            on_popup_pages: __field1,
                            on_search_pages: __field2,
                            on_search_query: __field3,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "on_web_pages",
                    "on_popup_pages",
                    "on_search_pages",
                    "on_search_query",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "PreventMiddleMouseOptions",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            PreventMiddleMouseOptions,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for PreventMiddleMouseOptions {
        #[inline]
        fn default() -> PreventMiddleMouseOptions {
            PreventMiddleMouseOptions {
                on_web_pages: ::core::default::Default::default(),
                on_popup_pages: ::core::default::Default::default(),
                on_search_pages: ::core::default::Default::default(),
                on_search_query: ::core::default::Default::default(),
            }
        }
    }
    /// Change how related results are grouped.
    ///
    /// The Primary dictionary option should be assigned to a
    /// dictionary which contains related term information,
    /// and configuring the Secondary dictionaries will allow definitions for the
    /// related terms to be included from other dictionaries.
    ///
    /// _Not all dictionaries are able to be selected as the Primary dictionary_.
    pub enum ResultOutputMode {
        /// No grouping.
        ///
        /// Every definition will be listed as a separate entry.
        Split,
        /// Group term-reading pairs.
        ///
        /// Definitions for the same term with the same reading will be grouped together.
        #[default]
        Group,
        /// Group related terms.
        ///
        /// Related terms that share the same definitions will be grouped together.
        Merge,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ResultOutputMode {
        #[inline]
        fn clone(&self) -> ResultOutputMode {
            match self {
                ResultOutputMode::Split => ResultOutputMode::Split,
                ResultOutputMode::Group => ResultOutputMode::Group,
                ResultOutputMode::Merge => ResultOutputMode::Merge,
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ResultOutputMode {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    ResultOutputMode::Split => "Split",
                    ResultOutputMode::Group => "Group",
                    ResultOutputMode::Merge => "Merge",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ResultOutputMode {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ResultOutputMode {
        #[inline]
        fn eq(&self, other: &ResultOutputMode) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ResultOutputMode {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    ResultOutputMode::Split => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ResultOutputMode",
                            0u32,
                            "Split",
                        )
                    }
                    ResultOutputMode::Group => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ResultOutputMode",
                            1u32,
                            "Group",
                        )
                    }
                    ResultOutputMode::Merge => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ResultOutputMode",
                            2u32,
                            "Merge",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ResultOutputMode {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 3",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Split" => _serde::__private::Ok(__Field::__field0),
                            "Group" => _serde::__private::Ok(__Field::__field1),
                            "Merge" => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Split" => _serde::__private::Ok(__Field::__field0),
                            b"Group" => _serde::__private::Ok(__Field::__field1),
                            b"Merge" => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ResultOutputMode>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ResultOutputMode;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum ResultOutputMode",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(ResultOutputMode::Split)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(ResultOutputMode::Group)
                            }
                            (__Field::__field2, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(ResultOutputMode::Merge)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["Split", "Group", "Merge"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "ResultOutputMode",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ResultOutputMode>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for ResultOutputMode {
        #[inline]
        fn default() -> ResultOutputMode {
            Self::Group
        }
    }
    /// Change the layout of the popup.
    ///
    /// The `Default` mode will position the popup relative to the scanned text.
    /// The `Full Width` mode will anchor the popup to the top or bottom of the screen and
    /// take up the full width of the screen, which can be useful on devices with touch screens.
    pub enum PopupDisplayMode {
        #[default]
        Default,
        FullWidth,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for PopupDisplayMode {
        #[inline]
        fn clone(&self) -> PopupDisplayMode {
            match self {
                PopupDisplayMode::Default => PopupDisplayMode::Default,
                PopupDisplayMode::FullWidth => PopupDisplayMode::FullWidth,
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for PopupDisplayMode {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    PopupDisplayMode::Default => "Default",
                    PopupDisplayMode::FullWidth => "FullWidth",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for PopupDisplayMode {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for PopupDisplayMode {
        #[inline]
        fn eq(&self, other: &PopupDisplayMode) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for PopupDisplayMode {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    PopupDisplayMode::Default => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "PopupDisplayMode",
                            0u32,
                            "Default",
                        )
                    }
                    PopupDisplayMode::FullWidth => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "PopupDisplayMode",
                            1u32,
                            "FullWidth",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for PopupDisplayMode {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 2",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Default" => _serde::__private::Ok(__Field::__field0),
                            "FullWidth" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Default" => _serde::__private::Ok(__Field::__field0),
                            b"FullWidth" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<PopupDisplayMode>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = PopupDisplayMode;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum PopupDisplayMode",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(PopupDisplayMode::Default)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(PopupDisplayMode::FullWidth)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["Default", "FullWidth"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "PopupDisplayMode",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<PopupDisplayMode>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for PopupDisplayMode {
        #[inline]
        fn default() -> PopupDisplayMode {
            Self::Default
        }
    }
    /// Change where the popup is positioned relative to horizontal text.
    pub enum PopupHorizontalTextPosition {
        #[default]
        Below,
        Above,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for PopupHorizontalTextPosition {
        #[inline]
        fn clone(&self) -> PopupHorizontalTextPosition {
            match self {
                PopupHorizontalTextPosition::Below => PopupHorizontalTextPosition::Below,
                PopupHorizontalTextPosition::Above => PopupHorizontalTextPosition::Above,
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for PopupHorizontalTextPosition {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    PopupHorizontalTextPosition::Below => "Below",
                    PopupHorizontalTextPosition::Above => "Above",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for PopupHorizontalTextPosition {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for PopupHorizontalTextPosition {
        #[inline]
        fn eq(&self, other: &PopupHorizontalTextPosition) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for PopupHorizontalTextPosition {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    PopupHorizontalTextPosition::Below => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "PopupHorizontalTextPosition",
                            0u32,
                            "Below",
                        )
                    }
                    PopupHorizontalTextPosition::Above => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "PopupHorizontalTextPosition",
                            1u32,
                            "Above",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for PopupHorizontalTextPosition {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 2",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Below" => _serde::__private::Ok(__Field::__field0),
                            "Above" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Below" => _serde::__private::Ok(__Field::__field0),
                            b"Above" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<PopupHorizontalTextPosition>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = PopupHorizontalTextPosition;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum PopupHorizontalTextPosition",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(PopupHorizontalTextPosition::Below)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(PopupHorizontalTextPosition::Above)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["Below", "Above"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "PopupHorizontalTextPosition",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            PopupHorizontalTextPosition,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for PopupHorizontalTextPosition {
        #[inline]
        fn default() -> PopupHorizontalTextPosition {
            Self::Below
        }
    }
    /// Change where the popup is positioned relative to vertical text.
    pub enum PopupVerticalTextPosition {
        #[default]
        Before,
        After,
        Left,
        Right,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for PopupVerticalTextPosition {
        #[inline]
        fn clone(&self) -> PopupVerticalTextPosition {
            match self {
                PopupVerticalTextPosition::Before => PopupVerticalTextPosition::Before,
                PopupVerticalTextPosition::After => PopupVerticalTextPosition::After,
                PopupVerticalTextPosition::Left => PopupVerticalTextPosition::Left,
                PopupVerticalTextPosition::Right => PopupVerticalTextPosition::Right,
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for PopupVerticalTextPosition {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    PopupVerticalTextPosition::Before => "Before",
                    PopupVerticalTextPosition::After => "After",
                    PopupVerticalTextPosition::Left => "Left",
                    PopupVerticalTextPosition::Right => "Right",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for PopupVerticalTextPosition {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for PopupVerticalTextPosition {
        #[inline]
        fn eq(&self, other: &PopupVerticalTextPosition) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for PopupVerticalTextPosition {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    PopupVerticalTextPosition::Before => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "PopupVerticalTextPosition",
                            0u32,
                            "Before",
                        )
                    }
                    PopupVerticalTextPosition::After => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "PopupVerticalTextPosition",
                            1u32,
                            "After",
                        )
                    }
                    PopupVerticalTextPosition::Left => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "PopupVerticalTextPosition",
                            2u32,
                            "Left",
                        )
                    }
                    PopupVerticalTextPosition::Right => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "PopupVerticalTextPosition",
                            3u32,
                            "Right",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for PopupVerticalTextPosition {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 4",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Before" => _serde::__private::Ok(__Field::__field0),
                            "After" => _serde::__private::Ok(__Field::__field1),
                            "Left" => _serde::__private::Ok(__Field::__field2),
                            "Right" => _serde::__private::Ok(__Field::__field3),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Before" => _serde::__private::Ok(__Field::__field0),
                            b"After" => _serde::__private::Ok(__Field::__field1),
                            b"Left" => _serde::__private::Ok(__Field::__field2),
                            b"Right" => _serde::__private::Ok(__Field::__field3),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<PopupVerticalTextPosition>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = PopupVerticalTextPosition;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum PopupVerticalTextPosition",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(PopupVerticalTextPosition::Before)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(PopupVerticalTextPosition::After)
                            }
                            (__Field::__field2, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(PopupVerticalTextPosition::Left)
                            }
                            (__Field::__field3, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(PopupVerticalTextPosition::Right)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "Before",
                    "After",
                    "Left",
                    "Right",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "PopupVerticalTextPosition",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            PopupVerticalTextPosition,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for PopupVerticalTextPosition {
        #[inline]
        fn default() -> PopupVerticalTextPosition {
            Self::Before
        }
    }
    /// Adjust the main style.
    pub enum PopupTheme {
        Light,
        #[default]
        Dark,
        System,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for PopupTheme {
        #[inline]
        fn clone(&self) -> PopupTheme {
            match self {
                PopupTheme::Light => PopupTheme::Light,
                PopupTheme::Dark => PopupTheme::Dark,
                PopupTheme::System => PopupTheme::System,
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for PopupTheme {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    PopupTheme::Light => "Light",
                    PopupTheme::Dark => "Dark",
                    PopupTheme::System => "System",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for PopupTheme {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for PopupTheme {
        #[inline]
        fn eq(&self, other: &PopupTheme) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for PopupTheme {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    PopupTheme::Light => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "PopupTheme",
                            0u32,
                            "Light",
                        )
                    }
                    PopupTheme::Dark => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "PopupTheme",
                            1u32,
                            "Dark",
                        )
                    }
                    PopupTheme::System => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "PopupTheme",
                            2u32,
                            "System",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for PopupTheme {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 3",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Light" => _serde::__private::Ok(__Field::__field0),
                            "Dark" => _serde::__private::Ok(__Field::__field1),
                            "System" => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Light" => _serde::__private::Ok(__Field::__field0),
                            b"Dark" => _serde::__private::Ok(__Field::__field1),
                            b"System" => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<PopupTheme>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = PopupTheme;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum PopupTheme",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(PopupTheme::Light)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(PopupTheme::Dark)
                            }
                            (__Field::__field2, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(PopupTheme::System)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["Light", "Dark", "System"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "PopupTheme",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<PopupTheme>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for PopupTheme {
        #[inline]
        fn default() -> PopupTheme {
            Self::Dark
        }
    }
    /// Control when the action bar is visible.
    pub enum PopupActionBarVisibility {
        #[default]
        Auto,
        Always,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for PopupActionBarVisibility {
        #[inline]
        fn clone(&self) -> PopupActionBarVisibility {
            match self {
                PopupActionBarVisibility::Auto => PopupActionBarVisibility::Auto,
                PopupActionBarVisibility::Always => PopupActionBarVisibility::Always,
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for PopupActionBarVisibility {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    PopupActionBarVisibility::Auto => "Auto",
                    PopupActionBarVisibility::Always => "Always",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for PopupActionBarVisibility {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for PopupActionBarVisibility {
        #[inline]
        fn eq(&self, other: &PopupActionBarVisibility) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for PopupActionBarVisibility {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    PopupActionBarVisibility::Auto => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "PopupActionBarVisibility",
                            0u32,
                            "Auto",
                        )
                    }
                    PopupActionBarVisibility::Always => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "PopupActionBarVisibility",
                            1u32,
                            "Always",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for PopupActionBarVisibility {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 2",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Auto" => _serde::__private::Ok(__Field::__field0),
                            "Always" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Auto" => _serde::__private::Ok(__Field::__field0),
                            b"Always" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<PopupActionBarVisibility>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = PopupActionBarVisibility;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum PopupActionBarVisibility",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(PopupActionBarVisibility::Auto)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(PopupActionBarVisibility::Always)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["Auto", "Always"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "PopupActionBarVisibility",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            PopupActionBarVisibility,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for PopupActionBarVisibility {
        #[inline]
        fn default() -> PopupActionBarVisibility {
            Self::Auto
        }
    }
    /// Control where the action bar is visible.
    pub enum PopupActionBarLocation {
        #[default]
        Top,
        Right,
        Bottom,
        Left,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for PopupActionBarLocation {
        #[inline]
        fn clone(&self) -> PopupActionBarLocation {
            match self {
                PopupActionBarLocation::Top => PopupActionBarLocation::Top,
                PopupActionBarLocation::Right => PopupActionBarLocation::Right,
                PopupActionBarLocation::Bottom => PopupActionBarLocation::Bottom,
                PopupActionBarLocation::Left => PopupActionBarLocation::Left,
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for PopupActionBarLocation {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    PopupActionBarLocation::Top => "Top",
                    PopupActionBarLocation::Right => "Right",
                    PopupActionBarLocation::Bottom => "Bottom",
                    PopupActionBarLocation::Left => "Left",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for PopupActionBarLocation {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for PopupActionBarLocation {
        #[inline]
        fn eq(&self, other: &PopupActionBarLocation) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for PopupActionBarLocation {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    PopupActionBarLocation::Top => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "PopupActionBarLocation",
                            0u32,
                            "Top",
                        )
                    }
                    PopupActionBarLocation::Right => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "PopupActionBarLocation",
                            1u32,
                            "Right",
                        )
                    }
                    PopupActionBarLocation::Bottom => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "PopupActionBarLocation",
                            2u32,
                            "Bottom",
                        )
                    }
                    PopupActionBarLocation::Left => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "PopupActionBarLocation",
                            3u32,
                            "Left",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for PopupActionBarLocation {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 4",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Top" => _serde::__private::Ok(__Field::__field0),
                            "Right" => _serde::__private::Ok(__Field::__field1),
                            "Bottom" => _serde::__private::Ok(__Field::__field2),
                            "Left" => _serde::__private::Ok(__Field::__field3),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Top" => _serde::__private::Ok(__Field::__field0),
                            b"Right" => _serde::__private::Ok(__Field::__field1),
                            b"Bottom" => _serde::__private::Ok(__Field::__field2),
                            b"Left" => _serde::__private::Ok(__Field::__field3),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<PopupActionBarLocation>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = PopupActionBarLocation;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum PopupActionBarLocation",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(PopupActionBarLocation::Top)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(PopupActionBarLocation::Right)
                            }
                            (__Field::__field2, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(PopupActionBarLocation::Bottom)
                            }
                            (__Field::__field3, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(PopupActionBarLocation::Left)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "Top",
                    "Right",
                    "Bottom",
                    "Left",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "PopupActionBarLocation",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<PopupActionBarLocation>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for PopupActionBarLocation {
        #[inline]
        fn default() -> PopupActionBarLocation {
            Self::Top
        }
    }
    /// Adjust the shadow style.
    pub enum PopupShadow {
        /// Casts no shadow.
        Light,
        #[default]
        /// Casts a white shadow.
        Dark,
        System,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for PopupShadow {
        #[inline]
        fn clone(&self) -> PopupShadow {
            match self {
                PopupShadow::Light => PopupShadow::Light,
                PopupShadow::Dark => PopupShadow::Dark,
                PopupShadow::System => PopupShadow::System,
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for PopupShadow {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    PopupShadow::Light => "Light",
                    PopupShadow::Dark => "Dark",
                    PopupShadow::System => "System",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for PopupShadow {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for PopupShadow {
        #[inline]
        fn eq(&self, other: &PopupShadow) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for PopupShadow {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    PopupShadow::Light => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "PopupShadow",
                            0u32,
                            "Light",
                        )
                    }
                    PopupShadow::Dark => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "PopupShadow",
                            1u32,
                            "Dark",
                        )
                    }
                    PopupShadow::System => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "PopupShadow",
                            2u32,
                            "System",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for PopupShadow {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 3",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Light" => _serde::__private::Ok(__Field::__field0),
                            "Dark" => _serde::__private::Ok(__Field::__field1),
                            "System" => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Light" => _serde::__private::Ok(__Field::__field0),
                            b"Dark" => _serde::__private::Ok(__Field::__field1),
                            b"System" => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<PopupShadow>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = PopupShadow;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum PopupShadow",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(PopupShadow::Light)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(PopupShadow::Dark)
                            }
                            (__Field::__field2, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(PopupShadow::System)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["Light", "Dark", "System"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "PopupShadow",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<PopupShadow>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for PopupShadow {
        #[inline]
        fn default() -> PopupShadow {
            Self::Dark
        }
    }
    /// Change how the selected definition entry is visually indicated.
    pub enum PopupCurrentIndicatorMode {
        None,
        Asterisk,
        Triangle,
        #[default]
        VerticalBarLeft,
        VerticalBarRight,
        DotLeft,
        DotRight,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for PopupCurrentIndicatorMode {
        #[inline]
        fn clone(&self) -> PopupCurrentIndicatorMode {
            match self {
                PopupCurrentIndicatorMode::None => PopupCurrentIndicatorMode::None,
                PopupCurrentIndicatorMode::Asterisk => {
                    PopupCurrentIndicatorMode::Asterisk
                }
                PopupCurrentIndicatorMode::Triangle => {
                    PopupCurrentIndicatorMode::Triangle
                }
                PopupCurrentIndicatorMode::VerticalBarLeft => {
                    PopupCurrentIndicatorMode::VerticalBarLeft
                }
                PopupCurrentIndicatorMode::VerticalBarRight => {
                    PopupCurrentIndicatorMode::VerticalBarRight
                }
                PopupCurrentIndicatorMode::DotLeft => PopupCurrentIndicatorMode::DotLeft,
                PopupCurrentIndicatorMode::DotRight => {
                    PopupCurrentIndicatorMode::DotRight
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for PopupCurrentIndicatorMode {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    PopupCurrentIndicatorMode::None => "None",
                    PopupCurrentIndicatorMode::Asterisk => "Asterisk",
                    PopupCurrentIndicatorMode::Triangle => "Triangle",
                    PopupCurrentIndicatorMode::VerticalBarLeft => "VerticalBarLeft",
                    PopupCurrentIndicatorMode::VerticalBarRight => "VerticalBarRight",
                    PopupCurrentIndicatorMode::DotLeft => "DotLeft",
                    PopupCurrentIndicatorMode::DotRight => "DotRight",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for PopupCurrentIndicatorMode {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for PopupCurrentIndicatorMode {
        #[inline]
        fn eq(&self, other: &PopupCurrentIndicatorMode) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for PopupCurrentIndicatorMode {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    PopupCurrentIndicatorMode::None => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "PopupCurrentIndicatorMode",
                            0u32,
                            "None",
                        )
                    }
                    PopupCurrentIndicatorMode::Asterisk => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "PopupCurrentIndicatorMode",
                            1u32,
                            "Asterisk",
                        )
                    }
                    PopupCurrentIndicatorMode::Triangle => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "PopupCurrentIndicatorMode",
                            2u32,
                            "Triangle",
                        )
                    }
                    PopupCurrentIndicatorMode::VerticalBarLeft => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "PopupCurrentIndicatorMode",
                            3u32,
                            "VerticalBarLeft",
                        )
                    }
                    PopupCurrentIndicatorMode::VerticalBarRight => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "PopupCurrentIndicatorMode",
                            4u32,
                            "VerticalBarRight",
                        )
                    }
                    PopupCurrentIndicatorMode::DotLeft => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "PopupCurrentIndicatorMode",
                            5u32,
                            "DotLeft",
                        )
                    }
                    PopupCurrentIndicatorMode::DotRight => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "PopupCurrentIndicatorMode",
                            6u32,
                            "DotRight",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for PopupCurrentIndicatorMode {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 7",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "None" => _serde::__private::Ok(__Field::__field0),
                            "Asterisk" => _serde::__private::Ok(__Field::__field1),
                            "Triangle" => _serde::__private::Ok(__Field::__field2),
                            "VerticalBarLeft" => _serde::__private::Ok(__Field::__field3),
                            "VerticalBarRight" => {
                                _serde::__private::Ok(__Field::__field4)
                            }
                            "DotLeft" => _serde::__private::Ok(__Field::__field5),
                            "DotRight" => _serde::__private::Ok(__Field::__field6),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"None" => _serde::__private::Ok(__Field::__field0),
                            b"Asterisk" => _serde::__private::Ok(__Field::__field1),
                            b"Triangle" => _serde::__private::Ok(__Field::__field2),
                            b"VerticalBarLeft" => {
                                _serde::__private::Ok(__Field::__field3)
                            }
                            b"VerticalBarRight" => {
                                _serde::__private::Ok(__Field::__field4)
                            }
                            b"DotLeft" => _serde::__private::Ok(__Field::__field5),
                            b"DotRight" => _serde::__private::Ok(__Field::__field6),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<PopupCurrentIndicatorMode>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = PopupCurrentIndicatorMode;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum PopupCurrentIndicatorMode",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(PopupCurrentIndicatorMode::None)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(PopupCurrentIndicatorMode::Asterisk)
                            }
                            (__Field::__field2, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(PopupCurrentIndicatorMode::Triangle)
                            }
                            (__Field::__field3, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(
                                    PopupCurrentIndicatorMode::VerticalBarLeft,
                                )
                            }
                            (__Field::__field4, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(
                                    PopupCurrentIndicatorMode::VerticalBarRight,
                                )
                            }
                            (__Field::__field5, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(PopupCurrentIndicatorMode::DotLeft)
                            }
                            (__Field::__field6, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(PopupCurrentIndicatorMode::DotRight)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "None",
                    "Asterisk",
                    "Triangle",
                    "VerticalBarLeft",
                    "VerticalBarRight",
                    "DotLeft",
                    "DotRight",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "PopupCurrentIndicatorMode",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            PopupCurrentIndicatorMode,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for PopupCurrentIndicatorMode {
        #[inline]
        fn default() -> PopupCurrentIndicatorMode {
            Self::VerticalBarLeft
        }
    }
    /// Change how frequency information is presented.
    pub enum FrequencyDisplayStyle {
        Tags,
        TagsGrouped,
        SplitTags,
        #[default]
        SplitTagsGrouped,
        InlineList,
        List,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for FrequencyDisplayStyle {
        #[inline]
        fn clone(&self) -> FrequencyDisplayStyle {
            match self {
                FrequencyDisplayStyle::Tags => FrequencyDisplayStyle::Tags,
                FrequencyDisplayStyle::TagsGrouped => FrequencyDisplayStyle::TagsGrouped,
                FrequencyDisplayStyle::SplitTags => FrequencyDisplayStyle::SplitTags,
                FrequencyDisplayStyle::SplitTagsGrouped => {
                    FrequencyDisplayStyle::SplitTagsGrouped
                }
                FrequencyDisplayStyle::InlineList => FrequencyDisplayStyle::InlineList,
                FrequencyDisplayStyle::List => FrequencyDisplayStyle::List,
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for FrequencyDisplayStyle {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    FrequencyDisplayStyle::Tags => "Tags",
                    FrequencyDisplayStyle::TagsGrouped => "TagsGrouped",
                    FrequencyDisplayStyle::SplitTags => "SplitTags",
                    FrequencyDisplayStyle::SplitTagsGrouped => "SplitTagsGrouped",
                    FrequencyDisplayStyle::InlineList => "InlineList",
                    FrequencyDisplayStyle::List => "List",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for FrequencyDisplayStyle {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for FrequencyDisplayStyle {
        #[inline]
        fn eq(&self, other: &FrequencyDisplayStyle) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for FrequencyDisplayStyle {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    FrequencyDisplayStyle::Tags => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "FrequencyDisplayStyle",
                            0u32,
                            "Tags",
                        )
                    }
                    FrequencyDisplayStyle::TagsGrouped => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "FrequencyDisplayStyle",
                            1u32,
                            "TagsGrouped",
                        )
                    }
                    FrequencyDisplayStyle::SplitTags => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "FrequencyDisplayStyle",
                            2u32,
                            "SplitTags",
                        )
                    }
                    FrequencyDisplayStyle::SplitTagsGrouped => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "FrequencyDisplayStyle",
                            3u32,
                            "SplitTagsGrouped",
                        )
                    }
                    FrequencyDisplayStyle::InlineList => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "FrequencyDisplayStyle",
                            4u32,
                            "InlineList",
                        )
                    }
                    FrequencyDisplayStyle::List => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "FrequencyDisplayStyle",
                            5u32,
                            "List",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for FrequencyDisplayStyle {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 6",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Tags" => _serde::__private::Ok(__Field::__field0),
                            "TagsGrouped" => _serde::__private::Ok(__Field::__field1),
                            "SplitTags" => _serde::__private::Ok(__Field::__field2),
                            "SplitTagsGrouped" => {
                                _serde::__private::Ok(__Field::__field3)
                            }
                            "InlineList" => _serde::__private::Ok(__Field::__field4),
                            "List" => _serde::__private::Ok(__Field::__field5),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Tags" => _serde::__private::Ok(__Field::__field0),
                            b"TagsGrouped" => _serde::__private::Ok(__Field::__field1),
                            b"SplitTags" => _serde::__private::Ok(__Field::__field2),
                            b"SplitTagsGrouped" => {
                                _serde::__private::Ok(__Field::__field3)
                            }
                            b"InlineList" => _serde::__private::Ok(__Field::__field4),
                            b"List" => _serde::__private::Ok(__Field::__field5),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<FrequencyDisplayStyle>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = FrequencyDisplayStyle;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum FrequencyDisplayStyle",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(FrequencyDisplayStyle::Tags)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(FrequencyDisplayStyle::TagsGrouped)
                            }
                            (__Field::__field2, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(FrequencyDisplayStyle::SplitTags)
                            }
                            (__Field::__field3, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(
                                    FrequencyDisplayStyle::SplitTagsGrouped,
                                )
                            }
                            (__Field::__field4, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(FrequencyDisplayStyle::InlineList)
                            }
                            (__Field::__field5, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(FrequencyDisplayStyle::List)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "Tags",
                    "TagsGrouped",
                    "SplitTags",
                    "SplitTagsGrouped",
                    "InlineList",
                    "List",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "FrequencyDisplayStyle",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<FrequencyDisplayStyle>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for FrequencyDisplayStyle {
        #[inline]
        fn default() -> FrequencyDisplayStyle {
            Self::SplitTagsGrouped
        }
    }
    /// Change how terms and their readings are displayed.
    pub enum TermDisplayStyle {
        #[default]
        Ruby,
        RubyAndReading,
        TermAndReading,
        TermOnly,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TermDisplayStyle {
        #[inline]
        fn clone(&self) -> TermDisplayStyle {
            match self {
                TermDisplayStyle::Ruby => TermDisplayStyle::Ruby,
                TermDisplayStyle::RubyAndReading => TermDisplayStyle::RubyAndReading,
                TermDisplayStyle::TermAndReading => TermDisplayStyle::TermAndReading,
                TermDisplayStyle::TermOnly => TermDisplayStyle::TermOnly,
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TermDisplayStyle {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    TermDisplayStyle::Ruby => "Ruby",
                    TermDisplayStyle::RubyAndReading => "RubyAndReading",
                    TermDisplayStyle::TermAndReading => "TermAndReading",
                    TermDisplayStyle::TermOnly => "TermOnly",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TermDisplayStyle {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TermDisplayStyle {
        #[inline]
        fn eq(&self, other: &TermDisplayStyle) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TermDisplayStyle {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    TermDisplayStyle::Ruby => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "TermDisplayStyle",
                            0u32,
                            "Ruby",
                        )
                    }
                    TermDisplayStyle::RubyAndReading => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "TermDisplayStyle",
                            1u32,
                            "RubyAndReading",
                        )
                    }
                    TermDisplayStyle::TermAndReading => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "TermDisplayStyle",
                            2u32,
                            "TermAndReading",
                        )
                    }
                    TermDisplayStyle::TermOnly => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "TermDisplayStyle",
                            3u32,
                            "TermOnly",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TermDisplayStyle {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 4",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Ruby" => _serde::__private::Ok(__Field::__field0),
                            "RubyAndReading" => _serde::__private::Ok(__Field::__field1),
                            "TermAndReading" => _serde::__private::Ok(__Field::__field2),
                            "TermOnly" => _serde::__private::Ok(__Field::__field3),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Ruby" => _serde::__private::Ok(__Field::__field0),
                            b"RubyAndReading" => _serde::__private::Ok(__Field::__field1),
                            b"TermAndReading" => _serde::__private::Ok(__Field::__field2),
                            b"TermOnly" => _serde::__private::Ok(__Field::__field3),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<TermDisplayStyle>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TermDisplayStyle;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum TermDisplayStyle",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(TermDisplayStyle::Ruby)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(TermDisplayStyle::RubyAndReading)
                            }
                            (__Field::__field2, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(TermDisplayStyle::TermAndReading)
                            }
                            (__Field::__field3, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(TermDisplayStyle::TermOnly)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "Ruby",
                    "RubyAndReading",
                    "TermAndReading",
                    "TermOnly",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "TermDisplayStyle",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<TermDisplayStyle>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for TermDisplayStyle {
        #[inline]
        fn default() -> TermDisplayStyle {
            Self::Ruby
        }
    }
    /// Frequency sorting mode
    ///
    /// Dictionary frequency data can be represented in one of two ways:
    ///
    /// `Occurrence`-based, where the frequency corresponds to a number of occurrences.
    /// - Large values indicate a more common term.
    ///
    /// `Rank`-based, where the frequency value corresponds to a ranking index.
    /// - Smaller values indicate a more common term.
    ///
    /// _`Occurrence`-based frequency dictionaries are highly discouraged, do not use them!!_
    pub enum SortFrequencyDictionaryOrder {
        Occurance,
        #[default]
        Rank,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for SortFrequencyDictionaryOrder {
        #[inline]
        fn clone(&self) -> SortFrequencyDictionaryOrder {
            match self {
                SortFrequencyDictionaryOrder::Occurance => {
                    SortFrequencyDictionaryOrder::Occurance
                }
                SortFrequencyDictionaryOrder::Rank => SortFrequencyDictionaryOrder::Rank,
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for SortFrequencyDictionaryOrder {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    SortFrequencyDictionaryOrder::Occurance => "Occurance",
                    SortFrequencyDictionaryOrder::Rank => "Rank",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for SortFrequencyDictionaryOrder {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for SortFrequencyDictionaryOrder {
        #[inline]
        fn eq(&self, other: &SortFrequencyDictionaryOrder) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for SortFrequencyDictionaryOrder {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    SortFrequencyDictionaryOrder::Occurance => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SortFrequencyDictionaryOrder",
                            0u32,
                            "Occurance",
                        )
                    }
                    SortFrequencyDictionaryOrder::Rank => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SortFrequencyDictionaryOrder",
                            1u32,
                            "Rank",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for SortFrequencyDictionaryOrder {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 2",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Occurance" => _serde::__private::Ok(__Field::__field0),
                            "Rank" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Occurance" => _serde::__private::Ok(__Field::__field0),
                            b"Rank" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<SortFrequencyDictionaryOrder>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = SortFrequencyDictionaryOrder;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum SortFrequencyDictionaryOrder",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(
                                    SortFrequencyDictionaryOrder::Occurance,
                                )
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(SortFrequencyDictionaryOrder::Rank)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["Occurance", "Rank"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "SortFrequencyDictionaryOrder",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            SortFrequencyDictionaryOrder,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for SortFrequencyDictionaryOrder {
        #[inline]
        fn default() -> SortFrequencyDictionaryOrder {
            Self::Rank
        }
    }
    /// Change the appearance of the window type.
    pub enum PopupWindowType {
        Normal,
        #[default]
        Popup,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for PopupWindowType {
        #[inline]
        fn clone(&self) -> PopupWindowType {
            match self {
                PopupWindowType::Normal => PopupWindowType::Normal,
                PopupWindowType::Popup => PopupWindowType::Popup,
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for PopupWindowType {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    PopupWindowType::Normal => "Normal",
                    PopupWindowType::Popup => "Popup",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for PopupWindowType {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for PopupWindowType {
        #[inline]
        fn eq(&self, other: &PopupWindowType) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for PopupWindowType {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    PopupWindowType::Normal => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "PopupWindowType",
                            0u32,
                            "Normal",
                        )
                    }
                    PopupWindowType::Popup => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "PopupWindowType",
                            1u32,
                            "Popup",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for PopupWindowType {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 2",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Normal" => _serde::__private::Ok(__Field::__field0),
                            "Popup" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Normal" => _serde::__private::Ok(__Field::__field0),
                            b"Popup" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<PopupWindowType>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = PopupWindowType;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum PopupWindowType",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(PopupWindowType::Normal)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(PopupWindowType::Popup)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["Normal", "Popup"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "PopupWindowType",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<PopupWindowType>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for PopupWindowType {
        #[inline]
        fn default() -> PopupWindowType {
            Self::Popup
        }
    }
    /// Change the state of the window.
    pub enum PopupWindowState {
        #[default]
        Normal,
        Maximized,
        Fullscreen,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for PopupWindowState {
        #[inline]
        fn clone(&self) -> PopupWindowState {
            match self {
                PopupWindowState::Normal => PopupWindowState::Normal,
                PopupWindowState::Maximized => PopupWindowState::Maximized,
                PopupWindowState::Fullscreen => PopupWindowState::Fullscreen,
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for PopupWindowState {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    PopupWindowState::Normal => "Normal",
                    PopupWindowState::Maximized => "Maximized",
                    PopupWindowState::Fullscreen => "Fullscreen",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for PopupWindowState {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for PopupWindowState {
        #[inline]
        fn eq(&self, other: &PopupWindowState) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for PopupWindowState {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    PopupWindowState::Normal => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "PopupWindowState",
                            0u32,
                            "Normal",
                        )
                    }
                    PopupWindowState::Maximized => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "PopupWindowState",
                            1u32,
                            "Maximized",
                        )
                    }
                    PopupWindowState::Fullscreen => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "PopupWindowState",
                            2u32,
                            "Fullscreen",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for PopupWindowState {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 3",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Normal" => _serde::__private::Ok(__Field::__field0),
                            "Maximized" => _serde::__private::Ok(__Field::__field1),
                            "Fullscreen" => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Normal" => _serde::__private::Ok(__Field::__field0),
                            b"Maximized" => _serde::__private::Ok(__Field::__field1),
                            b"Fullscreen" => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<PopupWindowState>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = PopupWindowState;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum PopupWindowState",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(PopupWindowState::Normal)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(PopupWindowState::Maximized)
                            }
                            (__Field::__field2, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(PopupWindowState::Fullscreen)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "Normal",
                    "Maximized",
                    "Fullscreen",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "PopupWindowState",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<PopupWindowState>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for PopupWindowState {
        #[inline]
        fn default() -> PopupWindowState {
            Self::Normal
        }
    }
    /// When searching for audio, the sources are checked in order until the first valid source is found.
    /// This allows for selecting a fallback source if the first choice is not available.
    pub enum AudioSourceType {
        #[default]
        Jpod101,
        Jpod101Alternate,
        Jisho,
        LinguaLibre,
        Wiktionary,
        TextToSpeech,
        TextToSpeechReading,
        Custom,
        CustomJson,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for AudioSourceType {
        #[inline]
        fn clone(&self) -> AudioSourceType {
            match self {
                AudioSourceType::Jpod101 => AudioSourceType::Jpod101,
                AudioSourceType::Jpod101Alternate => AudioSourceType::Jpod101Alternate,
                AudioSourceType::Jisho => AudioSourceType::Jisho,
                AudioSourceType::LinguaLibre => AudioSourceType::LinguaLibre,
                AudioSourceType::Wiktionary => AudioSourceType::Wiktionary,
                AudioSourceType::TextToSpeech => AudioSourceType::TextToSpeech,
                AudioSourceType::TextToSpeechReading => {
                    AudioSourceType::TextToSpeechReading
                }
                AudioSourceType::Custom => AudioSourceType::Custom,
                AudioSourceType::CustomJson => AudioSourceType::CustomJson,
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for AudioSourceType {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    AudioSourceType::Jpod101 => "Jpod101",
                    AudioSourceType::Jpod101Alternate => "Jpod101Alternate",
                    AudioSourceType::Jisho => "Jisho",
                    AudioSourceType::LinguaLibre => "LinguaLibre",
                    AudioSourceType::Wiktionary => "Wiktionary",
                    AudioSourceType::TextToSpeech => "TextToSpeech",
                    AudioSourceType::TextToSpeechReading => "TextToSpeechReading",
                    AudioSourceType::Custom => "Custom",
                    AudioSourceType::CustomJson => "CustomJson",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for AudioSourceType {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for AudioSourceType {
        #[inline]
        fn eq(&self, other: &AudioSourceType) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for AudioSourceType {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    AudioSourceType::Jpod101 => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "AudioSourceType",
                            0u32,
                            "Jpod101",
                        )
                    }
                    AudioSourceType::Jpod101Alternate => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "AudioSourceType",
                            1u32,
                            "Jpod101Alternate",
                        )
                    }
                    AudioSourceType::Jisho => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "AudioSourceType",
                            2u32,
                            "Jisho",
                        )
                    }
                    AudioSourceType::LinguaLibre => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "AudioSourceType",
                            3u32,
                            "LinguaLibre",
                        )
                    }
                    AudioSourceType::Wiktionary => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "AudioSourceType",
                            4u32,
                            "Wiktionary",
                        )
                    }
                    AudioSourceType::TextToSpeech => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "AudioSourceType",
                            5u32,
                            "TextToSpeech",
                        )
                    }
                    AudioSourceType::TextToSpeechReading => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "AudioSourceType",
                            6u32,
                            "TextToSpeechReading",
                        )
                    }
                    AudioSourceType::Custom => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "AudioSourceType",
                            7u32,
                            "Custom",
                        )
                    }
                    AudioSourceType::CustomJson => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "AudioSourceType",
                            8u32,
                            "CustomJson",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for AudioSourceType {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __field8,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            8u64 => _serde::__private::Ok(__Field::__field8),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 9",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Jpod101" => _serde::__private::Ok(__Field::__field0),
                            "Jpod101Alternate" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            "Jisho" => _serde::__private::Ok(__Field::__field2),
                            "LinguaLibre" => _serde::__private::Ok(__Field::__field3),
                            "Wiktionary" => _serde::__private::Ok(__Field::__field4),
                            "TextToSpeech" => _serde::__private::Ok(__Field::__field5),
                            "TextToSpeechReading" => {
                                _serde::__private::Ok(__Field::__field6)
                            }
                            "Custom" => _serde::__private::Ok(__Field::__field7),
                            "CustomJson" => _serde::__private::Ok(__Field::__field8),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Jpod101" => _serde::__private::Ok(__Field::__field0),
                            b"Jpod101Alternate" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            b"Jisho" => _serde::__private::Ok(__Field::__field2),
                            b"LinguaLibre" => _serde::__private::Ok(__Field::__field3),
                            b"Wiktionary" => _serde::__private::Ok(__Field::__field4),
                            b"TextToSpeech" => _serde::__private::Ok(__Field::__field5),
                            b"TextToSpeechReading" => {
                                _serde::__private::Ok(__Field::__field6)
                            }
                            b"Custom" => _serde::__private::Ok(__Field::__field7),
                            b"CustomJson" => _serde::__private::Ok(__Field::__field8),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<AudioSourceType>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = AudioSourceType;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum AudioSourceType",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(AudioSourceType::Jpod101)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(AudioSourceType::Jpod101Alternate)
                            }
                            (__Field::__field2, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(AudioSourceType::Jisho)
                            }
                            (__Field::__field3, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(AudioSourceType::LinguaLibre)
                            }
                            (__Field::__field4, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(AudioSourceType::Wiktionary)
                            }
                            (__Field::__field5, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(AudioSourceType::TextToSpeech)
                            }
                            (__Field::__field6, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(AudioSourceType::TextToSpeechReading)
                            }
                            (__Field::__field7, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(AudioSourceType::Custom)
                            }
                            (__Field::__field8, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(AudioSourceType::CustomJson)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "Jpod101",
                    "Jpod101Alternate",
                    "Jisho",
                    "LinguaLibre",
                    "Wiktionary",
                    "TextToSpeech",
                    "TextToSpeechReading",
                    "Custom",
                    "CustomJson",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "AudioSourceType",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<AudioSourceType>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for AudioSourceType {
        #[inline]
        fn default() -> AudioSourceType {
            Self::Jpod101
        }
    }
    pub enum TranslationConvertType {
        #[default]
        False,
        True,
        Variant,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TranslationConvertType {
        #[inline]
        fn clone(&self) -> TranslationConvertType {
            match self {
                TranslationConvertType::False => TranslationConvertType::False,
                TranslationConvertType::True => TranslationConvertType::True,
                TranslationConvertType::Variant => TranslationConvertType::Variant,
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TranslationConvertType {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    TranslationConvertType::False => "False",
                    TranslationConvertType::True => "True",
                    TranslationConvertType::Variant => "Variant",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TranslationConvertType {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TranslationConvertType {
        #[inline]
        fn eq(&self, other: &TranslationConvertType) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TranslationConvertType {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    TranslationConvertType::False => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "TranslationConvertType",
                            0u32,
                            "False",
                        )
                    }
                    TranslationConvertType::True => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "TranslationConvertType",
                            1u32,
                            "True",
                        )
                    }
                    TranslationConvertType::Variant => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "TranslationConvertType",
                            2u32,
                            "Variant",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TranslationConvertType {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 3",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "False" => _serde::__private::Ok(__Field::__field0),
                            "True" => _serde::__private::Ok(__Field::__field1),
                            "Variant" => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"False" => _serde::__private::Ok(__Field::__field0),
                            b"True" => _serde::__private::Ok(__Field::__field1),
                            b"Variant" => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<TranslationConvertType>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TranslationConvertType;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum TranslationConvertType",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(TranslationConvertType::False)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(TranslationConvertType::True)
                            }
                            (__Field::__field2, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(TranslationConvertType::Variant)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["False", "True", "Variant"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "TranslationConvertType",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<TranslationConvertType>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for TranslationConvertType {
        #[inline]
        fn default() -> TranslationConvertType {
            Self::False
        }
    }
    pub enum TranslationCollapseEmphaticSequences {
        #[default]
        False,
        True,
        Full,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TranslationCollapseEmphaticSequences {
        #[inline]
        fn clone(&self) -> TranslationCollapseEmphaticSequences {
            match self {
                TranslationCollapseEmphaticSequences::False => {
                    TranslationCollapseEmphaticSequences::False
                }
                TranslationCollapseEmphaticSequences::True => {
                    TranslationCollapseEmphaticSequences::True
                }
                TranslationCollapseEmphaticSequences::Full => {
                    TranslationCollapseEmphaticSequences::Full
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TranslationCollapseEmphaticSequences {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    TranslationCollapseEmphaticSequences::False => "False",
                    TranslationCollapseEmphaticSequences::True => "True",
                    TranslationCollapseEmphaticSequences::Full => "Full",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TranslationCollapseEmphaticSequences {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TranslationCollapseEmphaticSequences {
        #[inline]
        fn eq(&self, other: &TranslationCollapseEmphaticSequences) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TranslationCollapseEmphaticSequences {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    TranslationCollapseEmphaticSequences::False => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "TranslationCollapseEmphaticSequences",
                            0u32,
                            "False",
                        )
                    }
                    TranslationCollapseEmphaticSequences::True => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "TranslationCollapseEmphaticSequences",
                            1u32,
                            "True",
                        )
                    }
                    TranslationCollapseEmphaticSequences::Full => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "TranslationCollapseEmphaticSequences",
                            2u32,
                            "Full",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TranslationCollapseEmphaticSequences {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 3",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "False" => _serde::__private::Ok(__Field::__field0),
                            "True" => _serde::__private::Ok(__Field::__field1),
                            "Full" => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"False" => _serde::__private::Ok(__Field::__field0),
                            b"True" => _serde::__private::Ok(__Field::__field1),
                            b"Full" => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<
                        TranslationCollapseEmphaticSequences,
                    >,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TranslationCollapseEmphaticSequences;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum TranslationCollapseEmphaticSequences",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(
                                    TranslationCollapseEmphaticSequences::False,
                                )
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(
                                    TranslationCollapseEmphaticSequences::True,
                                )
                            }
                            (__Field::__field2, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(
                                    TranslationCollapseEmphaticSequences::Full,
                                )
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["False", "True", "Full"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "TranslationCollapseEmphaticSequences",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            TranslationCollapseEmphaticSequences,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for TranslationCollapseEmphaticSequences {
        #[inline]
        fn default() -> TranslationCollapseEmphaticSequences {
            Self::False
        }
    }
    /// Customize dictionary collapsing.
    pub enum DictionaryDefinitionsCollapsible {
        /// Definitions will not be collapsed.
        NotCollapsible,
        /// Definitions will show a collapse button if their size exceeds the max height,
        /// and they will be collapsed by default.
        #[default]
        Expanded,
        /// Definitions will show a collapse button if their size exceeds the max height,
        /// and they will be expanded by default.
        Collapsed,
        /// Definitions will always show a collapse button,
        /// and they will be collapsed by default.
        ForceCollapsed,
        ///  Definitions will always show a collapse button,
        ///  and they will be expanded by default.
        ForceExpanded,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for DictionaryDefinitionsCollapsible {
        #[inline]
        fn clone(&self) -> DictionaryDefinitionsCollapsible {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for DictionaryDefinitionsCollapsible {}
    #[automatically_derived]
    impl ::core::fmt::Debug for DictionaryDefinitionsCollapsible {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    DictionaryDefinitionsCollapsible::NotCollapsible => "NotCollapsible",
                    DictionaryDefinitionsCollapsible::Expanded => "Expanded",
                    DictionaryDefinitionsCollapsible::Collapsed => "Collapsed",
                    DictionaryDefinitionsCollapsible::ForceCollapsed => "ForceCollapsed",
                    DictionaryDefinitionsCollapsible::ForceExpanded => "ForceExpanded",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for DictionaryDefinitionsCollapsible {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for DictionaryDefinitionsCollapsible {
        #[inline]
        fn eq(&self, other: &DictionaryDefinitionsCollapsible) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for DictionaryDefinitionsCollapsible {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for DictionaryDefinitionsCollapsible {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_discr, state)
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for DictionaryDefinitionsCollapsible {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    DictionaryDefinitionsCollapsible::NotCollapsible => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "DictionaryDefinitionsCollapsible",
                            0u32,
                            "NotCollapsible",
                        )
                    }
                    DictionaryDefinitionsCollapsible::Expanded => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "DictionaryDefinitionsCollapsible",
                            1u32,
                            "Expanded",
                        )
                    }
                    DictionaryDefinitionsCollapsible::Collapsed => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "DictionaryDefinitionsCollapsible",
                            2u32,
                            "Collapsed",
                        )
                    }
                    DictionaryDefinitionsCollapsible::ForceCollapsed => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "DictionaryDefinitionsCollapsible",
                            3u32,
                            "ForceCollapsed",
                        )
                    }
                    DictionaryDefinitionsCollapsible::ForceExpanded => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "DictionaryDefinitionsCollapsible",
                            4u32,
                            "ForceExpanded",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for DictionaryDefinitionsCollapsible {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 5",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "NotCollapsible" => _serde::__private::Ok(__Field::__field0),
                            "Expanded" => _serde::__private::Ok(__Field::__field1),
                            "Collapsed" => _serde::__private::Ok(__Field::__field2),
                            "ForceCollapsed" => _serde::__private::Ok(__Field::__field3),
                            "ForceExpanded" => _serde::__private::Ok(__Field::__field4),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"NotCollapsible" => _serde::__private::Ok(__Field::__field0),
                            b"Expanded" => _serde::__private::Ok(__Field::__field1),
                            b"Collapsed" => _serde::__private::Ok(__Field::__field2),
                            b"ForceCollapsed" => _serde::__private::Ok(__Field::__field3),
                            b"ForceExpanded" => _serde::__private::Ok(__Field::__field4),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<
                        DictionaryDefinitionsCollapsible,
                    >,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = DictionaryDefinitionsCollapsible;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum DictionaryDefinitionsCollapsible",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(
                                    DictionaryDefinitionsCollapsible::NotCollapsible,
                                )
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(
                                    DictionaryDefinitionsCollapsible::Expanded,
                                )
                            }
                            (__Field::__field2, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(
                                    DictionaryDefinitionsCollapsible::Collapsed,
                                )
                            }
                            (__Field::__field3, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(
                                    DictionaryDefinitionsCollapsible::ForceCollapsed,
                                )
                            }
                            (__Field::__field4, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(
                                    DictionaryDefinitionsCollapsible::ForceExpanded,
                                )
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "NotCollapsible",
                    "Expanded",
                    "Collapsed",
                    "ForceCollapsed",
                    "ForceExpanded",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "DictionaryDefinitionsCollapsible",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            DictionaryDefinitionsCollapsible,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for DictionaryDefinitionsCollapsible {
        #[inline]
        fn default() -> DictionaryDefinitionsCollapsible {
            Self::Expanded
        }
    }
    /// Change what type of furigana is displayed for parsed text.
    pub enum ParsingReadingMode {
        #[default]
        Hiragana,
        Katakana,
        Romaji,
        DictionaryReading,
        None,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ParsingReadingMode {
        #[inline]
        fn clone(&self) -> ParsingReadingMode {
            match self {
                ParsingReadingMode::Hiragana => ParsingReadingMode::Hiragana,
                ParsingReadingMode::Katakana => ParsingReadingMode::Katakana,
                ParsingReadingMode::Romaji => ParsingReadingMode::Romaji,
                ParsingReadingMode::DictionaryReading => {
                    ParsingReadingMode::DictionaryReading
                }
                ParsingReadingMode::None => ParsingReadingMode::None,
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ParsingReadingMode {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    ParsingReadingMode::Hiragana => "Hiragana",
                    ParsingReadingMode::Katakana => "Katakana",
                    ParsingReadingMode::Romaji => "Romaji",
                    ParsingReadingMode::DictionaryReading => "DictionaryReading",
                    ParsingReadingMode::None => "None",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ParsingReadingMode {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ParsingReadingMode {
        #[inline]
        fn eq(&self, other: &ParsingReadingMode) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ParsingReadingMode {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    ParsingReadingMode::Hiragana => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ParsingReadingMode",
                            0u32,
                            "Hiragana",
                        )
                    }
                    ParsingReadingMode::Katakana => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ParsingReadingMode",
                            1u32,
                            "Katakana",
                        )
                    }
                    ParsingReadingMode::Romaji => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ParsingReadingMode",
                            2u32,
                            "Romaji",
                        )
                    }
                    ParsingReadingMode::DictionaryReading => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ParsingReadingMode",
                            3u32,
                            "DictionaryReading",
                        )
                    }
                    ParsingReadingMode::None => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ParsingReadingMode",
                            4u32,
                            "None",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ParsingReadingMode {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 5",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Hiragana" => _serde::__private::Ok(__Field::__field0),
                            "Katakana" => _serde::__private::Ok(__Field::__field1),
                            "Romaji" => _serde::__private::Ok(__Field::__field2),
                            "DictionaryReading" => {
                                _serde::__private::Ok(__Field::__field3)
                            }
                            "None" => _serde::__private::Ok(__Field::__field4),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Hiragana" => _serde::__private::Ok(__Field::__field0),
                            b"Katakana" => _serde::__private::Ok(__Field::__field1),
                            b"Romaji" => _serde::__private::Ok(__Field::__field2),
                            b"DictionaryReading" => {
                                _serde::__private::Ok(__Field::__field3)
                            }
                            b"None" => _serde::__private::Ok(__Field::__field4),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ParsingReadingMode>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ParsingReadingMode;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum ParsingReadingMode",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(ParsingReadingMode::Hiragana)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(ParsingReadingMode::Katakana)
                            }
                            (__Field::__field2, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(ParsingReadingMode::Romaji)
                            }
                            (__Field::__field3, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(ParsingReadingMode::DictionaryReading)
                            }
                            (__Field::__field4, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(ParsingReadingMode::None)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "Hiragana",
                    "Katakana",
                    "Romaji",
                    "DictionaryReading",
                    "None",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "ParsingReadingMode",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ParsingReadingMode>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for ParsingReadingMode {
        #[inline]
        fn default() -> ParsingReadingMode {
            Self::Hiragana
        }
    }
    /// Adjust the format and quality of screenshots created for cards.
    pub enum AnkiScreenshotFormat {
        #[default]
        Png,
        Jpeg,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for AnkiScreenshotFormat {
        #[inline]
        fn clone(&self) -> AnkiScreenshotFormat {
            match self {
                AnkiScreenshotFormat::Png => AnkiScreenshotFormat::Png,
                AnkiScreenshotFormat::Jpeg => AnkiScreenshotFormat::Jpeg,
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for AnkiScreenshotFormat {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    AnkiScreenshotFormat::Png => "Png",
                    AnkiScreenshotFormat::Jpeg => "Jpeg",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for AnkiScreenshotFormat {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for AnkiScreenshotFormat {
        #[inline]
        fn eq(&self, other: &AnkiScreenshotFormat) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for AnkiScreenshotFormat {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    AnkiScreenshotFormat::Png => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "AnkiScreenshotFormat",
                            0u32,
                            "Png",
                        )
                    }
                    AnkiScreenshotFormat::Jpeg => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "AnkiScreenshotFormat",
                            1u32,
                            "Jpeg",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for AnkiScreenshotFormat {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 2",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Png" => _serde::__private::Ok(__Field::__field0),
                            "Jpeg" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Png" => _serde::__private::Ok(__Field::__field0),
                            b"Jpeg" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<AnkiScreenshotFormat>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = AnkiScreenshotFormat;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum AnkiScreenshotFormat",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(AnkiScreenshotFormat::Png)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(AnkiScreenshotFormat::Jpeg)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["Png", "Jpeg"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "AnkiScreenshotFormat",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<AnkiScreenshotFormat>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for AnkiScreenshotFormat {
        #[inline]
        fn default() -> AnkiScreenshotFormat {
            Self::Png
        }
    }
    /// A card is considered a duplicate if the value of the first field matches that of any other card.
    /// By default, this check will include cards across all decks in a collection,
    /// but this constraint can be relaxed by using either the Deck or Deck root option.
    ///
    /// The Deck option will only check for duplicates in the target deck.
    /// The Deck root option will additionally check for duplicates in all child decks of the root deck.
    /// This allows adding cards that are unique for decks including a subdeck structure.
    /// For decks which don't have any parent-child hierarchy, both options function the same.
    pub enum AnkiDuplicateScope {
        #[default]
        Collection,
        Deck,
        DeckRoot,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for AnkiDuplicateScope {
        #[inline]
        fn clone(&self) -> AnkiDuplicateScope {
            match self {
                AnkiDuplicateScope::Collection => AnkiDuplicateScope::Collection,
                AnkiDuplicateScope::Deck => AnkiDuplicateScope::Deck,
                AnkiDuplicateScope::DeckRoot => AnkiDuplicateScope::DeckRoot,
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for AnkiDuplicateScope {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    AnkiDuplicateScope::Collection => "Collection",
                    AnkiDuplicateScope::Deck => "Deck",
                    AnkiDuplicateScope::DeckRoot => "DeckRoot",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for AnkiDuplicateScope {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for AnkiDuplicateScope {
        #[inline]
        fn eq(&self, other: &AnkiDuplicateScope) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for AnkiDuplicateScope {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    AnkiDuplicateScope::Collection => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "AnkiDuplicateScope",
                            0u32,
                            "Collection",
                        )
                    }
                    AnkiDuplicateScope::Deck => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "AnkiDuplicateScope",
                            1u32,
                            "Deck",
                        )
                    }
                    AnkiDuplicateScope::DeckRoot => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "AnkiDuplicateScope",
                            2u32,
                            "DeckRoot",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for AnkiDuplicateScope {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 3",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Collection" => _serde::__private::Ok(__Field::__field0),
                            "Deck" => _serde::__private::Ok(__Field::__field1),
                            "DeckRoot" => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Collection" => _serde::__private::Ok(__Field::__field0),
                            b"Deck" => _serde::__private::Ok(__Field::__field1),
                            b"DeckRoot" => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<AnkiDuplicateScope>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = AnkiDuplicateScope;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum AnkiDuplicateScope",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(AnkiDuplicateScope::Collection)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(AnkiDuplicateScope::Deck)
                            }
                            (__Field::__field2, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(AnkiDuplicateScope::DeckRoot)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "Collection",
                    "Deck",
                    "DeckRoot",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "AnkiDuplicateScope",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<AnkiDuplicateScope>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for AnkiDuplicateScope {
        #[inline]
        fn default() -> AnkiDuplicateScope {
            Self::Collection
        }
    }
    /// When a duplicate is detected.
    pub enum AnkiDuplicateBehavior {
        #[default]
        Prevent,
        Overwrite,
        New,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for AnkiDuplicateBehavior {
        #[inline]
        fn clone(&self) -> AnkiDuplicateBehavior {
            match self {
                AnkiDuplicateBehavior::Prevent => AnkiDuplicateBehavior::Prevent,
                AnkiDuplicateBehavior::Overwrite => AnkiDuplicateBehavior::Overwrite,
                AnkiDuplicateBehavior::New => AnkiDuplicateBehavior::New,
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for AnkiDuplicateBehavior {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    AnkiDuplicateBehavior::Prevent => "Prevent",
                    AnkiDuplicateBehavior::Overwrite => "Overwrite",
                    AnkiDuplicateBehavior::New => "New",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for AnkiDuplicateBehavior {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for AnkiDuplicateBehavior {
        #[inline]
        fn eq(&self, other: &AnkiDuplicateBehavior) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for AnkiDuplicateBehavior {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    AnkiDuplicateBehavior::Prevent => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "AnkiDuplicateBehavior",
                            0u32,
                            "Prevent",
                        )
                    }
                    AnkiDuplicateBehavior::Overwrite => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "AnkiDuplicateBehavior",
                            1u32,
                            "Overwrite",
                        )
                    }
                    AnkiDuplicateBehavior::New => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "AnkiDuplicateBehavior",
                            2u32,
                            "New",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for AnkiDuplicateBehavior {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 3",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Prevent" => _serde::__private::Ok(__Field::__field0),
                            "Overwrite" => _serde::__private::Ok(__Field::__field1),
                            "New" => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Prevent" => _serde::__private::Ok(__Field::__field0),
                            b"Overwrite" => _serde::__private::Ok(__Field::__field1),
                            b"New" => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<AnkiDuplicateBehavior>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = AnkiDuplicateBehavior;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum AnkiDuplicateBehavior",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(AnkiDuplicateBehavior::Prevent)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(AnkiDuplicateBehavior::Overwrite)
                            }
                            (__Field::__field2, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(AnkiDuplicateBehavior::New)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "Prevent",
                    "Overwrite",
                    "New",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "AnkiDuplicateBehavior",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<AnkiDuplicateBehavior>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for AnkiDuplicateBehavior {
        #[inline]
        fn default() -> AnkiDuplicateBehavior {
            Self::Prevent
        }
    }
    /// Show card tags
    ///
    /// When coming across a word that is already in an Anki deck,
    /// a button will appear that shows the tags the card has.
    ///
    /// If set to `Non-Standard`, all tags that are included in the Card tags option will be filtered out from the list.
    /// If no tags remain after filtering, then the button will not be shown.
    pub enum AnkiDisplayTags {
        #[default]
        Never,
        Always,
        NonStandard,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for AnkiDisplayTags {
        #[inline]
        fn clone(&self) -> AnkiDisplayTags {
            match self {
                AnkiDisplayTags::Never => AnkiDisplayTags::Never,
                AnkiDisplayTags::Always => AnkiDisplayTags::Always,
                AnkiDisplayTags::NonStandard => AnkiDisplayTags::NonStandard,
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for AnkiDisplayTags {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    AnkiDisplayTags::Never => "Never",
                    AnkiDisplayTags::Always => "Always",
                    AnkiDisplayTags::NonStandard => "NonStandard",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for AnkiDisplayTags {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for AnkiDisplayTags {
        #[inline]
        fn eq(&self, other: &AnkiDisplayTags) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for AnkiDisplayTags {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    AnkiDisplayTags::Never => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "AnkiDisplayTags",
                            0u32,
                            "Never",
                        )
                    }
                    AnkiDisplayTags::Always => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "AnkiDisplayTags",
                            1u32,
                            "Always",
                        )
                    }
                    AnkiDisplayTags::NonStandard => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "AnkiDisplayTags",
                            2u32,
                            "NonStandard",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for AnkiDisplayTags {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 3",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Never" => _serde::__private::Ok(__Field::__field0),
                            "Always" => _serde::__private::Ok(__Field::__field1),
                            "NonStandard" => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Never" => _serde::__private::Ok(__Field::__field0),
                            b"Always" => _serde::__private::Ok(__Field::__field1),
                            b"NonStandard" => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<AnkiDisplayTags>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = AnkiDisplayTags;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum AnkiDisplayTags",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(AnkiDisplayTags::Never)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(AnkiDisplayTags::Always)
                            }
                            (__Field::__field2, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(AnkiDisplayTags::NonStandard)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "Never",
                    "Always",
                    "NonStandard",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "AnkiDisplayTags",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<AnkiDisplayTags>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for AnkiDisplayTags {
        #[inline]
        fn default() -> AnkiDisplayTags {
            Self::Never
        }
    }
    /// Note viewer window
    ///
    /// Clicking the View added note button shows this window.
    ///
    /// AnkiConnect releases after around `2022-05-29` support a new note editor window-
    /// which can be shown when clicking the View added note button.
    /// This can be tested using the buttons below.
    ///
    /// _If an error occurs, [Anki](https://apps.ankiweb.net/) and/or [AnkiConnect](https://ankiweb.net/shared/info/2055492159) may need to be updated_.
    pub enum AnkiNoteGuiMode {
        #[default]
        CardBrowser,
        NoteEditor,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for AnkiNoteGuiMode {
        #[inline]
        fn clone(&self) -> AnkiNoteGuiMode {
            match self {
                AnkiNoteGuiMode::CardBrowser => AnkiNoteGuiMode::CardBrowser,
                AnkiNoteGuiMode::NoteEditor => AnkiNoteGuiMode::NoteEditor,
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for AnkiNoteGuiMode {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    AnkiNoteGuiMode::CardBrowser => "CardBrowser",
                    AnkiNoteGuiMode::NoteEditor => "NoteEditor",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for AnkiNoteGuiMode {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for AnkiNoteGuiMode {
        #[inline]
        fn eq(&self, other: &AnkiNoteGuiMode) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for AnkiNoteGuiMode {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    AnkiNoteGuiMode::CardBrowser => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "AnkiNoteGuiMode",
                            0u32,
                            "CardBrowser",
                        )
                    }
                    AnkiNoteGuiMode::NoteEditor => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "AnkiNoteGuiMode",
                            1u32,
                            "NoteEditor",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for AnkiNoteGuiMode {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 2",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "CardBrowser" => _serde::__private::Ok(__Field::__field0),
                            "NoteEditor" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"CardBrowser" => _serde::__private::Ok(__Field::__field0),
                            b"NoteEditor" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<AnkiNoteGuiMode>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = AnkiNoteGuiMode;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum AnkiNoteGuiMode",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(AnkiNoteGuiMode::CardBrowser)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(AnkiNoteGuiMode::NoteEditor)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["CardBrowser", "NoteEditor"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "AnkiNoteGuiMode",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<AnkiNoteGuiMode>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for AnkiNoteGuiMode {
        #[inline]
        fn default() -> AnkiNoteGuiMode {
            Self::CardBrowser
        }
    }
    /// Sentence termination characters.
    pub enum SentenceTerminationCharacterMode {
        #[default]
        Custom,
        CustomNoNewlines,
        Newlines,
        None,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for SentenceTerminationCharacterMode {
        #[inline]
        fn clone(&self) -> SentenceTerminationCharacterMode {
            match self {
                SentenceTerminationCharacterMode::Custom => {
                    SentenceTerminationCharacterMode::Custom
                }
                SentenceTerminationCharacterMode::CustomNoNewlines => {
                    SentenceTerminationCharacterMode::CustomNoNewlines
                }
                SentenceTerminationCharacterMode::Newlines => {
                    SentenceTerminationCharacterMode::Newlines
                }
                SentenceTerminationCharacterMode::None => {
                    SentenceTerminationCharacterMode::None
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for SentenceTerminationCharacterMode {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    SentenceTerminationCharacterMode::Custom => "Custom",
                    SentenceTerminationCharacterMode::CustomNoNewlines => {
                        "CustomNoNewlines"
                    }
                    SentenceTerminationCharacterMode::Newlines => "Newlines",
                    SentenceTerminationCharacterMode::None => "None",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for SentenceTerminationCharacterMode {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for SentenceTerminationCharacterMode {
        #[inline]
        fn eq(&self, other: &SentenceTerminationCharacterMode) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for SentenceTerminationCharacterMode {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    SentenceTerminationCharacterMode::Custom => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SentenceTerminationCharacterMode",
                            0u32,
                            "Custom",
                        )
                    }
                    SentenceTerminationCharacterMode::CustomNoNewlines => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SentenceTerminationCharacterMode",
                            1u32,
                            "CustomNoNewlines",
                        )
                    }
                    SentenceTerminationCharacterMode::Newlines => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SentenceTerminationCharacterMode",
                            2u32,
                            "Newlines",
                        )
                    }
                    SentenceTerminationCharacterMode::None => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SentenceTerminationCharacterMode",
                            3u32,
                            "None",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for SentenceTerminationCharacterMode {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 4",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Custom" => _serde::__private::Ok(__Field::__field0),
                            "CustomNoNewlines" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            "Newlines" => _serde::__private::Ok(__Field::__field2),
                            "None" => _serde::__private::Ok(__Field::__field3),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Custom" => _serde::__private::Ok(__Field::__field0),
                            b"CustomNoNewlines" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            b"Newlines" => _serde::__private::Ok(__Field::__field2),
                            b"None" => _serde::__private::Ok(__Field::__field3),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<
                        SentenceTerminationCharacterMode,
                    >,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = SentenceTerminationCharacterMode;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum SentenceTerminationCharacterMode",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(
                                    SentenceTerminationCharacterMode::Custom,
                                )
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(
                                    SentenceTerminationCharacterMode::CustomNoNewlines,
                                )
                            }
                            (__Field::__field2, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(
                                    SentenceTerminationCharacterMode::Newlines,
                                )
                            }
                            (__Field::__field3, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(
                                    SentenceTerminationCharacterMode::None,
                                )
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "Custom",
                    "CustomNoNewlines",
                    "Newlines",
                    "None",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "SentenceTerminationCharacterMode",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            SentenceTerminationCharacterMode,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for SentenceTerminationCharacterMode {
        #[inline]
        fn default() -> SentenceTerminationCharacterMode {
            Self::Custom
        }
    }
    /// Hold a key while moving the cursor to scan text.
    ///
    /// A keyboard modifier key can be used to activate text scanning when the cursor is moved.
    /// Alternatively, the `No Key` option can be used
    /// to scan text whenever the cursor is moved, without requiring any key to be held.
    ///
    /// More advanced scanning input customization can be set up
    /// by enabling the `Advanced` option and clicking `Configure Advanced Scanning Inputs`.
    pub enum InputsHotkeyModifier {
        NoKey,
        Alt,
        Ctrl,
        #[default]
        Shift,
        Meta,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for InputsHotkeyModifier {
        #[inline]
        fn clone(&self) -> InputsHotkeyModifier {
            match self {
                InputsHotkeyModifier::NoKey => InputsHotkeyModifier::NoKey,
                InputsHotkeyModifier::Alt => InputsHotkeyModifier::Alt,
                InputsHotkeyModifier::Ctrl => InputsHotkeyModifier::Ctrl,
                InputsHotkeyModifier::Shift => InputsHotkeyModifier::Shift,
                InputsHotkeyModifier::Meta => InputsHotkeyModifier::Meta,
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for InputsHotkeyModifier {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    InputsHotkeyModifier::NoKey => "NoKey",
                    InputsHotkeyModifier::Alt => "Alt",
                    InputsHotkeyModifier::Ctrl => "Ctrl",
                    InputsHotkeyModifier::Shift => "Shift",
                    InputsHotkeyModifier::Meta => "Meta",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for InputsHotkeyModifier {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for InputsHotkeyModifier {
        #[inline]
        fn eq(&self, other: &InputsHotkeyModifier) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for InputsHotkeyModifier {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    InputsHotkeyModifier::NoKey => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "InputsHotkeyModifier",
                            0u32,
                            "NoKey",
                        )
                    }
                    InputsHotkeyModifier::Alt => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "InputsHotkeyModifier",
                            1u32,
                            "Alt",
                        )
                    }
                    InputsHotkeyModifier::Ctrl => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "InputsHotkeyModifier",
                            2u32,
                            "Ctrl",
                        )
                    }
                    InputsHotkeyModifier::Shift => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "InputsHotkeyModifier",
                            3u32,
                            "Shift",
                        )
                    }
                    InputsHotkeyModifier::Meta => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "InputsHotkeyModifier",
                            4u32,
                            "Meta",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for InputsHotkeyModifier {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 5",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "NoKey" => _serde::__private::Ok(__Field::__field0),
                            "Alt" => _serde::__private::Ok(__Field::__field1),
                            "Ctrl" => _serde::__private::Ok(__Field::__field2),
                            "Shift" => _serde::__private::Ok(__Field::__field3),
                            "Meta" => _serde::__private::Ok(__Field::__field4),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"NoKey" => _serde::__private::Ok(__Field::__field0),
                            b"Alt" => _serde::__private::Ok(__Field::__field1),
                            b"Ctrl" => _serde::__private::Ok(__Field::__field2),
                            b"Shift" => _serde::__private::Ok(__Field::__field3),
                            b"Meta" => _serde::__private::Ok(__Field::__field4),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<InputsHotkeyModifier>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = InputsHotkeyModifier;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum InputsHotkeyModifier",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(InputsHotkeyModifier::NoKey)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(InputsHotkeyModifier::Alt)
                            }
                            (__Field::__field2, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(InputsHotkeyModifier::Ctrl)
                            }
                            (__Field::__field3, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(InputsHotkeyModifier::Shift)
                            }
                            (__Field::__field4, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(InputsHotkeyModifier::Meta)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "NoKey",
                    "Alt",
                    "Ctrl",
                    "Shift",
                    "Meta",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "InputsHotkeyModifier",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<InputsHotkeyModifier>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for InputsHotkeyModifier {
        #[inline]
        fn default() -> InputsHotkeyModifier {
            Self::Shift
        }
    }
    pub enum InputsHotkeyScope {
        #[default]
        Popup,
        Search,
        Web,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for InputsHotkeyScope {
        #[inline]
        fn clone(&self) -> InputsHotkeyScope {
            match self {
                InputsHotkeyScope::Popup => InputsHotkeyScope::Popup,
                InputsHotkeyScope::Search => InputsHotkeyScope::Search,
                InputsHotkeyScope::Web => InputsHotkeyScope::Web,
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for InputsHotkeyScope {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    InputsHotkeyScope::Popup => "Popup",
                    InputsHotkeyScope::Search => "Search",
                    InputsHotkeyScope::Web => "Web",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for InputsHotkeyScope {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for InputsHotkeyScope {
        #[inline]
        fn eq(&self, other: &InputsHotkeyScope) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for InputsHotkeyScope {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    InputsHotkeyScope::Popup => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "InputsHotkeyScope",
                            0u32,
                            "Popup",
                        )
                    }
                    InputsHotkeyScope::Search => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "InputsHotkeyScope",
                            1u32,
                            "Search",
                        )
                    }
                    InputsHotkeyScope::Web => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "InputsHotkeyScope",
                            2u32,
                            "Web",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for InputsHotkeyScope {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 3",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Popup" => _serde::__private::Ok(__Field::__field0),
                            "Search" => _serde::__private::Ok(__Field::__field1),
                            "Web" => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Popup" => _serde::__private::Ok(__Field::__field0),
                            b"Search" => _serde::__private::Ok(__Field::__field1),
                            b"Web" => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<InputsHotkeyScope>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = InputsHotkeyScope;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum InputsHotkeyScope",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(InputsHotkeyScope::Popup)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(InputsHotkeyScope::Search)
                            }
                            (__Field::__field2, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(InputsHotkeyScope::Web)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["Popup", "Search", "Web"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "InputsHotkeyScope",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<InputsHotkeyScope>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for InputsHotkeyScope {
        #[inline]
        fn default() -> InputsHotkeyScope {
            Self::Popup
        }
    }
}
mod structured_content {
    use std::hash::Hash;
    use indexmap::IndexMap;
    use serde::{de, Deserialize, Deserializer, Serialize};
    use serde_untagged::UntaggedEnumVisitor;
    /// An `untagged` match type to generically match
    /// the `header`, `reading`, and `structured-content`
    /// of a `term_bank_$i.json` entry item.
    #[serde(untagged)]
    pub enum EntryItemMatchType {
        String(String),
        Integer(i128),
        /// The array holding the main `structured-content` object.
        /// There is only 1 per entry.
        StructuredContentVec(Vec<StructuredContent>),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for EntryItemMatchType {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                EntryItemMatchType::String(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "String",
                        &__self_0,
                    )
                }
                EntryItemMatchType::Integer(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Integer",
                        &__self_0,
                    )
                }
                EntryItemMatchType::StructuredContentVec(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "StructuredContentVec",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for EntryItemMatchType {
        #[inline]
        fn clone(&self) -> EntryItemMatchType {
            match self {
                EntryItemMatchType::String(__self_0) => {
                    EntryItemMatchType::String(::core::clone::Clone::clone(__self_0))
                }
                EntryItemMatchType::Integer(__self_0) => {
                    EntryItemMatchType::Integer(::core::clone::Clone::clone(__self_0))
                }
                EntryItemMatchType::StructuredContentVec(__self_0) => {
                    EntryItemMatchType::StructuredContentVec(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for EntryItemMatchType {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for EntryItemMatchType {
        #[inline]
        fn eq(&self, other: &EntryItemMatchType) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
                && match (self, other) {
                    (
                        EntryItemMatchType::String(__self_0),
                        EntryItemMatchType::String(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        EntryItemMatchType::Integer(__self_0),
                        EntryItemMatchType::Integer(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        EntryItemMatchType::StructuredContentVec(__self_0),
                        EntryItemMatchType::StructuredContentVec(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for EntryItemMatchType {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    EntryItemMatchType::String(ref __field0) => {
                        _serde::Serialize::serialize(__field0, __serializer)
                    }
                    EntryItemMatchType::Integer(ref __field0) => {
                        _serde::Serialize::serialize(__field0, __serializer)
                    }
                    EntryItemMatchType::StructuredContentVec(ref __field0) => {
                        _serde::Serialize::serialize(__field0, __serializer)
                    }
                }
            }
        }
    };
    /// The object holding all html & information about an entry.
    /// _There is only 1 per entry_.
    pub struct StructuredContent {
        /// Identifier to mark the start of each entry's content.
        ///
        /// This should _always_ be `"type": "structured-content"` in the file.
        /// If not, the dictionary is not valid.
        #[serde(rename = "type")]
        pub content_type: String,
        /// Contains the main content of the entry.
        /// _(see: [`ContentMatchType`] )_.
        ///
        /// Will _always_ be either an `Element (obj)` or a `Content (array)` _(ie: Never a String)_.
        pub content: ContentMatchType,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for StructuredContent {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "StructuredContent",
                "content_type",
                &self.content_type,
                "content",
                &&self.content,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for StructuredContent {
        #[inline]
        fn clone(&self) -> StructuredContent {
            StructuredContent {
                content_type: ::core::clone::Clone::clone(&self.content_type),
                content: ::core::clone::Clone::clone(&self.content),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for StructuredContent {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for StructuredContent {
        #[inline]
        fn eq(&self, other: &StructuredContent) -> bool {
            self.content_type == other.content_type && self.content == other.content
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for StructuredContent {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "StructuredContent",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "type",
                    &self.content_type,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "content",
                    &self.content,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for StructuredContent {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "type" => _serde::__private::Ok(__Field::__field0),
                            "content" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"type" => _serde::__private::Ok(__Field::__field0),
                            b"content" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<StructuredContent>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = StructuredContent;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct StructuredContent",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct StructuredContent with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            ContentMatchType,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct StructuredContent with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(StructuredContent {
                            content_type: __field0,
                            content: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<ContentMatchType> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("type"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "content",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ContentMatchType,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("type")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("content")?
                            }
                        };
                        _serde::__private::Ok(StructuredContent {
                            content_type: __field0,
                            content: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["type", "content"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "StructuredContent",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<StructuredContent>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    /// A match type to deserialize any `Content` type.
    #[serde(untagged)]
    pub enum ContentMatchType {
        String(String),
        /// A single html element.
        /// See: [`HtmlTag`].
        ///
        /// Most likely a [`HtmlTag::Anchor`] element.
        /// If so, the definition contains a reference to another entry.
        Element(Box<Element>),
        /// An array of html elements.
        /// See: [`HtmlTag`].
        ///
        Content(Vec<Element>),
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ContentMatchType {
        #[inline]
        fn clone(&self) -> ContentMatchType {
            match self {
                ContentMatchType::String(__self_0) => {
                    ContentMatchType::String(::core::clone::Clone::clone(__self_0))
                }
                ContentMatchType::Element(__self_0) => {
                    ContentMatchType::Element(::core::clone::Clone::clone(__self_0))
                }
                ContentMatchType::Content(__self_0) => {
                    ContentMatchType::Content(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ContentMatchType {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                ContentMatchType::String(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "String",
                        &__self_0,
                    )
                }
                ContentMatchType::Element(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Element",
                        &__self_0,
                    )
                }
                ContentMatchType::Content(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Content",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ContentMatchType {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ContentMatchType {
        #[inline]
        fn eq(&self, other: &ContentMatchType) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
                && match (self, other) {
                    (
                        ContentMatchType::String(__self_0),
                        ContentMatchType::String(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        ContentMatchType::Element(__self_0),
                        ContentMatchType::Element(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        ContentMatchType::Content(__self_0),
                        ContentMatchType::Content(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ContentMatchType {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    ContentMatchType::String(ref __field0) => {
                        _serde::Serialize::serialize(__field0, __serializer)
                    }
                    ContentMatchType::Element(ref __field0) => {
                        _serde::Serialize::serialize(__field0, __serializer)
                    }
                    ContentMatchType::Content(ref __field0) => {
                        _serde::Serialize::serialize(__field0, __serializer)
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ContentMatchType {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                let __content = <_serde::__private::de::Content as _serde::Deserialize>::deserialize(
                    __deserializer,
                )?;
                let __deserializer = _serde::__private::de::ContentRefDeserializer::<
                    __D::Error,
                >::new(&__content);
                if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                    <String as _serde::Deserialize>::deserialize(__deserializer),
                    ContentMatchType::String,
                ) {
                    return _serde::__private::Ok(__ok);
                }
                if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                    <Box<Element> as _serde::Deserialize>::deserialize(__deserializer),
                    ContentMatchType::Element,
                ) {
                    return _serde::__private::Ok(__ok);
                }
                if let _serde::__private::Ok(__ok) = _serde::__private::Result::map(
                    <Vec<Element> as _serde::Deserialize>::deserialize(__deserializer),
                    ContentMatchType::Content,
                ) {
                    return _serde::__private::Ok(__ok);
                }
                _serde::__private::Err(
                    _serde::de::Error::custom(
                        "data did not match any variant of untagged enum ContentMatchType",
                    ),
                )
            }
        }
    };
    /// The 'header', and `structured-content`
    /// of a `term_bank_${i}.json` entry item.
    pub struct TermEntryItem {
        pub expression: String,
        pub reading: String,
        pub def_tags: Option<String>,
        pub rules: String,
        pub score: i128,
        pub structured_content: Vec<StructuredContent>,
        pub sequence: i128,
        pub term_tags: String,
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TermEntryItem {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "TermEntryItem",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "expression",
                    &self.expression,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "reading",
                    &self.reading,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "def_tags",
                    &self.def_tags,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "rules",
                    &self.rules,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "score",
                    &self.score,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "structured_content",
                    &self.structured_content,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "sequence",
                    &self.sequence,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "term_tags",
                    &self.term_tags,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TermEntryItem {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "expression" => _serde::__private::Ok(__Field::__field0),
                            "reading" => _serde::__private::Ok(__Field::__field1),
                            "def_tags" => _serde::__private::Ok(__Field::__field2),
                            "rules" => _serde::__private::Ok(__Field::__field3),
                            "score" => _serde::__private::Ok(__Field::__field4),
                            "structured_content" => {
                                _serde::__private::Ok(__Field::__field5)
                            }
                            "sequence" => _serde::__private::Ok(__Field::__field6),
                            "term_tags" => _serde::__private::Ok(__Field::__field7),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"expression" => _serde::__private::Ok(__Field::__field0),
                            b"reading" => _serde::__private::Ok(__Field::__field1),
                            b"def_tags" => _serde::__private::Ok(__Field::__field2),
                            b"rules" => _serde::__private::Ok(__Field::__field3),
                            b"score" => _serde::__private::Ok(__Field::__field4),
                            b"structured_content" => {
                                _serde::__private::Ok(__Field::__field5)
                            }
                            b"sequence" => _serde::__private::Ok(__Field::__field6),
                            b"term_tags" => _serde::__private::Ok(__Field::__field7),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<TermEntryItem>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TermEntryItem;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct TermEntryItem",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct TermEntryItem with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct TermEntryItem with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct TermEntryItem with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct TermEntryItem with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            i128,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct TermEntryItem with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            Vec<StructuredContent>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct TermEntryItem with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field6 = match _serde::de::SeqAccess::next_element::<
                            i128,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        6usize,
                                        &"struct TermEntryItem with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field7 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        7usize,
                                        &"struct TermEntryItem with 8 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(TermEntryItem {
                            expression: __field0,
                            reading: __field1,
                            def_tags: __field2,
                            rules: __field3,
                            score: __field4,
                            structured_content: __field5,
                            sequence: __field6,
                            term_tags: __field7,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<i128> = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<
                            Vec<StructuredContent>,
                        > = _serde::__private::None;
                        let mut __field6: _serde::__private::Option<i128> = _serde::__private::None;
                        let mut __field7: _serde::__private::Option<String> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "expression",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "reading",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "def_tags",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("rules"),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("score"),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i128>(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "structured_content",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<StructuredContent>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "sequence",
                                            ),
                                        );
                                    }
                                    __field6 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i128>(&mut __map)?,
                                    );
                                }
                                __Field::__field7 => {
                                    if _serde::__private::Option::is_some(&__field7) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "term_tags",
                                            ),
                                        );
                                    }
                                    __field7 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("expression")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("reading")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("def_tags")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("rules")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("score")?
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("structured_content")?
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("sequence")?
                            }
                        };
                        let __field7 = match __field7 {
                            _serde::__private::Some(__field7) => __field7,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("term_tags")?
                            }
                        };
                        _serde::__private::Ok(TermEntryItem {
                            expression: __field0,
                            reading: __field1,
                            def_tags: __field2,
                            rules: __field3,
                            score: __field4,
                            structured_content: __field5,
                            sequence: __field6,
                            term_tags: __field7,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "expression",
                    "reading",
                    "def_tags",
                    "rules",
                    "score",
                    "structured_content",
                    "sequence",
                    "term_tags",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "TermEntryItem",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<TermEntryItem>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::clone::Clone for TermEntryItem {
        #[inline]
        fn clone(&self) -> TermEntryItem {
            TermEntryItem {
                expression: ::core::clone::Clone::clone(&self.expression),
                reading: ::core::clone::Clone::clone(&self.reading),
                def_tags: ::core::clone::Clone::clone(&self.def_tags),
                rules: ::core::clone::Clone::clone(&self.rules),
                score: ::core::clone::Clone::clone(&self.score),
                structured_content: ::core::clone::Clone::clone(
                    &self.structured_content,
                ),
                sequence: ::core::clone::Clone::clone(&self.sequence),
                term_tags: ::core::clone::Clone::clone(&self.term_tags),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TermEntryItem {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "expression",
                "reading",
                "def_tags",
                "rules",
                "score",
                "structured_content",
                "sequence",
                "term_tags",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.expression,
                &self.reading,
                &self.def_tags,
                &self.rules,
                &self.score,
                &self.structured_content,
                &self.sequence,
                &&self.term_tags,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "TermEntryItem",
                names,
                values,
            )
        }
    }
    #[serde(rename_all = "lowercase")]
    pub enum ImageRendering {
        Auto,
        Pixelated,
        CrispEdges,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ImageRendering {
        #[inline]
        fn clone(&self) -> ImageRendering {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for ImageRendering {}
    #[automatically_derived]
    impl ::core::fmt::Debug for ImageRendering {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    ImageRendering::Auto => "Auto",
                    ImageRendering::Pixelated => "Pixelated",
                    ImageRendering::CrispEdges => "CrispEdges",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ImageRendering {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ImageRendering {
        #[inline]
        fn eq(&self, other: &ImageRendering) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for ImageRendering {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for ImageRendering {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_discr, state)
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ImageRendering {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    ImageRendering::Auto => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ImageRendering",
                            0u32,
                            "auto",
                        )
                    }
                    ImageRendering::Pixelated => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ImageRendering",
                            1u32,
                            "pixelated",
                        )
                    }
                    ImageRendering::CrispEdges => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ImageRendering",
                            2u32,
                            "crispedges",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ImageRendering {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 3",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "auto" => _serde::__private::Ok(__Field::__field0),
                            "pixelated" => _serde::__private::Ok(__Field::__field1),
                            "crispedges" => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"auto" => _serde::__private::Ok(__Field::__field0),
                            b"pixelated" => _serde::__private::Ok(__Field::__field1),
                            b"crispedges" => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ImageRendering>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ImageRendering;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum ImageRendering",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(ImageRendering::Auto)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(ImageRendering::Pixelated)
                            }
                            (__Field::__field2, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(ImageRendering::CrispEdges)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "auto",
                    "pixelated",
                    "crispedges",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "ImageRendering",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ImageRendering>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[serde(rename_all = "lowercase")]
    pub enum ImageAppearance {
        Auto,
        Monochrome,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ImageAppearance {
        #[inline]
        fn clone(&self) -> ImageAppearance {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for ImageAppearance {}
    #[automatically_derived]
    impl ::core::fmt::Debug for ImageAppearance {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    ImageAppearance::Auto => "Auto",
                    ImageAppearance::Monochrome => "Monochrome",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ImageAppearance {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ImageAppearance {
        #[inline]
        fn eq(&self, other: &ImageAppearance) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for ImageAppearance {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for ImageAppearance {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_discr, state)
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ImageAppearance {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    ImageAppearance::Auto => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ImageAppearance",
                            0u32,
                            "auto",
                        )
                    }
                    ImageAppearance::Monochrome => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ImageAppearance",
                            1u32,
                            "monochrome",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ImageAppearance {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 2",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "auto" => _serde::__private::Ok(__Field::__field0),
                            "monochrome" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"auto" => _serde::__private::Ok(__Field::__field0),
                            b"monochrome" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ImageAppearance>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ImageAppearance;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum ImageAppearance",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(ImageAppearance::Auto)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(ImageAppearance::Monochrome)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["auto", "monochrome"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "ImageAppearance",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ImageAppearance>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[serde(rename_all = "lowercase")]
    pub enum HtmlTag {
        #[serde(rename = "ruby")]
        Ruby,
        #[serde(rename = "rt")]
        RubyText,
        #[serde(rename = "rp")]
        RubyParenthesis,
        Table,
        #[serde(rename = "td")]
        TableData,
        #[serde(rename = "th")]
        TableHeader,
        #[serde(rename = "tb")]
        TableBody,
        #[serde(rename = "tf")]
        TableFooter,
        #[serde(rename = "tr")]
        TableRow,
        #[serde(rename = "a")]
        Anchor,
        Span,
        Div,
        #[serde(rename = "ol")]
        OrderedList,
        #[serde(rename = "ul")]
        UnorderedList,
        #[serde(rename = "li")]
        ListItem,
        Details,
        Summary,
        #[serde(rename = "br")]
        Break,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for HtmlTag {
        #[inline]
        fn clone(&self) -> HtmlTag {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for HtmlTag {}
    #[automatically_derived]
    impl ::core::fmt::Debug for HtmlTag {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    HtmlTag::Ruby => "Ruby",
                    HtmlTag::RubyText => "RubyText",
                    HtmlTag::RubyParenthesis => "RubyParenthesis",
                    HtmlTag::Table => "Table",
                    HtmlTag::TableData => "TableData",
                    HtmlTag::TableHeader => "TableHeader",
                    HtmlTag::TableBody => "TableBody",
                    HtmlTag::TableFooter => "TableFooter",
                    HtmlTag::TableRow => "TableRow",
                    HtmlTag::Anchor => "Anchor",
                    HtmlTag::Span => "Span",
                    HtmlTag::Div => "Div",
                    HtmlTag::OrderedList => "OrderedList",
                    HtmlTag::UnorderedList => "UnorderedList",
                    HtmlTag::ListItem => "ListItem",
                    HtmlTag::Details => "Details",
                    HtmlTag::Summary => "Summary",
                    HtmlTag::Break => "Break",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for HtmlTag {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for HtmlTag {
        #[inline]
        fn eq(&self, other: &HtmlTag) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for HtmlTag {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for HtmlTag {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_discr, state)
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for HtmlTag {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    HtmlTag::Ruby => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "HtmlTag",
                            0u32,
                            "ruby",
                        )
                    }
                    HtmlTag::RubyText => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "HtmlTag",
                            1u32,
                            "rt",
                        )
                    }
                    HtmlTag::RubyParenthesis => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "HtmlTag",
                            2u32,
                            "rp",
                        )
                    }
                    HtmlTag::Table => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "HtmlTag",
                            3u32,
                            "table",
                        )
                    }
                    HtmlTag::TableData => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "HtmlTag",
                            4u32,
                            "td",
                        )
                    }
                    HtmlTag::TableHeader => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "HtmlTag",
                            5u32,
                            "th",
                        )
                    }
                    HtmlTag::TableBody => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "HtmlTag",
                            6u32,
                            "tb",
                        )
                    }
                    HtmlTag::TableFooter => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "HtmlTag",
                            7u32,
                            "tf",
                        )
                    }
                    HtmlTag::TableRow => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "HtmlTag",
                            8u32,
                            "tr",
                        )
                    }
                    HtmlTag::Anchor => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "HtmlTag",
                            9u32,
                            "a",
                        )
                    }
                    HtmlTag::Span => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "HtmlTag",
                            10u32,
                            "span",
                        )
                    }
                    HtmlTag::Div => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "HtmlTag",
                            11u32,
                            "div",
                        )
                    }
                    HtmlTag::OrderedList => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "HtmlTag",
                            12u32,
                            "ol",
                        )
                    }
                    HtmlTag::UnorderedList => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "HtmlTag",
                            13u32,
                            "ul",
                        )
                    }
                    HtmlTag::ListItem => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "HtmlTag",
                            14u32,
                            "li",
                        )
                    }
                    HtmlTag::Details => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "HtmlTag",
                            15u32,
                            "details",
                        )
                    }
                    HtmlTag::Summary => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "HtmlTag",
                            16u32,
                            "summary",
                        )
                    }
                    HtmlTag::Break => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "HtmlTag",
                            17u32,
                            "br",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for HtmlTag {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __field8,
                    __field9,
                    __field10,
                    __field11,
                    __field12,
                    __field13,
                    __field14,
                    __field15,
                    __field16,
                    __field17,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            8u64 => _serde::__private::Ok(__Field::__field8),
                            9u64 => _serde::__private::Ok(__Field::__field9),
                            10u64 => _serde::__private::Ok(__Field::__field10),
                            11u64 => _serde::__private::Ok(__Field::__field11),
                            12u64 => _serde::__private::Ok(__Field::__field12),
                            13u64 => _serde::__private::Ok(__Field::__field13),
                            14u64 => _serde::__private::Ok(__Field::__field14),
                            15u64 => _serde::__private::Ok(__Field::__field15),
                            16u64 => _serde::__private::Ok(__Field::__field16),
                            17u64 => _serde::__private::Ok(__Field::__field17),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 18",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "ruby" => _serde::__private::Ok(__Field::__field0),
                            "rt" => _serde::__private::Ok(__Field::__field1),
                            "rp" => _serde::__private::Ok(__Field::__field2),
                            "table" => _serde::__private::Ok(__Field::__field3),
                            "td" => _serde::__private::Ok(__Field::__field4),
                            "th" => _serde::__private::Ok(__Field::__field5),
                            "tb" => _serde::__private::Ok(__Field::__field6),
                            "tf" => _serde::__private::Ok(__Field::__field7),
                            "tr" => _serde::__private::Ok(__Field::__field8),
                            "a" => _serde::__private::Ok(__Field::__field9),
                            "span" => _serde::__private::Ok(__Field::__field10),
                            "div" => _serde::__private::Ok(__Field::__field11),
                            "ol" => _serde::__private::Ok(__Field::__field12),
                            "ul" => _serde::__private::Ok(__Field::__field13),
                            "li" => _serde::__private::Ok(__Field::__field14),
                            "details" => _serde::__private::Ok(__Field::__field15),
                            "summary" => _serde::__private::Ok(__Field::__field16),
                            "br" => _serde::__private::Ok(__Field::__field17),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"ruby" => _serde::__private::Ok(__Field::__field0),
                            b"rt" => _serde::__private::Ok(__Field::__field1),
                            b"rp" => _serde::__private::Ok(__Field::__field2),
                            b"table" => _serde::__private::Ok(__Field::__field3),
                            b"td" => _serde::__private::Ok(__Field::__field4),
                            b"th" => _serde::__private::Ok(__Field::__field5),
                            b"tb" => _serde::__private::Ok(__Field::__field6),
                            b"tf" => _serde::__private::Ok(__Field::__field7),
                            b"tr" => _serde::__private::Ok(__Field::__field8),
                            b"a" => _serde::__private::Ok(__Field::__field9),
                            b"span" => _serde::__private::Ok(__Field::__field10),
                            b"div" => _serde::__private::Ok(__Field::__field11),
                            b"ol" => _serde::__private::Ok(__Field::__field12),
                            b"ul" => _serde::__private::Ok(__Field::__field13),
                            b"li" => _serde::__private::Ok(__Field::__field14),
                            b"details" => _serde::__private::Ok(__Field::__field15),
                            b"summary" => _serde::__private::Ok(__Field::__field16),
                            b"br" => _serde::__private::Ok(__Field::__field17),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<HtmlTag>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = HtmlTag;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum HtmlTag",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(HtmlTag::Ruby)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(HtmlTag::RubyText)
                            }
                            (__Field::__field2, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(HtmlTag::RubyParenthesis)
                            }
                            (__Field::__field3, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(HtmlTag::Table)
                            }
                            (__Field::__field4, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(HtmlTag::TableData)
                            }
                            (__Field::__field5, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(HtmlTag::TableHeader)
                            }
                            (__Field::__field6, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(HtmlTag::TableBody)
                            }
                            (__Field::__field7, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(HtmlTag::TableFooter)
                            }
                            (__Field::__field8, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(HtmlTag::TableRow)
                            }
                            (__Field::__field9, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(HtmlTag::Anchor)
                            }
                            (__Field::__field10, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(HtmlTag::Span)
                            }
                            (__Field::__field11, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(HtmlTag::Div)
                            }
                            (__Field::__field12, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(HtmlTag::OrderedList)
                            }
                            (__Field::__field13, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(HtmlTag::UnorderedList)
                            }
                            (__Field::__field14, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(HtmlTag::ListItem)
                            }
                            (__Field::__field15, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(HtmlTag::Details)
                            }
                            (__Field::__field16, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(HtmlTag::Summary)
                            }
                            (__Field::__field17, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(HtmlTag::Break)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "ruby",
                    "rt",
                    "rp",
                    "table",
                    "td",
                    "th",
                    "tb",
                    "tf",
                    "tr",
                    "a",
                    "span",
                    "div",
                    "ol",
                    "ul",
                    "li",
                    "details",
                    "summary",
                    "br",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "HtmlTag",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<HtmlTag>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[serde(rename_all = "lowercase")]
    pub enum VerticalAlign {
        Baseline,
        Sub,
        Super,
        TextTop,
        TextBottom,
        Middle,
        Top,
        Bottom,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for VerticalAlign {
        #[inline]
        fn clone(&self) -> VerticalAlign {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for VerticalAlign {}
    #[automatically_derived]
    impl ::core::fmt::Debug for VerticalAlign {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    VerticalAlign::Baseline => "Baseline",
                    VerticalAlign::Sub => "Sub",
                    VerticalAlign::Super => "Super",
                    VerticalAlign::TextTop => "TextTop",
                    VerticalAlign::TextBottom => "TextBottom",
                    VerticalAlign::Middle => "Middle",
                    VerticalAlign::Top => "Top",
                    VerticalAlign::Bottom => "Bottom",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for VerticalAlign {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for VerticalAlign {
        #[inline]
        fn eq(&self, other: &VerticalAlign) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for VerticalAlign {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for VerticalAlign {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_discr, state)
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for VerticalAlign {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    VerticalAlign::Baseline => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "VerticalAlign",
                            0u32,
                            "baseline",
                        )
                    }
                    VerticalAlign::Sub => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "VerticalAlign",
                            1u32,
                            "sub",
                        )
                    }
                    VerticalAlign::Super => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "VerticalAlign",
                            2u32,
                            "super",
                        )
                    }
                    VerticalAlign::TextTop => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "VerticalAlign",
                            3u32,
                            "texttop",
                        )
                    }
                    VerticalAlign::TextBottom => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "VerticalAlign",
                            4u32,
                            "textbottom",
                        )
                    }
                    VerticalAlign::Middle => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "VerticalAlign",
                            5u32,
                            "middle",
                        )
                    }
                    VerticalAlign::Top => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "VerticalAlign",
                            6u32,
                            "top",
                        )
                    }
                    VerticalAlign::Bottom => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "VerticalAlign",
                            7u32,
                            "bottom",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for VerticalAlign {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 8",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "baseline" => _serde::__private::Ok(__Field::__field0),
                            "sub" => _serde::__private::Ok(__Field::__field1),
                            "super" => _serde::__private::Ok(__Field::__field2),
                            "texttop" => _serde::__private::Ok(__Field::__field3),
                            "textbottom" => _serde::__private::Ok(__Field::__field4),
                            "middle" => _serde::__private::Ok(__Field::__field5),
                            "top" => _serde::__private::Ok(__Field::__field6),
                            "bottom" => _serde::__private::Ok(__Field::__field7),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"baseline" => _serde::__private::Ok(__Field::__field0),
                            b"sub" => _serde::__private::Ok(__Field::__field1),
                            b"super" => _serde::__private::Ok(__Field::__field2),
                            b"texttop" => _serde::__private::Ok(__Field::__field3),
                            b"textbottom" => _serde::__private::Ok(__Field::__field4),
                            b"middle" => _serde::__private::Ok(__Field::__field5),
                            b"top" => _serde::__private::Ok(__Field::__field6),
                            b"bottom" => _serde::__private::Ok(__Field::__field7),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<VerticalAlign>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = VerticalAlign;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum VerticalAlign",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(VerticalAlign::Baseline)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(VerticalAlign::Sub)
                            }
                            (__Field::__field2, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(VerticalAlign::Super)
                            }
                            (__Field::__field3, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(VerticalAlign::TextTop)
                            }
                            (__Field::__field4, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(VerticalAlign::TextBottom)
                            }
                            (__Field::__field5, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(VerticalAlign::Middle)
                            }
                            (__Field::__field6, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(VerticalAlign::Top)
                            }
                            (__Field::__field7, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(VerticalAlign::Bottom)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "baseline",
                    "sub",
                    "super",
                    "texttop",
                    "textbottom",
                    "middle",
                    "top",
                    "bottom",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "VerticalAlign",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<VerticalAlign>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[serde(rename_all = "lowercase")]
    pub enum TextDecorationLine {
        Underline,
        Overline,
        LineThrough,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TextDecorationLine {
        #[inline]
        fn clone(&self) -> TextDecorationLine {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for TextDecorationLine {}
    #[automatically_derived]
    impl ::core::fmt::Debug for TextDecorationLine {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    TextDecorationLine::Underline => "Underline",
                    TextDecorationLine::Overline => "Overline",
                    TextDecorationLine::LineThrough => "LineThrough",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TextDecorationLine {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TextDecorationLine {
        #[inline]
        fn eq(&self, other: &TextDecorationLine) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for TextDecorationLine {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for TextDecorationLine {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_discr, state)
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TextDecorationLine {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    TextDecorationLine::Underline => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "TextDecorationLine",
                            0u32,
                            "underline",
                        )
                    }
                    TextDecorationLine::Overline => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "TextDecorationLine",
                            1u32,
                            "overline",
                        )
                    }
                    TextDecorationLine::LineThrough => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "TextDecorationLine",
                            2u32,
                            "linethrough",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TextDecorationLine {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 3",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "underline" => _serde::__private::Ok(__Field::__field0),
                            "overline" => _serde::__private::Ok(__Field::__field1),
                            "linethrough" => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"underline" => _serde::__private::Ok(__Field::__field0),
                            b"overline" => _serde::__private::Ok(__Field::__field1),
                            b"linethrough" => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<TextDecorationLine>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TextDecorationLine;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum TextDecorationLine",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(TextDecorationLine::Underline)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(TextDecorationLine::Overline)
                            }
                            (__Field::__field2, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(TextDecorationLine::LineThrough)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "underline",
                    "overline",
                    "linethrough",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "TextDecorationLine",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<TextDecorationLine>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    pub enum TextDecorationLineOrNone {
        None,
        TextDecorationLine(TextDecorationLine),
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TextDecorationLineOrNone {
        #[inline]
        fn clone(&self) -> TextDecorationLineOrNone {
            let _: ::core::clone::AssertParamIsClone<TextDecorationLine>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for TextDecorationLineOrNone {}
    #[automatically_derived]
    impl ::core::fmt::Debug for TextDecorationLineOrNone {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                TextDecorationLineOrNone::None => {
                    ::core::fmt::Formatter::write_str(f, "None")
                }
                TextDecorationLineOrNone::TextDecorationLine(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "TextDecorationLine",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TextDecorationLineOrNone {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TextDecorationLineOrNone {
        #[inline]
        fn eq(&self, other: &TextDecorationLineOrNone) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
                && match (self, other) {
                    (
                        TextDecorationLineOrNone::TextDecorationLine(__self_0),
                        TextDecorationLineOrNone::TextDecorationLine(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    _ => true,
                }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for TextDecorationLineOrNone {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<TextDecorationLine>;
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for TextDecorationLineOrNone {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_discr, state);
            match self {
                TextDecorationLineOrNone::TextDecorationLine(__self_0) => {
                    ::core::hash::Hash::hash(__self_0, state)
                }
                _ => {}
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TextDecorationLineOrNone {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    TextDecorationLineOrNone::None => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "TextDecorationLineOrNone",
                            0u32,
                            "None",
                        )
                    }
                    TextDecorationLineOrNone::TextDecorationLine(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "TextDecorationLineOrNone",
                            1u32,
                            "TextDecorationLine",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TextDecorationLineOrNone {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 2",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "None" => _serde::__private::Ok(__Field::__field0),
                            "TextDecorationLine" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"None" => _serde::__private::Ok(__Field::__field0),
                            b"TextDecorationLine" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<TextDecorationLineOrNone>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TextDecorationLineOrNone;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum TextDecorationLineOrNone",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(TextDecorationLineOrNone::None)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        TextDecorationLine,
                                    >(__variant),
                                    TextDecorationLineOrNone::TextDecorationLine,
                                )
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "None",
                    "TextDecorationLine",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "TextDecorationLineOrNone",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            TextDecorationLineOrNone,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[serde(rename_all = "lowercase")]
    pub enum TextDecorationStyle {
        Solid,
        Double,
        Dotted,
        Dashed,
        Wavy,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TextDecorationStyle {
        #[inline]
        fn clone(&self) -> TextDecorationStyle {
            match self {
                TextDecorationStyle::Solid => TextDecorationStyle::Solid,
                TextDecorationStyle::Double => TextDecorationStyle::Double,
                TextDecorationStyle::Dotted => TextDecorationStyle::Dotted,
                TextDecorationStyle::Dashed => TextDecorationStyle::Dashed,
                TextDecorationStyle::Wavy => TextDecorationStyle::Wavy,
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TextDecorationStyle {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    TextDecorationStyle::Solid => "Solid",
                    TextDecorationStyle::Double => "Double",
                    TextDecorationStyle::Dotted => "Dotted",
                    TextDecorationStyle::Dashed => "Dashed",
                    TextDecorationStyle::Wavy => "Wavy",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TextDecorationStyle {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TextDecorationStyle {
        #[inline]
        fn eq(&self, other: &TextDecorationStyle) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TextDecorationStyle {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    TextDecorationStyle::Solid => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "TextDecorationStyle",
                            0u32,
                            "solid",
                        )
                    }
                    TextDecorationStyle::Double => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "TextDecorationStyle",
                            1u32,
                            "double",
                        )
                    }
                    TextDecorationStyle::Dotted => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "TextDecorationStyle",
                            2u32,
                            "dotted",
                        )
                    }
                    TextDecorationStyle::Dashed => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "TextDecorationStyle",
                            3u32,
                            "dashed",
                        )
                    }
                    TextDecorationStyle::Wavy => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "TextDecorationStyle",
                            4u32,
                            "wavy",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TextDecorationStyle {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 5",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "solid" => _serde::__private::Ok(__Field::__field0),
                            "double" => _serde::__private::Ok(__Field::__field1),
                            "dotted" => _serde::__private::Ok(__Field::__field2),
                            "dashed" => _serde::__private::Ok(__Field::__field3),
                            "wavy" => _serde::__private::Ok(__Field::__field4),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"solid" => _serde::__private::Ok(__Field::__field0),
                            b"double" => _serde::__private::Ok(__Field::__field1),
                            b"dotted" => _serde::__private::Ok(__Field::__field2),
                            b"dashed" => _serde::__private::Ok(__Field::__field3),
                            b"wavy" => _serde::__private::Ok(__Field::__field4),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<TextDecorationStyle>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TextDecorationStyle;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum TextDecorationStyle",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(TextDecorationStyle::Solid)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(TextDecorationStyle::Double)
                            }
                            (__Field::__field2, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(TextDecorationStyle::Dotted)
                            }
                            (__Field::__field3, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(TextDecorationStyle::Dashed)
                            }
                            (__Field::__field4, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(TextDecorationStyle::Wavy)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "solid",
                    "double",
                    "dotted",
                    "dashed",
                    "wavy",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "TextDecorationStyle",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<TextDecorationStyle>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[serde(rename_all = "lowercase")]
    pub enum FontStyle {
        Normal,
        Italic,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for FontStyle {
        #[inline]
        fn clone(&self) -> FontStyle {
            match self {
                FontStyle::Normal => FontStyle::Normal,
                FontStyle::Italic => FontStyle::Italic,
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for FontStyle {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    FontStyle::Normal => "Normal",
                    FontStyle::Italic => "Italic",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for FontStyle {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for FontStyle {
        #[inline]
        fn eq(&self, other: &FontStyle) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for FontStyle {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    FontStyle::Normal => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "FontStyle",
                            0u32,
                            "normal",
                        )
                    }
                    FontStyle::Italic => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "FontStyle",
                            1u32,
                            "italic",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for FontStyle {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 2",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "normal" => _serde::__private::Ok(__Field::__field0),
                            "italic" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"normal" => _serde::__private::Ok(__Field::__field0),
                            b"italic" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<FontStyle>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = FontStyle;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum FontStyle",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(FontStyle::Normal)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(FontStyle::Italic)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["normal", "italic"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "FontStyle",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<FontStyle>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[serde(rename_all = "lowercase")]
    pub enum FontWeight {
        Normal,
        Bold,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for FontWeight {
        #[inline]
        fn clone(&self) -> FontWeight {
            match self {
                FontWeight::Normal => FontWeight::Normal,
                FontWeight::Bold => FontWeight::Bold,
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for FontWeight {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    FontWeight::Normal => "Normal",
                    FontWeight::Bold => "Bold",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for FontWeight {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for FontWeight {
        #[inline]
        fn eq(&self, other: &FontWeight) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for FontWeight {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    FontWeight::Normal => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "FontWeight",
                            0u32,
                            "normal",
                        )
                    }
                    FontWeight::Bold => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "FontWeight",
                            1u32,
                            "bold",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for FontWeight {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 2",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "normal" => _serde::__private::Ok(__Field::__field0),
                            "bold" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"normal" => _serde::__private::Ok(__Field::__field0),
                            b"bold" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<FontWeight>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = FontWeight;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum FontWeight",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(FontWeight::Normal)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(FontWeight::Bold)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["normal", "bold"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "FontWeight",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<FontWeight>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[serde(rename_all = "lowercase")]
    pub enum WordBreak {
        Normal,
        BreakAll,
        KeepAll,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for WordBreak {
        #[inline]
        fn clone(&self) -> WordBreak {
            match self {
                WordBreak::Normal => WordBreak::Normal,
                WordBreak::BreakAll => WordBreak::BreakAll,
                WordBreak::KeepAll => WordBreak::KeepAll,
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for WordBreak {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    WordBreak::Normal => "Normal",
                    WordBreak::BreakAll => "BreakAll",
                    WordBreak::KeepAll => "KeepAll",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for WordBreak {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for WordBreak {
        #[inline]
        fn eq(&self, other: &WordBreak) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for WordBreak {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    WordBreak::Normal => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "WordBreak",
                            0u32,
                            "normal",
                        )
                    }
                    WordBreak::BreakAll => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "WordBreak",
                            1u32,
                            "breakall",
                        )
                    }
                    WordBreak::KeepAll => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "WordBreak",
                            2u32,
                            "keepall",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for WordBreak {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 3",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "normal" => _serde::__private::Ok(__Field::__field0),
                            "breakall" => _serde::__private::Ok(__Field::__field1),
                            "keepall" => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"normal" => _serde::__private::Ok(__Field::__field0),
                            b"breakall" => _serde::__private::Ok(__Field::__field1),
                            b"keepall" => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<WordBreak>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = WordBreak;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum WordBreak",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(WordBreak::Normal)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(WordBreak::BreakAll)
                            }
                            (__Field::__field2, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(WordBreak::KeepAll)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "normal",
                    "breakall",
                    "keepall",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "WordBreak",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<WordBreak>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    pub enum TextAlign {
        Start,
        End,
        Left,
        Right,
        Center,
        Justify,
        JustifyAll,
        MatchParent,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TextAlign {
        #[inline]
        fn clone(&self) -> TextAlign {
            match self {
                TextAlign::Start => TextAlign::Start,
                TextAlign::End => TextAlign::End,
                TextAlign::Left => TextAlign::Left,
                TextAlign::Right => TextAlign::Right,
                TextAlign::Center => TextAlign::Center,
                TextAlign::Justify => TextAlign::Justify,
                TextAlign::JustifyAll => TextAlign::JustifyAll,
                TextAlign::MatchParent => TextAlign::MatchParent,
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TextAlign {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    TextAlign::Start => "Start",
                    TextAlign::End => "End",
                    TextAlign::Left => "Left",
                    TextAlign::Right => "Right",
                    TextAlign::Center => "Center",
                    TextAlign::Justify => "Justify",
                    TextAlign::JustifyAll => "JustifyAll",
                    TextAlign::MatchParent => "MatchParent",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TextAlign {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TextAlign {
        #[inline]
        fn eq(&self, other: &TextAlign) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TextAlign {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    TextAlign::Start => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "TextAlign",
                            0u32,
                            "Start",
                        )
                    }
                    TextAlign::End => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "TextAlign",
                            1u32,
                            "End",
                        )
                    }
                    TextAlign::Left => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "TextAlign",
                            2u32,
                            "Left",
                        )
                    }
                    TextAlign::Right => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "TextAlign",
                            3u32,
                            "Right",
                        )
                    }
                    TextAlign::Center => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "TextAlign",
                            4u32,
                            "Center",
                        )
                    }
                    TextAlign::Justify => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "TextAlign",
                            5u32,
                            "Justify",
                        )
                    }
                    TextAlign::JustifyAll => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "TextAlign",
                            6u32,
                            "JustifyAll",
                        )
                    }
                    TextAlign::MatchParent => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "TextAlign",
                            7u32,
                            "MatchParent",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TextAlign {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 8",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Start" => _serde::__private::Ok(__Field::__field0),
                            "End" => _serde::__private::Ok(__Field::__field1),
                            "Left" => _serde::__private::Ok(__Field::__field2),
                            "Right" => _serde::__private::Ok(__Field::__field3),
                            "Center" => _serde::__private::Ok(__Field::__field4),
                            "Justify" => _serde::__private::Ok(__Field::__field5),
                            "JustifyAll" => _serde::__private::Ok(__Field::__field6),
                            "MatchParent" => _serde::__private::Ok(__Field::__field7),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Start" => _serde::__private::Ok(__Field::__field0),
                            b"End" => _serde::__private::Ok(__Field::__field1),
                            b"Left" => _serde::__private::Ok(__Field::__field2),
                            b"Right" => _serde::__private::Ok(__Field::__field3),
                            b"Center" => _serde::__private::Ok(__Field::__field4),
                            b"Justify" => _serde::__private::Ok(__Field::__field5),
                            b"JustifyAll" => _serde::__private::Ok(__Field::__field6),
                            b"MatchParent" => _serde::__private::Ok(__Field::__field7),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<TextAlign>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TextAlign;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum TextAlign",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(TextAlign::Start)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(TextAlign::End)
                            }
                            (__Field::__field2, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(TextAlign::Left)
                            }
                            (__Field::__field3, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(TextAlign::Right)
                            }
                            (__Field::__field4, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(TextAlign::Center)
                            }
                            (__Field::__field5, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(TextAlign::Justify)
                            }
                            (__Field::__field6, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(TextAlign::JustifyAll)
                            }
                            (__Field::__field7, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(TextAlign::MatchParent)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "Start",
                    "End",
                    "Left",
                    "Right",
                    "Center",
                    "Justify",
                    "JustifyAll",
                    "MatchParent",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "TextAlign",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<TextAlign>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    pub enum SizeUnits {
        Px,
        Em,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for SizeUnits {
        #[inline]
        fn clone(&self) -> SizeUnits {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for SizeUnits {}
    #[automatically_derived]
    impl ::core::fmt::Debug for SizeUnits {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    SizeUnits::Px => "Px",
                    SizeUnits::Em => "Em",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for SizeUnits {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for SizeUnits {
        #[inline]
        fn eq(&self, other: &SizeUnits) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for SizeUnits {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for SizeUnits {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_discr, state)
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for SizeUnits {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    SizeUnits::Px => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SizeUnits",
                            0u32,
                            "Px",
                        )
                    }
                    SizeUnits::Em => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "SizeUnits",
                            1u32,
                            "Em",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for SizeUnits {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 2",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Px" => _serde::__private::Ok(__Field::__field0),
                            "Em" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Px" => _serde::__private::Ok(__Field::__field0),
                            b"Em" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<SizeUnits>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = SizeUnits;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum SizeUnits",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(SizeUnits::Px)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(SizeUnits::Em)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["Px", "Em"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "SizeUnits",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<SizeUnits>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    pub struct StructuredContentStyle {
        font_style: Option<FontStyle>,
        font_weight: Option<FontWeight>,
        font_size: Option<String>,
        color: Option<String>,
        background: Option<String>,
        background_color: Option<String>,
        text_decoration_line: Option<TextDecorationLineOrNone>,
        text_decoration_style: Option<TextDecorationStyle>,
        text_decoration_color: Option<String>,
        border_color: Option<String>,
        border_style: Option<String>,
        border_radius: Option<String>,
        border_width: Option<String>,
        clip_path: Option<String>,
        vertical_align: Option<VerticalAlign>,
        text_align: Option<TextAlign>,
        text_emphasis: Option<String>,
        text_shadow: Option<String>,
        margin: Option<String>,
        margin_top: Option<String>,
        margin_left: Option<String>,
        margin_right: Option<String>,
        margin_bottom: Option<String>,
        padding: Option<String>,
        padding_top: Option<String>,
        padding_left: Option<String>,
        padding_right: Option<String>,
        padding_bottom: Option<String>,
        word_break: Option<WordBreak>,
        white_space: Option<String>,
        cursor: Option<String>,
        list_style_type: Option<String>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for StructuredContentStyle {
        #[inline]
        fn clone(&self) -> StructuredContentStyle {
            StructuredContentStyle {
                font_style: ::core::clone::Clone::clone(&self.font_style),
                font_weight: ::core::clone::Clone::clone(&self.font_weight),
                font_size: ::core::clone::Clone::clone(&self.font_size),
                color: ::core::clone::Clone::clone(&self.color),
                background: ::core::clone::Clone::clone(&self.background),
                background_color: ::core::clone::Clone::clone(&self.background_color),
                text_decoration_line: ::core::clone::Clone::clone(
                    &self.text_decoration_line,
                ),
                text_decoration_style: ::core::clone::Clone::clone(
                    &self.text_decoration_style,
                ),
                text_decoration_color: ::core::clone::Clone::clone(
                    &self.text_decoration_color,
                ),
                border_color: ::core::clone::Clone::clone(&self.border_color),
                border_style: ::core::clone::Clone::clone(&self.border_style),
                border_radius: ::core::clone::Clone::clone(&self.border_radius),
                border_width: ::core::clone::Clone::clone(&self.border_width),
                clip_path: ::core::clone::Clone::clone(&self.clip_path),
                vertical_align: ::core::clone::Clone::clone(&self.vertical_align),
                text_align: ::core::clone::Clone::clone(&self.text_align),
                text_emphasis: ::core::clone::Clone::clone(&self.text_emphasis),
                text_shadow: ::core::clone::Clone::clone(&self.text_shadow),
                margin: ::core::clone::Clone::clone(&self.margin),
                margin_top: ::core::clone::Clone::clone(&self.margin_top),
                margin_left: ::core::clone::Clone::clone(&self.margin_left),
                margin_right: ::core::clone::Clone::clone(&self.margin_right),
                margin_bottom: ::core::clone::Clone::clone(&self.margin_bottom),
                padding: ::core::clone::Clone::clone(&self.padding),
                padding_top: ::core::clone::Clone::clone(&self.padding_top),
                padding_left: ::core::clone::Clone::clone(&self.padding_left),
                padding_right: ::core::clone::Clone::clone(&self.padding_right),
                padding_bottom: ::core::clone::Clone::clone(&self.padding_bottom),
                word_break: ::core::clone::Clone::clone(&self.word_break),
                white_space: ::core::clone::Clone::clone(&self.white_space),
                cursor: ::core::clone::Clone::clone(&self.cursor),
                list_style_type: ::core::clone::Clone::clone(&self.list_style_type),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for StructuredContentStyle {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "font_style",
                "font_weight",
                "font_size",
                "color",
                "background",
                "background_color",
                "text_decoration_line",
                "text_decoration_style",
                "text_decoration_color",
                "border_color",
                "border_style",
                "border_radius",
                "border_width",
                "clip_path",
                "vertical_align",
                "text_align",
                "text_emphasis",
                "text_shadow",
                "margin",
                "margin_top",
                "margin_left",
                "margin_right",
                "margin_bottom",
                "padding",
                "padding_top",
                "padding_left",
                "padding_right",
                "padding_bottom",
                "word_break",
                "white_space",
                "cursor",
                "list_style_type",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.font_style,
                &self.font_weight,
                &self.font_size,
                &self.color,
                &self.background,
                &self.background_color,
                &self.text_decoration_line,
                &self.text_decoration_style,
                &self.text_decoration_color,
                &self.border_color,
                &self.border_style,
                &self.border_radius,
                &self.border_width,
                &self.clip_path,
                &self.vertical_align,
                &self.text_align,
                &self.text_emphasis,
                &self.text_shadow,
                &self.margin,
                &self.margin_top,
                &self.margin_left,
                &self.margin_right,
                &self.margin_bottom,
                &self.padding,
                &self.padding_top,
                &self.padding_left,
                &self.padding_right,
                &self.padding_bottom,
                &self.word_break,
                &self.white_space,
                &self.cursor,
                &&self.list_style_type,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "StructuredContentStyle",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for StructuredContentStyle {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for StructuredContentStyle {
        #[inline]
        fn eq(&self, other: &StructuredContentStyle) -> bool {
            self.font_style == other.font_style && self.font_weight == other.font_weight
                && self.font_size == other.font_size && self.color == other.color
                && self.background == other.background
                && self.background_color == other.background_color
                && self.text_decoration_line == other.text_decoration_line
                && self.text_decoration_style == other.text_decoration_style
                && self.text_decoration_color == other.text_decoration_color
                && self.border_color == other.border_color
                && self.border_style == other.border_style
                && self.border_radius == other.border_radius
                && self.border_width == other.border_width
                && self.clip_path == other.clip_path
                && self.vertical_align == other.vertical_align
                && self.text_align == other.text_align
                && self.text_emphasis == other.text_emphasis
                && self.text_shadow == other.text_shadow && self.margin == other.margin
                && self.margin_top == other.margin_top
                && self.margin_left == other.margin_left
                && self.margin_right == other.margin_right
                && self.margin_bottom == other.margin_bottom
                && self.padding == other.padding && self.padding_top == other.padding_top
                && self.padding_left == other.padding_left
                && self.padding_right == other.padding_right
                && self.padding_bottom == other.padding_bottom
                && self.word_break == other.word_break
                && self.white_space == other.white_space && self.cursor == other.cursor
                && self.list_style_type == other.list_style_type
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for StructuredContentStyle {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "StructuredContentStyle",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1
                        + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1
                        + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "font_style",
                    &self.font_style,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "font_weight",
                    &self.font_weight,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "font_size",
                    &self.font_size,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "color",
                    &self.color,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "background",
                    &self.background,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "background_color",
                    &self.background_color,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "text_decoration_line",
                    &self.text_decoration_line,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "text_decoration_style",
                    &self.text_decoration_style,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "text_decoration_color",
                    &self.text_decoration_color,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "border_color",
                    &self.border_color,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "border_style",
                    &self.border_style,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "border_radius",
                    &self.border_radius,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "border_width",
                    &self.border_width,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "clip_path",
                    &self.clip_path,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "vertical_align",
                    &self.vertical_align,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "text_align",
                    &self.text_align,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "text_emphasis",
                    &self.text_emphasis,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "text_shadow",
                    &self.text_shadow,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "margin",
                    &self.margin,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "margin_top",
                    &self.margin_top,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "margin_left",
                    &self.margin_left,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "margin_right",
                    &self.margin_right,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "margin_bottom",
                    &self.margin_bottom,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "padding",
                    &self.padding,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "padding_top",
                    &self.padding_top,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "padding_left",
                    &self.padding_left,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "padding_right",
                    &self.padding_right,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "padding_bottom",
                    &self.padding_bottom,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "word_break",
                    &self.word_break,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "white_space",
                    &self.white_space,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "cursor",
                    &self.cursor,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "list_style_type",
                    &self.list_style_type,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for StructuredContentStyle {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __field8,
                    __field9,
                    __field10,
                    __field11,
                    __field12,
                    __field13,
                    __field14,
                    __field15,
                    __field16,
                    __field17,
                    __field18,
                    __field19,
                    __field20,
                    __field21,
                    __field22,
                    __field23,
                    __field24,
                    __field25,
                    __field26,
                    __field27,
                    __field28,
                    __field29,
                    __field30,
                    __field31,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            8u64 => _serde::__private::Ok(__Field::__field8),
                            9u64 => _serde::__private::Ok(__Field::__field9),
                            10u64 => _serde::__private::Ok(__Field::__field10),
                            11u64 => _serde::__private::Ok(__Field::__field11),
                            12u64 => _serde::__private::Ok(__Field::__field12),
                            13u64 => _serde::__private::Ok(__Field::__field13),
                            14u64 => _serde::__private::Ok(__Field::__field14),
                            15u64 => _serde::__private::Ok(__Field::__field15),
                            16u64 => _serde::__private::Ok(__Field::__field16),
                            17u64 => _serde::__private::Ok(__Field::__field17),
                            18u64 => _serde::__private::Ok(__Field::__field18),
                            19u64 => _serde::__private::Ok(__Field::__field19),
                            20u64 => _serde::__private::Ok(__Field::__field20),
                            21u64 => _serde::__private::Ok(__Field::__field21),
                            22u64 => _serde::__private::Ok(__Field::__field22),
                            23u64 => _serde::__private::Ok(__Field::__field23),
                            24u64 => _serde::__private::Ok(__Field::__field24),
                            25u64 => _serde::__private::Ok(__Field::__field25),
                            26u64 => _serde::__private::Ok(__Field::__field26),
                            27u64 => _serde::__private::Ok(__Field::__field27),
                            28u64 => _serde::__private::Ok(__Field::__field28),
                            29u64 => _serde::__private::Ok(__Field::__field29),
                            30u64 => _serde::__private::Ok(__Field::__field30),
                            31u64 => _serde::__private::Ok(__Field::__field31),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "font_style" => _serde::__private::Ok(__Field::__field0),
                            "font_weight" => _serde::__private::Ok(__Field::__field1),
                            "font_size" => _serde::__private::Ok(__Field::__field2),
                            "color" => _serde::__private::Ok(__Field::__field3),
                            "background" => _serde::__private::Ok(__Field::__field4),
                            "background_color" => {
                                _serde::__private::Ok(__Field::__field5)
                            }
                            "text_decoration_line" => {
                                _serde::__private::Ok(__Field::__field6)
                            }
                            "text_decoration_style" => {
                                _serde::__private::Ok(__Field::__field7)
                            }
                            "text_decoration_color" => {
                                _serde::__private::Ok(__Field::__field8)
                            }
                            "border_color" => _serde::__private::Ok(__Field::__field9),
                            "border_style" => _serde::__private::Ok(__Field::__field10),
                            "border_radius" => _serde::__private::Ok(__Field::__field11),
                            "border_width" => _serde::__private::Ok(__Field::__field12),
                            "clip_path" => _serde::__private::Ok(__Field::__field13),
                            "vertical_align" => _serde::__private::Ok(__Field::__field14),
                            "text_align" => _serde::__private::Ok(__Field::__field15),
                            "text_emphasis" => _serde::__private::Ok(__Field::__field16),
                            "text_shadow" => _serde::__private::Ok(__Field::__field17),
                            "margin" => _serde::__private::Ok(__Field::__field18),
                            "margin_top" => _serde::__private::Ok(__Field::__field19),
                            "margin_left" => _serde::__private::Ok(__Field::__field20),
                            "margin_right" => _serde::__private::Ok(__Field::__field21),
                            "margin_bottom" => _serde::__private::Ok(__Field::__field22),
                            "padding" => _serde::__private::Ok(__Field::__field23),
                            "padding_top" => _serde::__private::Ok(__Field::__field24),
                            "padding_left" => _serde::__private::Ok(__Field::__field25),
                            "padding_right" => _serde::__private::Ok(__Field::__field26),
                            "padding_bottom" => _serde::__private::Ok(__Field::__field27),
                            "word_break" => _serde::__private::Ok(__Field::__field28),
                            "white_space" => _serde::__private::Ok(__Field::__field29),
                            "cursor" => _serde::__private::Ok(__Field::__field30),
                            "list_style_type" => {
                                _serde::__private::Ok(__Field::__field31)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"font_style" => _serde::__private::Ok(__Field::__field0),
                            b"font_weight" => _serde::__private::Ok(__Field::__field1),
                            b"font_size" => _serde::__private::Ok(__Field::__field2),
                            b"color" => _serde::__private::Ok(__Field::__field3),
                            b"background" => _serde::__private::Ok(__Field::__field4),
                            b"background_color" => {
                                _serde::__private::Ok(__Field::__field5)
                            }
                            b"text_decoration_line" => {
                                _serde::__private::Ok(__Field::__field6)
                            }
                            b"text_decoration_style" => {
                                _serde::__private::Ok(__Field::__field7)
                            }
                            b"text_decoration_color" => {
                                _serde::__private::Ok(__Field::__field8)
                            }
                            b"border_color" => _serde::__private::Ok(__Field::__field9),
                            b"border_style" => _serde::__private::Ok(__Field::__field10),
                            b"border_radius" => _serde::__private::Ok(__Field::__field11),
                            b"border_width" => _serde::__private::Ok(__Field::__field12),
                            b"clip_path" => _serde::__private::Ok(__Field::__field13),
                            b"vertical_align" => {
                                _serde::__private::Ok(__Field::__field14)
                            }
                            b"text_align" => _serde::__private::Ok(__Field::__field15),
                            b"text_emphasis" => _serde::__private::Ok(__Field::__field16),
                            b"text_shadow" => _serde::__private::Ok(__Field::__field17),
                            b"margin" => _serde::__private::Ok(__Field::__field18),
                            b"margin_top" => _serde::__private::Ok(__Field::__field19),
                            b"margin_left" => _serde::__private::Ok(__Field::__field20),
                            b"margin_right" => _serde::__private::Ok(__Field::__field21),
                            b"margin_bottom" => _serde::__private::Ok(__Field::__field22),
                            b"padding" => _serde::__private::Ok(__Field::__field23),
                            b"padding_top" => _serde::__private::Ok(__Field::__field24),
                            b"padding_left" => _serde::__private::Ok(__Field::__field25),
                            b"padding_right" => _serde::__private::Ok(__Field::__field26),
                            b"padding_bottom" => {
                                _serde::__private::Ok(__Field::__field27)
                            }
                            b"word_break" => _serde::__private::Ok(__Field::__field28),
                            b"white_space" => _serde::__private::Ok(__Field::__field29),
                            b"cursor" => _serde::__private::Ok(__Field::__field30),
                            b"list_style_type" => {
                                _serde::__private::Ok(__Field::__field31)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<StructuredContentStyle>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = StructuredContentStyle;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct StructuredContentStyle",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            Option<FontStyle>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct StructuredContentStyle with 32 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            Option<FontWeight>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct StructuredContentStyle with 32 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct StructuredContentStyle with 32 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct StructuredContentStyle with 32 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct StructuredContentStyle with 32 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct StructuredContentStyle with 32 elements",
                                    ),
                                );
                            }
                        };
                        let __field6 = match _serde::de::SeqAccess::next_element::<
                            Option<TextDecorationLineOrNone>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        6usize,
                                        &"struct StructuredContentStyle with 32 elements",
                                    ),
                                );
                            }
                        };
                        let __field7 = match _serde::de::SeqAccess::next_element::<
                            Option<TextDecorationStyle>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        7usize,
                                        &"struct StructuredContentStyle with 32 elements",
                                    ),
                                );
                            }
                        };
                        let __field8 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        8usize,
                                        &"struct StructuredContentStyle with 32 elements",
                                    ),
                                );
                            }
                        };
                        let __field9 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        9usize,
                                        &"struct StructuredContentStyle with 32 elements",
                                    ),
                                );
                            }
                        };
                        let __field10 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        10usize,
                                        &"struct StructuredContentStyle with 32 elements",
                                    ),
                                );
                            }
                        };
                        let __field11 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        11usize,
                                        &"struct StructuredContentStyle with 32 elements",
                                    ),
                                );
                            }
                        };
                        let __field12 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        12usize,
                                        &"struct StructuredContentStyle with 32 elements",
                                    ),
                                );
                            }
                        };
                        let __field13 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        13usize,
                                        &"struct StructuredContentStyle with 32 elements",
                                    ),
                                );
                            }
                        };
                        let __field14 = match _serde::de::SeqAccess::next_element::<
                            Option<VerticalAlign>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        14usize,
                                        &"struct StructuredContentStyle with 32 elements",
                                    ),
                                );
                            }
                        };
                        let __field15 = match _serde::de::SeqAccess::next_element::<
                            Option<TextAlign>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        15usize,
                                        &"struct StructuredContentStyle with 32 elements",
                                    ),
                                );
                            }
                        };
                        let __field16 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        16usize,
                                        &"struct StructuredContentStyle with 32 elements",
                                    ),
                                );
                            }
                        };
                        let __field17 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        17usize,
                                        &"struct StructuredContentStyle with 32 elements",
                                    ),
                                );
                            }
                        };
                        let __field18 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        18usize,
                                        &"struct StructuredContentStyle with 32 elements",
                                    ),
                                );
                            }
                        };
                        let __field19 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        19usize,
                                        &"struct StructuredContentStyle with 32 elements",
                                    ),
                                );
                            }
                        };
                        let __field20 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        20usize,
                                        &"struct StructuredContentStyle with 32 elements",
                                    ),
                                );
                            }
                        };
                        let __field21 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        21usize,
                                        &"struct StructuredContentStyle with 32 elements",
                                    ),
                                );
                            }
                        };
                        let __field22 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        22usize,
                                        &"struct StructuredContentStyle with 32 elements",
                                    ),
                                );
                            }
                        };
                        let __field23 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        23usize,
                                        &"struct StructuredContentStyle with 32 elements",
                                    ),
                                );
                            }
                        };
                        let __field24 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        24usize,
                                        &"struct StructuredContentStyle with 32 elements",
                                    ),
                                );
                            }
                        };
                        let __field25 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        25usize,
                                        &"struct StructuredContentStyle with 32 elements",
                                    ),
                                );
                            }
                        };
                        let __field26 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        26usize,
                                        &"struct StructuredContentStyle with 32 elements",
                                    ),
                                );
                            }
                        };
                        let __field27 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        27usize,
                                        &"struct StructuredContentStyle with 32 elements",
                                    ),
                                );
                            }
                        };
                        let __field28 = match _serde::de::SeqAccess::next_element::<
                            Option<WordBreak>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        28usize,
                                        &"struct StructuredContentStyle with 32 elements",
                                    ),
                                );
                            }
                        };
                        let __field29 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        29usize,
                                        &"struct StructuredContentStyle with 32 elements",
                                    ),
                                );
                            }
                        };
                        let __field30 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        30usize,
                                        &"struct StructuredContentStyle with 32 elements",
                                    ),
                                );
                            }
                        };
                        let __field31 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        31usize,
                                        &"struct StructuredContentStyle with 32 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(StructuredContentStyle {
                            font_style: __field0,
                            font_weight: __field1,
                            font_size: __field2,
                            color: __field3,
                            background: __field4,
                            background_color: __field5,
                            text_decoration_line: __field6,
                            text_decoration_style: __field7,
                            text_decoration_color: __field8,
                            border_color: __field9,
                            border_style: __field10,
                            border_radius: __field11,
                            border_width: __field12,
                            clip_path: __field13,
                            vertical_align: __field14,
                            text_align: __field15,
                            text_emphasis: __field16,
                            text_shadow: __field17,
                            margin: __field18,
                            margin_top: __field19,
                            margin_left: __field20,
                            margin_right: __field21,
                            margin_bottom: __field22,
                            padding: __field23,
                            padding_top: __field24,
                            padding_left: __field25,
                            padding_right: __field26,
                            padding_bottom: __field27,
                            word_break: __field28,
                            white_space: __field29,
                            cursor: __field30,
                            list_style_type: __field31,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<Option<FontStyle>> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            Option<FontWeight>,
                        > = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field6: _serde::__private::Option<
                            Option<TextDecorationLineOrNone>,
                        > = _serde::__private::None;
                        let mut __field7: _serde::__private::Option<
                            Option<TextDecorationStyle>,
                        > = _serde::__private::None;
                        let mut __field8: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field9: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field10: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field11: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field12: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field13: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field14: _serde::__private::Option<
                            Option<VerticalAlign>,
                        > = _serde::__private::None;
                        let mut __field15: _serde::__private::Option<
                            Option<TextAlign>,
                        > = _serde::__private::None;
                        let mut __field16: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field17: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field18: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field19: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field20: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field21: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field22: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field23: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field24: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field25: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field26: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field27: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field28: _serde::__private::Option<
                            Option<WordBreak>,
                        > = _serde::__private::None;
                        let mut __field29: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field30: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field31: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "font_style",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<FontStyle>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "font_weight",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<FontWeight>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "font_size",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("color"),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "background",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "background_color",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "text_decoration_line",
                                            ),
                                        );
                                    }
                                    __field6 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<TextDecorationLineOrNone>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field7 => {
                                    if _serde::__private::Option::is_some(&__field7) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "text_decoration_style",
                                            ),
                                        );
                                    }
                                    __field7 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<TextDecorationStyle>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field8 => {
                                    if _serde::__private::Option::is_some(&__field8) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "text_decoration_color",
                                            ),
                                        );
                                    }
                                    __field8 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field9 => {
                                    if _serde::__private::Option::is_some(&__field9) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "border_color",
                                            ),
                                        );
                                    }
                                    __field9 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field10 => {
                                    if _serde::__private::Option::is_some(&__field10) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "border_style",
                                            ),
                                        );
                                    }
                                    __field10 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field11 => {
                                    if _serde::__private::Option::is_some(&__field11) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "border_radius",
                                            ),
                                        );
                                    }
                                    __field11 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field12 => {
                                    if _serde::__private::Option::is_some(&__field12) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "border_width",
                                            ),
                                        );
                                    }
                                    __field12 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field13 => {
                                    if _serde::__private::Option::is_some(&__field13) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "clip_path",
                                            ),
                                        );
                                    }
                                    __field13 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field14 => {
                                    if _serde::__private::Option::is_some(&__field14) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "vertical_align",
                                            ),
                                        );
                                    }
                                    __field14 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<VerticalAlign>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field15 => {
                                    if _serde::__private::Option::is_some(&__field15) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "text_align",
                                            ),
                                        );
                                    }
                                    __field15 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<TextAlign>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field16 => {
                                    if _serde::__private::Option::is_some(&__field16) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "text_emphasis",
                                            ),
                                        );
                                    }
                                    __field16 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field17 => {
                                    if _serde::__private::Option::is_some(&__field17) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "text_shadow",
                                            ),
                                        );
                                    }
                                    __field17 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field18 => {
                                    if _serde::__private::Option::is_some(&__field18) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("margin"),
                                        );
                                    }
                                    __field18 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field19 => {
                                    if _serde::__private::Option::is_some(&__field19) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "margin_top",
                                            ),
                                        );
                                    }
                                    __field19 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field20 => {
                                    if _serde::__private::Option::is_some(&__field20) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "margin_left",
                                            ),
                                        );
                                    }
                                    __field20 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field21 => {
                                    if _serde::__private::Option::is_some(&__field21) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "margin_right",
                                            ),
                                        );
                                    }
                                    __field21 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field22 => {
                                    if _serde::__private::Option::is_some(&__field22) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "margin_bottom",
                                            ),
                                        );
                                    }
                                    __field22 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field23 => {
                                    if _serde::__private::Option::is_some(&__field23) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "padding",
                                            ),
                                        );
                                    }
                                    __field23 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field24 => {
                                    if _serde::__private::Option::is_some(&__field24) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "padding_top",
                                            ),
                                        );
                                    }
                                    __field24 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field25 => {
                                    if _serde::__private::Option::is_some(&__field25) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "padding_left",
                                            ),
                                        );
                                    }
                                    __field25 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field26 => {
                                    if _serde::__private::Option::is_some(&__field26) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "padding_right",
                                            ),
                                        );
                                    }
                                    __field26 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field27 => {
                                    if _serde::__private::Option::is_some(&__field27) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "padding_bottom",
                                            ),
                                        );
                                    }
                                    __field27 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field28 => {
                                    if _serde::__private::Option::is_some(&__field28) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "word_break",
                                            ),
                                        );
                                    }
                                    __field28 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<WordBreak>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field29 => {
                                    if _serde::__private::Option::is_some(&__field29) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "white_space",
                                            ),
                                        );
                                    }
                                    __field29 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field30 => {
                                    if _serde::__private::Option::is_some(&__field30) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("cursor"),
                                        );
                                    }
                                    __field30 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field31 => {
                                    if _serde::__private::Option::is_some(&__field31) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "list_style_type",
                                            ),
                                        );
                                    }
                                    __field31 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("font_style")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("font_weight")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("font_size")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("color")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("background")?
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("background_color")?
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "text_decoration_line",
                                )?
                            }
                        };
                        let __field7 = match __field7 {
                            _serde::__private::Some(__field7) => __field7,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "text_decoration_style",
                                )?
                            }
                        };
                        let __field8 = match __field8 {
                            _serde::__private::Some(__field8) => __field8,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "text_decoration_color",
                                )?
                            }
                        };
                        let __field9 = match __field9 {
                            _serde::__private::Some(__field9) => __field9,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("border_color")?
                            }
                        };
                        let __field10 = match __field10 {
                            _serde::__private::Some(__field10) => __field10,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("border_style")?
                            }
                        };
                        let __field11 = match __field11 {
                            _serde::__private::Some(__field11) => __field11,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("border_radius")?
                            }
                        };
                        let __field12 = match __field12 {
                            _serde::__private::Some(__field12) => __field12,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("border_width")?
                            }
                        };
                        let __field13 = match __field13 {
                            _serde::__private::Some(__field13) => __field13,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("clip_path")?
                            }
                        };
                        let __field14 = match __field14 {
                            _serde::__private::Some(__field14) => __field14,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("vertical_align")?
                            }
                        };
                        let __field15 = match __field15 {
                            _serde::__private::Some(__field15) => __field15,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("text_align")?
                            }
                        };
                        let __field16 = match __field16 {
                            _serde::__private::Some(__field16) => __field16,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("text_emphasis")?
                            }
                        };
                        let __field17 = match __field17 {
                            _serde::__private::Some(__field17) => __field17,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("text_shadow")?
                            }
                        };
                        let __field18 = match __field18 {
                            _serde::__private::Some(__field18) => __field18,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("margin")?
                            }
                        };
                        let __field19 = match __field19 {
                            _serde::__private::Some(__field19) => __field19,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("margin_top")?
                            }
                        };
                        let __field20 = match __field20 {
                            _serde::__private::Some(__field20) => __field20,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("margin_left")?
                            }
                        };
                        let __field21 = match __field21 {
                            _serde::__private::Some(__field21) => __field21,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("margin_right")?
                            }
                        };
                        let __field22 = match __field22 {
                            _serde::__private::Some(__field22) => __field22,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("margin_bottom")?
                            }
                        };
                        let __field23 = match __field23 {
                            _serde::__private::Some(__field23) => __field23,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("padding")?
                            }
                        };
                        let __field24 = match __field24 {
                            _serde::__private::Some(__field24) => __field24,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("padding_top")?
                            }
                        };
                        let __field25 = match __field25 {
                            _serde::__private::Some(__field25) => __field25,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("padding_left")?
                            }
                        };
                        let __field26 = match __field26 {
                            _serde::__private::Some(__field26) => __field26,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("padding_right")?
                            }
                        };
                        let __field27 = match __field27 {
                            _serde::__private::Some(__field27) => __field27,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("padding_bottom")?
                            }
                        };
                        let __field28 = match __field28 {
                            _serde::__private::Some(__field28) => __field28,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("word_break")?
                            }
                        };
                        let __field29 = match __field29 {
                            _serde::__private::Some(__field29) => __field29,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("white_space")?
                            }
                        };
                        let __field30 = match __field30 {
                            _serde::__private::Some(__field30) => __field30,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("cursor")?
                            }
                        };
                        let __field31 = match __field31 {
                            _serde::__private::Some(__field31) => __field31,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("list_style_type")?
                            }
                        };
                        _serde::__private::Ok(StructuredContentStyle {
                            font_style: __field0,
                            font_weight: __field1,
                            font_size: __field2,
                            color: __field3,
                            background: __field4,
                            background_color: __field5,
                            text_decoration_line: __field6,
                            text_decoration_style: __field7,
                            text_decoration_color: __field8,
                            border_color: __field9,
                            border_style: __field10,
                            border_radius: __field11,
                            border_width: __field12,
                            clip_path: __field13,
                            vertical_align: __field14,
                            text_align: __field15,
                            text_emphasis: __field16,
                            text_shadow: __field17,
                            margin: __field18,
                            margin_top: __field19,
                            margin_left: __field20,
                            margin_right: __field21,
                            margin_bottom: __field22,
                            padding: __field23,
                            padding_top: __field24,
                            padding_left: __field25,
                            padding_right: __field26,
                            padding_bottom: __field27,
                            word_break: __field28,
                            white_space: __field29,
                            cursor: __field30,
                            list_style_type: __field31,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "font_style",
                    "font_weight",
                    "font_size",
                    "color",
                    "background",
                    "background_color",
                    "text_decoration_line",
                    "text_decoration_style",
                    "text_decoration_color",
                    "border_color",
                    "border_style",
                    "border_radius",
                    "border_width",
                    "clip_path",
                    "vertical_align",
                    "text_align",
                    "text_emphasis",
                    "text_shadow",
                    "margin",
                    "margin_top",
                    "margin_left",
                    "margin_right",
                    "margin_bottom",
                    "padding",
                    "padding_top",
                    "padding_left",
                    "padding_right",
                    "padding_bottom",
                    "word_break",
                    "white_space",
                    "cursor",
                    "list_style_type",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "StructuredContentStyle",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<StructuredContentStyle>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    impl<'de> Deserialize<'de> for Element {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: Deserializer<'de>,
        {
            serde_untagged::UntaggedEnumVisitor::new()
                .string(|unkown_string| Ok(
                    Element::UnknownString(unkown_string.to_string()),
                ))
                .map(|map| {
                    let value = map.deserialize::<serde_json::Value>()?;
                    let tag = match value.get("tag") {
                        Some(tag) => {
                            tag.as_str()
                                .ok_or_else(|| serde::de::Error::custom(
                                    "tag is not a string",
                                ))
                        }
                        None => Err(serde::de::Error::custom("missing tag")),
                    }?;
                    let element = match tag {
                        "a" => serde_json::from_value(value).map(Element::Link),
                        "div" => serde_json::from_value(value).map(Element::Styled),
                        "span" => serde_json::from_value(value).map(Element::Styled),
                        "br" => serde_json::from_value(value).map(Element::LineBreak),
                        "img" => serde_json::from_value(value).map(Element::Image),
                        "ruby" => serde_json::from_value(value).map(Element::Unstyled),
                        "rt" => serde_json::from_value(value).map(Element::Unstyled),
                        "rp" => serde_json::from_value(value).map(Element::Unstyled),
                        "t" => serde_json::from_value(value).map(Element::Unstyled),
                        "th" => serde_json::from_value(value).map(Element::Unstyled),
                        "tb" => serde_json::from_value(value).map(Element::Unstyled),
                        "tf" => serde_json::from_value(value).map(Element::Unstyled),
                        "ol" => serde_json::from_value(value).map(Element::Styled),
                        "ul" => serde_json::from_value(value).map(Element::Styled),
                        "li" => serde_json::from_value(value).map(Element::Styled),
                        "details" => serde_json::from_value(value).map(Element::Styled),
                        "summary" => serde_json::from_value(value).map(Element::Styled),
                        "table" => serde_json::from_value(value).map(Element::Unstyled),
                        "thead" => serde_json::from_value(value).map(Element::Unstyled),
                        "tbody" => serde_json::from_value(value).map(Element::Unstyled),
                        "tfoot" => serde_json::from_value(value).map(Element::Unstyled),
                        "tr" => serde_json::from_value(value).map(Element::Unstyled),
                        "td" => serde_json::from_value(value).map(Element::Table),
                        "th" => serde_json::from_value(value).map(Element::Table),
                        _ => {
                            if let serde_json::Value::String(s) = value {
                                Ok(Element::UnknownString(s.to_string()))
                            } else {
                                Err(
                                    serde::de::Error::custom(
                                        ::alloc::__export::must_use({
                                            let res = ::alloc::fmt::format(
                                                format_args!("unexpected value: {0};", tag),
                                            );
                                            res
                                        }),
                                    ),
                                )
                            }
                        }
                    };
                    element
                        .map_err(|err| {
                            serde::de::Error::custom(
                                ::alloc::__export::must_use({
                                    let res = ::alloc::fmt::format(
                                        format_args!("failed to deserialize element: {0}", err),
                                    );
                                    res
                                }),
                            )
                        })
                })
                .deserialize(deserializer)
        }
    }
    /// Represents All `Content` elements that can
    /// appear within a `"content":` section.
    #[serde(untagged)]
    pub enum Element {
        UnknownString(String),
        Link(LinkElement),
        Styled(StyledElement),
        Unstyled(UnstyledElement),
        Table(TableElement),
        LineBreak(LineBreak),
        Image(ImageElement),
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Element {
        #[inline]
        fn clone(&self) -> Element {
            match self {
                Element::UnknownString(__self_0) => {
                    Element::UnknownString(::core::clone::Clone::clone(__self_0))
                }
                Element::Link(__self_0) => {
                    Element::Link(::core::clone::Clone::clone(__self_0))
                }
                Element::Styled(__self_0) => {
                    Element::Styled(::core::clone::Clone::clone(__self_0))
                }
                Element::Unstyled(__self_0) => {
                    Element::Unstyled(::core::clone::Clone::clone(__self_0))
                }
                Element::Table(__self_0) => {
                    Element::Table(::core::clone::Clone::clone(__self_0))
                }
                Element::LineBreak(__self_0) => {
                    Element::LineBreak(::core::clone::Clone::clone(__self_0))
                }
                Element::Image(__self_0) => {
                    Element::Image(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Element {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                Element::UnknownString(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "UnknownString",
                        &__self_0,
                    )
                }
                Element::Link(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Link",
                        &__self_0,
                    )
                }
                Element::Styled(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Styled",
                        &__self_0,
                    )
                }
                Element::Unstyled(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Unstyled",
                        &__self_0,
                    )
                }
                Element::Table(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Table",
                        &__self_0,
                    )
                }
                Element::LineBreak(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "LineBreak",
                        &__self_0,
                    )
                }
                Element::Image(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Image",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Element {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Element {
        #[inline]
        fn eq(&self, other: &Element) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
                && match (self, other) {
                    (
                        Element::UnknownString(__self_0),
                        Element::UnknownString(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (Element::Link(__self_0), Element::Link(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Element::Styled(__self_0), Element::Styled(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Element::Unstyled(__self_0), Element::Unstyled(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Element::Table(__self_0), Element::Table(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Element::LineBreak(__self_0), Element::LineBreak(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (Element::Image(__self_0), Element::Image(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Element {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    Element::UnknownString(ref __field0) => {
                        _serde::Serialize::serialize(__field0, __serializer)
                    }
                    Element::Link(ref __field0) => {
                        _serde::Serialize::serialize(__field0, __serializer)
                    }
                    Element::Styled(ref __field0) => {
                        _serde::Serialize::serialize(__field0, __serializer)
                    }
                    Element::Unstyled(ref __field0) => {
                        _serde::Serialize::serialize(__field0, __serializer)
                    }
                    Element::Table(ref __field0) => {
                        _serde::Serialize::serialize(__field0, __serializer)
                    }
                    Element::LineBreak(ref __field0) => {
                        _serde::Serialize::serialize(__field0, __serializer)
                    }
                    Element::Image(ref __field0) => {
                        _serde::Serialize::serialize(__field0, __serializer)
                    }
                }
            }
        }
    };
    /// This element doesn't support children or support language.
    pub struct LineBreak {
        /// The `LineBreak`' tag is:
        /// [`HtmlTag::Break`] | `"br"`.
        tag: HtmlTag,
        data: Option<IndexMap<String, String>>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for LineBreak {
        #[inline]
        fn clone(&self) -> LineBreak {
            LineBreak {
                tag: ::core::clone::Clone::clone(&self.tag),
                data: ::core::clone::Clone::clone(&self.data),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for LineBreak {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "LineBreak",
                "tag",
                &self.tag,
                "data",
                &&self.data,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for LineBreak {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for LineBreak {
        #[inline]
        fn eq(&self, other: &LineBreak) -> bool {
            self.tag == other.tag && self.data == other.data
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for LineBreak {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "LineBreak",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "tag",
                    &self.tag,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "data",
                    &self.data,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for LineBreak {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "tag" => _serde::__private::Ok(__Field::__field0),
                            "data" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"tag" => _serde::__private::Ok(__Field::__field0),
                            b"data" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<LineBreak>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = LineBreak;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct LineBreak",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            HtmlTag,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct LineBreak with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            Option<IndexMap<String, String>>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct LineBreak with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(LineBreak {
                            tag: __field0,
                            data: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<HtmlTag> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            Option<IndexMap<String, String>>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("tag"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<HtmlTag>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("data"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<IndexMap<String, String>>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("tag")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("data")?
                            }
                        };
                        _serde::__private::Ok(LineBreak {
                            tag: __field0,
                            data: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["tag", "data"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "LineBreak",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<LineBreak>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    pub struct UnstyledElement {
        /// `UnstyledElements`'s' tags could be the following:
        ///
        /// [`HtmlTag::Ruby`],
        /// [`HtmlTag::RubyText`],
        /// [`HtmlTag::RubyParenthesis`],
        /// [`HtmlTag::Table`],
        /// [`HtmlTag::TableHeader`],
        /// [`HtmlTag::TableBody`],
        /// [`HtmlTag::TableFooter`],
        /// [`HtmlTag::TableRow`].
        pub tag: HtmlTag,
        pub content: Option<ContentMatchType>,
        pub data: Option<IndexMap<String, String>>,
        /// Defines the language of an element in the format defined by RFC 5646.
        lang: Option<String>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for UnstyledElement {
        #[inline]
        fn clone(&self) -> UnstyledElement {
            UnstyledElement {
                tag: ::core::clone::Clone::clone(&self.tag),
                content: ::core::clone::Clone::clone(&self.content),
                data: ::core::clone::Clone::clone(&self.data),
                lang: ::core::clone::Clone::clone(&self.lang),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for UnstyledElement {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "UnstyledElement",
                "tag",
                &self.tag,
                "content",
                &self.content,
                "data",
                &self.data,
                "lang",
                &&self.lang,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for UnstyledElement {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for UnstyledElement {
        #[inline]
        fn eq(&self, other: &UnstyledElement) -> bool {
            self.tag == other.tag && self.content == other.content
                && self.data == other.data && self.lang == other.lang
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for UnstyledElement {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "UnstyledElement",
                    false as usize + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "tag",
                    &self.tag,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "content",
                    &self.content,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "data",
                    &self.data,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "lang",
                    &self.lang,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for UnstyledElement {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "tag" => _serde::__private::Ok(__Field::__field0),
                            "content" => _serde::__private::Ok(__Field::__field1),
                            "data" => _serde::__private::Ok(__Field::__field2),
                            "lang" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"tag" => _serde::__private::Ok(__Field::__field0),
                            b"content" => _serde::__private::Ok(__Field::__field1),
                            b"data" => _serde::__private::Ok(__Field::__field2),
                            b"lang" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<UnstyledElement>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = UnstyledElement;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct UnstyledElement",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            HtmlTag,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct UnstyledElement with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            Option<ContentMatchType>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct UnstyledElement with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            Option<IndexMap<String, String>>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct UnstyledElement with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct UnstyledElement with 4 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(UnstyledElement {
                            tag: __field0,
                            content: __field1,
                            data: __field2,
                            lang: __field3,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<HtmlTag> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            Option<ContentMatchType>,
                        > = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<
                            Option<IndexMap<String, String>>,
                        > = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("tag"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<HtmlTag>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "content",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<ContentMatchType>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("data"),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<IndexMap<String, String>>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("lang"),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("tag")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("content")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("data")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("lang")?
                            }
                        };
                        _serde::__private::Ok(UnstyledElement {
                            tag: __field0,
                            content: __field1,
                            data: __field2,
                            lang: __field3,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "tag",
                    "content",
                    "data",
                    "lang",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "UnstyledElement",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<UnstyledElement>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    pub struct TableElement {
        /// `TableElement`'s tags could be the following:
        ///
        /// [`HtmlTag::TableData`],
        /// [`HtmlTag::TableHeader`].
        pub tag: HtmlTag,
        pub content: Option<ContentMatchType>,
        pub data: Option<IndexMap<String, String>>,
        pub col_span: Option<u16>,
        pub row_span: Option<u16>,
        pub style: Option<StructuredContentStyle>,
        /// Defines the language of an element in the format defined by RFC 5646.
        lang: Option<String>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TableElement {
        #[inline]
        fn clone(&self) -> TableElement {
            TableElement {
                tag: ::core::clone::Clone::clone(&self.tag),
                content: ::core::clone::Clone::clone(&self.content),
                data: ::core::clone::Clone::clone(&self.data),
                col_span: ::core::clone::Clone::clone(&self.col_span),
                row_span: ::core::clone::Clone::clone(&self.row_span),
                style: ::core::clone::Clone::clone(&self.style),
                lang: ::core::clone::Clone::clone(&self.lang),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TableElement {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "tag",
                "content",
                "data",
                "col_span",
                "row_span",
                "style",
                "lang",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.tag,
                &self.content,
                &self.data,
                &self.col_span,
                &self.row_span,
                &self.style,
                &&self.lang,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "TableElement",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TableElement {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TableElement {
        #[inline]
        fn eq(&self, other: &TableElement) -> bool {
            self.tag == other.tag && self.content == other.content
                && self.data == other.data && self.col_span == other.col_span
                && self.row_span == other.row_span && self.style == other.style
                && self.lang == other.lang
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TableElement {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "TableElement",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "tag",
                    &self.tag,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "content",
                    &self.content,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "data",
                    &self.data,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "col_span",
                    &self.col_span,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "row_span",
                    &self.row_span,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "style",
                    &self.style,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "lang",
                    &self.lang,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TableElement {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "tag" => _serde::__private::Ok(__Field::__field0),
                            "content" => _serde::__private::Ok(__Field::__field1),
                            "data" => _serde::__private::Ok(__Field::__field2),
                            "col_span" => _serde::__private::Ok(__Field::__field3),
                            "row_span" => _serde::__private::Ok(__Field::__field4),
                            "style" => _serde::__private::Ok(__Field::__field5),
                            "lang" => _serde::__private::Ok(__Field::__field6),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"tag" => _serde::__private::Ok(__Field::__field0),
                            b"content" => _serde::__private::Ok(__Field::__field1),
                            b"data" => _serde::__private::Ok(__Field::__field2),
                            b"col_span" => _serde::__private::Ok(__Field::__field3),
                            b"row_span" => _serde::__private::Ok(__Field::__field4),
                            b"style" => _serde::__private::Ok(__Field::__field5),
                            b"lang" => _serde::__private::Ok(__Field::__field6),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<TableElement>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TableElement;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct TableElement",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            HtmlTag,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct TableElement with 7 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            Option<ContentMatchType>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct TableElement with 7 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            Option<IndexMap<String, String>>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct TableElement with 7 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            Option<u16>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct TableElement with 7 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            Option<u16>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct TableElement with 7 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            Option<StructuredContentStyle>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct TableElement with 7 elements",
                                    ),
                                );
                            }
                        };
                        let __field6 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        6usize,
                                        &"struct TableElement with 7 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(TableElement {
                            tag: __field0,
                            content: __field1,
                            data: __field2,
                            col_span: __field3,
                            row_span: __field4,
                            style: __field5,
                            lang: __field6,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<HtmlTag> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            Option<ContentMatchType>,
                        > = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<
                            Option<IndexMap<String, String>>,
                        > = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<Option<u16>> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<Option<u16>> = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<
                            Option<StructuredContentStyle>,
                        > = _serde::__private::None;
                        let mut __field6: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("tag"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<HtmlTag>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "content",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<ContentMatchType>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("data"),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<IndexMap<String, String>>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "col_span",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<u16>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "row_span",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<u16>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("style"),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<StructuredContentStyle>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("lang"),
                                        );
                                    }
                                    __field6 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("tag")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("content")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("data")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("col_span")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("row_span")?
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("style")?
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("lang")?
                            }
                        };
                        _serde::__private::Ok(TableElement {
                            tag: __field0,
                            content: __field1,
                            data: __field2,
                            col_span: __field3,
                            row_span: __field4,
                            style: __field5,
                            lang: __field6,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "tag",
                    "content",
                    "data",
                    "col_span",
                    "row_span",
                    "style",
                    "lang",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "TableElement",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<TableElement>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    pub struct StyledElement {
        /// `StyledElement`'s tags are:
        ///
        /// [`HtmlTag::Span`],
        /// [`HtmlTag::Div`],
        /// [`HtmlTag::OrderedList`],
        /// [`HtmlTag::UnorderedList`],
        /// [`HtmlTag::ListItem`],
        /// [`HtmlTag::Details`],
        /// [`HtmlTag::Summary`].
        pub tag: HtmlTag,
        pub content: Option<ContentMatchType>,
        pub data: Option<IndexMap<String, String>>,
        pub style: Option<StructuredContentStyle>,
        /// Hover text for the element.
        pub title: Option<String>,
        /// Defines the language of an element in the format defined by RFC 5646.
        lang: Option<String>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for StyledElement {
        #[inline]
        fn clone(&self) -> StyledElement {
            StyledElement {
                tag: ::core::clone::Clone::clone(&self.tag),
                content: ::core::clone::Clone::clone(&self.content),
                data: ::core::clone::Clone::clone(&self.data),
                style: ::core::clone::Clone::clone(&self.style),
                title: ::core::clone::Clone::clone(&self.title),
                lang: ::core::clone::Clone::clone(&self.lang),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for StyledElement {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "tag",
                "content",
                "data",
                "style",
                "title",
                "lang",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.tag,
                &self.content,
                &self.data,
                &self.style,
                &self.title,
                &&self.lang,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "StyledElement",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for StyledElement {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for StyledElement {
        #[inline]
        fn eq(&self, other: &StyledElement) -> bool {
            self.tag == other.tag && self.content == other.content
                && self.data == other.data && self.style == other.style
                && self.title == other.title && self.lang == other.lang
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for StyledElement {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "StyledElement",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "tag",
                    &self.tag,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "content",
                    &self.content,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "data",
                    &self.data,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "style",
                    &self.style,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "title",
                    &self.title,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "lang",
                    &self.lang,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for StyledElement {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "tag" => _serde::__private::Ok(__Field::__field0),
                            "content" => _serde::__private::Ok(__Field::__field1),
                            "data" => _serde::__private::Ok(__Field::__field2),
                            "style" => _serde::__private::Ok(__Field::__field3),
                            "title" => _serde::__private::Ok(__Field::__field4),
                            "lang" => _serde::__private::Ok(__Field::__field5),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"tag" => _serde::__private::Ok(__Field::__field0),
                            b"content" => _serde::__private::Ok(__Field::__field1),
                            b"data" => _serde::__private::Ok(__Field::__field2),
                            b"style" => _serde::__private::Ok(__Field::__field3),
                            b"title" => _serde::__private::Ok(__Field::__field4),
                            b"lang" => _serde::__private::Ok(__Field::__field5),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<StyledElement>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = StyledElement;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct StyledElement",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            HtmlTag,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct StyledElement with 6 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            Option<ContentMatchType>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct StyledElement with 6 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            Option<IndexMap<String, String>>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct StyledElement with 6 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            Option<StructuredContentStyle>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct StyledElement with 6 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct StyledElement with 6 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct StyledElement with 6 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(StyledElement {
                            tag: __field0,
                            content: __field1,
                            data: __field2,
                            style: __field3,
                            title: __field4,
                            lang: __field5,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<HtmlTag> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            Option<ContentMatchType>,
                        > = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<
                            Option<IndexMap<String, String>>,
                        > = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<
                            Option<StructuredContentStyle>,
                        > = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("tag"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<HtmlTag>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "content",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<ContentMatchType>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("data"),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<IndexMap<String, String>>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("style"),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<StructuredContentStyle>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("title"),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("lang"),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("tag")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("content")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("data")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("style")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("title")?
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("lang")?
                            }
                        };
                        _serde::__private::Ok(StyledElement {
                            tag: __field0,
                            content: __field1,
                            data: __field2,
                            style: __field3,
                            title: __field4,
                            lang: __field5,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "tag",
                    "content",
                    "data",
                    "style",
                    "title",
                    "lang",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "StyledElement",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<StyledElement>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    pub struct LinkElement {
        /// The `LinkElement`'s tag is:
        ///
        /// [`HtmlTag::Anchor`] | `"a"`.
        pub tag: HtmlTag,
        pub content: Option<ContentMatchType>,
        /// The URL for the link.
        ///
        /// URLs starting with a `?` are treated as internal links to other dictionary content.
        pub href: String,
        /// Defines the language of an element in the format defined by RFC 5646.
        ///
        ///yomichan_rs will currently only support `ja` & `ja-JP`.
        pub lang: Option<String>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for LinkElement {
        #[inline]
        fn clone(&self) -> LinkElement {
            LinkElement {
                tag: ::core::clone::Clone::clone(&self.tag),
                content: ::core::clone::Clone::clone(&self.content),
                href: ::core::clone::Clone::clone(&self.href),
                lang: ::core::clone::Clone::clone(&self.lang),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for LinkElement {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "LinkElement",
                "tag",
                &self.tag,
                "content",
                &self.content,
                "href",
                &self.href,
                "lang",
                &&self.lang,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for LinkElement {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for LinkElement {
        #[inline]
        fn eq(&self, other: &LinkElement) -> bool {
            self.tag == other.tag && self.content == other.content
                && self.href == other.href && self.lang == other.lang
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for LinkElement {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "LinkElement",
                    false as usize + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "tag",
                    &self.tag,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "content",
                    &self.content,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "href",
                    &self.href,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "lang",
                    &self.lang,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for LinkElement {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "tag" => _serde::__private::Ok(__Field::__field0),
                            "content" => _serde::__private::Ok(__Field::__field1),
                            "href" => _serde::__private::Ok(__Field::__field2),
                            "lang" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"tag" => _serde::__private::Ok(__Field::__field0),
                            b"content" => _serde::__private::Ok(__Field::__field1),
                            b"href" => _serde::__private::Ok(__Field::__field2),
                            b"lang" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<LinkElement>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = LinkElement;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct LinkElement",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            HtmlTag,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct LinkElement with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            Option<ContentMatchType>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct LinkElement with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct LinkElement with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct LinkElement with 4 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(LinkElement {
                            tag: __field0,
                            content: __field1,
                            href: __field2,
                            lang: __field3,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<HtmlTag> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            Option<ContentMatchType>,
                        > = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("tag"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<HtmlTag>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "content",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<ContentMatchType>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("href"),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("lang"),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("tag")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("content")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("href")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("lang")?
                            }
                        };
                        _serde::__private::Ok(LinkElement {
                            tag: __field0,
                            content: __field1,
                            href: __field2,
                            lang: __field3,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "tag",
                    "content",
                    "href",
                    "lang",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "LinkElement",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<LinkElement>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    pub struct ImageElement {
        /// This element doesn't support children.
        pub content: Option<()>,
        /// The vertical alignment of the image.
        pub vertical_align: Option<VerticalAlign>,
        /// Shorthand for border width, style, and color.
        pub border: Option<String>,
        /// Roundness of the corners of the image's outer border edge.
        pub border_radius: Option<String>,
        /// The units for the width and height.
        pub size_units: Option<SizeUnits>,
        pub data: Option<IndexMap<String, String>>,
        /// Path to the image file in the archive.
        pub path: String,
        /// Preferred width of the image.
        pub width: Option<f32>,
        /// Preferred height of the image.
        pub height: Option<f32>,
        /// Preferred width of the image.
        /// This is only used in the internal database.
        pub preferred_width: Option<f32>,
        /// Preferred height of the image.
        /// This is only used in the internal database.
        pub preferred_height: Option<f32>,
        /// Hover text for the image.
        pub title: Option<String>,
        /// Alt text for the image.
        pub alt: Option<String>,
        /// Description of the image.
        pub description: Option<String>,
        /// Whether or not the image should appear pixelated at sizes larger than the image's native resolution.
        pub pixelated: Option<bool>,
        /// Controls how the image is rendered. The value of this field supersedes the pixelated field.
        pub image_rendering: Option<ImageRendering>,
        /// Controls the appearance of the image. The 'monochrome' value will mask the opaque parts of the image using the current text color.
        appearance: Option<ImageAppearance>,
        /// Whether or not a background color is displayed behind the image.
        background: Option<bool>,
        /// Whether or not the image is collapsed by default.
        collapsed: Option<bool>,
        /// Whether or not the image can be collapsed.
        collapsible: Option<bool>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ImageElement {
        #[inline]
        fn clone(&self) -> ImageElement {
            ImageElement {
                content: ::core::clone::Clone::clone(&self.content),
                vertical_align: ::core::clone::Clone::clone(&self.vertical_align),
                border: ::core::clone::Clone::clone(&self.border),
                border_radius: ::core::clone::Clone::clone(&self.border_radius),
                size_units: ::core::clone::Clone::clone(&self.size_units),
                data: ::core::clone::Clone::clone(&self.data),
                path: ::core::clone::Clone::clone(&self.path),
                width: ::core::clone::Clone::clone(&self.width),
                height: ::core::clone::Clone::clone(&self.height),
                preferred_width: ::core::clone::Clone::clone(&self.preferred_width),
                preferred_height: ::core::clone::Clone::clone(&self.preferred_height),
                title: ::core::clone::Clone::clone(&self.title),
                alt: ::core::clone::Clone::clone(&self.alt),
                description: ::core::clone::Clone::clone(&self.description),
                pixelated: ::core::clone::Clone::clone(&self.pixelated),
                image_rendering: ::core::clone::Clone::clone(&self.image_rendering),
                appearance: ::core::clone::Clone::clone(&self.appearance),
                background: ::core::clone::Clone::clone(&self.background),
                collapsed: ::core::clone::Clone::clone(&self.collapsed),
                collapsible: ::core::clone::Clone::clone(&self.collapsible),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ImageElement {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "content",
                "vertical_align",
                "border",
                "border_radius",
                "size_units",
                "data",
                "path",
                "width",
                "height",
                "preferred_width",
                "preferred_height",
                "title",
                "alt",
                "description",
                "pixelated",
                "image_rendering",
                "appearance",
                "background",
                "collapsed",
                "collapsible",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.content,
                &self.vertical_align,
                &self.border,
                &self.border_radius,
                &self.size_units,
                &self.data,
                &self.path,
                &self.width,
                &self.height,
                &self.preferred_width,
                &self.preferred_height,
                &self.title,
                &self.alt,
                &self.description,
                &self.pixelated,
                &self.image_rendering,
                &self.appearance,
                &self.background,
                &self.collapsed,
                &&self.collapsible,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "ImageElement",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ImageElement {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ImageElement {
        #[inline]
        fn eq(&self, other: &ImageElement) -> bool {
            self.content == other.content && self.vertical_align == other.vertical_align
                && self.border == other.border
                && self.border_radius == other.border_radius
                && self.size_units == other.size_units && self.data == other.data
                && self.path == other.path && self.width == other.width
                && self.height == other.height
                && self.preferred_width == other.preferred_width
                && self.preferred_height == other.preferred_height
                && self.title == other.title && self.alt == other.alt
                && self.description == other.description
                && self.pixelated == other.pixelated
                && self.image_rendering == other.image_rendering
                && self.appearance == other.appearance
                && self.background == other.background
                && self.collapsed == other.collapsed
                && self.collapsible == other.collapsible
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ImageElement {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "ImageElement",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1
                        + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "content",
                    &self.content,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "vertical_align",
                    &self.vertical_align,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "border",
                    &self.border,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "border_radius",
                    &self.border_radius,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "size_units",
                    &self.size_units,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "data",
                    &self.data,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "path",
                    &self.path,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "width",
                    &self.width,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "height",
                    &self.height,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "preferred_width",
                    &self.preferred_width,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "preferred_height",
                    &self.preferred_height,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "title",
                    &self.title,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "alt",
                    &self.alt,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "description",
                    &self.description,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "pixelated",
                    &self.pixelated,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "image_rendering",
                    &self.image_rendering,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "appearance",
                    &self.appearance,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "background",
                    &self.background,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "collapsed",
                    &self.collapsed,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "collapsible",
                    &self.collapsible,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ImageElement {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __field8,
                    __field9,
                    __field10,
                    __field11,
                    __field12,
                    __field13,
                    __field14,
                    __field15,
                    __field16,
                    __field17,
                    __field18,
                    __field19,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            8u64 => _serde::__private::Ok(__Field::__field8),
                            9u64 => _serde::__private::Ok(__Field::__field9),
                            10u64 => _serde::__private::Ok(__Field::__field10),
                            11u64 => _serde::__private::Ok(__Field::__field11),
                            12u64 => _serde::__private::Ok(__Field::__field12),
                            13u64 => _serde::__private::Ok(__Field::__field13),
                            14u64 => _serde::__private::Ok(__Field::__field14),
                            15u64 => _serde::__private::Ok(__Field::__field15),
                            16u64 => _serde::__private::Ok(__Field::__field16),
                            17u64 => _serde::__private::Ok(__Field::__field17),
                            18u64 => _serde::__private::Ok(__Field::__field18),
                            19u64 => _serde::__private::Ok(__Field::__field19),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "content" => _serde::__private::Ok(__Field::__field0),
                            "vertical_align" => _serde::__private::Ok(__Field::__field1),
                            "border" => _serde::__private::Ok(__Field::__field2),
                            "border_radius" => _serde::__private::Ok(__Field::__field3),
                            "size_units" => _serde::__private::Ok(__Field::__field4),
                            "data" => _serde::__private::Ok(__Field::__field5),
                            "path" => _serde::__private::Ok(__Field::__field6),
                            "width" => _serde::__private::Ok(__Field::__field7),
                            "height" => _serde::__private::Ok(__Field::__field8),
                            "preferred_width" => _serde::__private::Ok(__Field::__field9),
                            "preferred_height" => {
                                _serde::__private::Ok(__Field::__field10)
                            }
                            "title" => _serde::__private::Ok(__Field::__field11),
                            "alt" => _serde::__private::Ok(__Field::__field12),
                            "description" => _serde::__private::Ok(__Field::__field13),
                            "pixelated" => _serde::__private::Ok(__Field::__field14),
                            "image_rendering" => {
                                _serde::__private::Ok(__Field::__field15)
                            }
                            "appearance" => _serde::__private::Ok(__Field::__field16),
                            "background" => _serde::__private::Ok(__Field::__field17),
                            "collapsed" => _serde::__private::Ok(__Field::__field18),
                            "collapsible" => _serde::__private::Ok(__Field::__field19),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"content" => _serde::__private::Ok(__Field::__field0),
                            b"vertical_align" => _serde::__private::Ok(__Field::__field1),
                            b"border" => _serde::__private::Ok(__Field::__field2),
                            b"border_radius" => _serde::__private::Ok(__Field::__field3),
                            b"size_units" => _serde::__private::Ok(__Field::__field4),
                            b"data" => _serde::__private::Ok(__Field::__field5),
                            b"path" => _serde::__private::Ok(__Field::__field6),
                            b"width" => _serde::__private::Ok(__Field::__field7),
                            b"height" => _serde::__private::Ok(__Field::__field8),
                            b"preferred_width" => {
                                _serde::__private::Ok(__Field::__field9)
                            }
                            b"preferred_height" => {
                                _serde::__private::Ok(__Field::__field10)
                            }
                            b"title" => _serde::__private::Ok(__Field::__field11),
                            b"alt" => _serde::__private::Ok(__Field::__field12),
                            b"description" => _serde::__private::Ok(__Field::__field13),
                            b"pixelated" => _serde::__private::Ok(__Field::__field14),
                            b"image_rendering" => {
                                _serde::__private::Ok(__Field::__field15)
                            }
                            b"appearance" => _serde::__private::Ok(__Field::__field16),
                            b"background" => _serde::__private::Ok(__Field::__field17),
                            b"collapsed" => _serde::__private::Ok(__Field::__field18),
                            b"collapsible" => _serde::__private::Ok(__Field::__field19),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ImageElement>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ImageElement;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct ImageElement",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            Option<()>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct ImageElement with 20 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            Option<VerticalAlign>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct ImageElement with 20 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct ImageElement with 20 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct ImageElement with 20 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            Option<SizeUnits>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct ImageElement with 20 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            Option<IndexMap<String, String>>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct ImageElement with 20 elements",
                                    ),
                                );
                            }
                        };
                        let __field6 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        6usize,
                                        &"struct ImageElement with 20 elements",
                                    ),
                                );
                            }
                        };
                        let __field7 = match _serde::de::SeqAccess::next_element::<
                            Option<f32>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        7usize,
                                        &"struct ImageElement with 20 elements",
                                    ),
                                );
                            }
                        };
                        let __field8 = match _serde::de::SeqAccess::next_element::<
                            Option<f32>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        8usize,
                                        &"struct ImageElement with 20 elements",
                                    ),
                                );
                            }
                        };
                        let __field9 = match _serde::de::SeqAccess::next_element::<
                            Option<f32>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        9usize,
                                        &"struct ImageElement with 20 elements",
                                    ),
                                );
                            }
                        };
                        let __field10 = match _serde::de::SeqAccess::next_element::<
                            Option<f32>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        10usize,
                                        &"struct ImageElement with 20 elements",
                                    ),
                                );
                            }
                        };
                        let __field11 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        11usize,
                                        &"struct ImageElement with 20 elements",
                                    ),
                                );
                            }
                        };
                        let __field12 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        12usize,
                                        &"struct ImageElement with 20 elements",
                                    ),
                                );
                            }
                        };
                        let __field13 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        13usize,
                                        &"struct ImageElement with 20 elements",
                                    ),
                                );
                            }
                        };
                        let __field14 = match _serde::de::SeqAccess::next_element::<
                            Option<bool>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        14usize,
                                        &"struct ImageElement with 20 elements",
                                    ),
                                );
                            }
                        };
                        let __field15 = match _serde::de::SeqAccess::next_element::<
                            Option<ImageRendering>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        15usize,
                                        &"struct ImageElement with 20 elements",
                                    ),
                                );
                            }
                        };
                        let __field16 = match _serde::de::SeqAccess::next_element::<
                            Option<ImageAppearance>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        16usize,
                                        &"struct ImageElement with 20 elements",
                                    ),
                                );
                            }
                        };
                        let __field17 = match _serde::de::SeqAccess::next_element::<
                            Option<bool>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        17usize,
                                        &"struct ImageElement with 20 elements",
                                    ),
                                );
                            }
                        };
                        let __field18 = match _serde::de::SeqAccess::next_element::<
                            Option<bool>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        18usize,
                                        &"struct ImageElement with 20 elements",
                                    ),
                                );
                            }
                        };
                        let __field19 = match _serde::de::SeqAccess::next_element::<
                            Option<bool>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        19usize,
                                        &"struct ImageElement with 20 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(ImageElement {
                            content: __field0,
                            vertical_align: __field1,
                            border: __field2,
                            border_radius: __field3,
                            size_units: __field4,
                            data: __field5,
                            path: __field6,
                            width: __field7,
                            height: __field8,
                            preferred_width: __field9,
                            preferred_height: __field10,
                            title: __field11,
                            alt: __field12,
                            description: __field13,
                            pixelated: __field14,
                            image_rendering: __field15,
                            appearance: __field16,
                            background: __field17,
                            collapsed: __field18,
                            collapsible: __field19,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<Option<()>> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            Option<VerticalAlign>,
                        > = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<Option<SizeUnits>> = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<
                            Option<IndexMap<String, String>>,
                        > = _serde::__private::None;
                        let mut __field6: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field7: _serde::__private::Option<Option<f32>> = _serde::__private::None;
                        let mut __field8: _serde::__private::Option<Option<f32>> = _serde::__private::None;
                        let mut __field9: _serde::__private::Option<Option<f32>> = _serde::__private::None;
                        let mut __field10: _serde::__private::Option<Option<f32>> = _serde::__private::None;
                        let mut __field11: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field12: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field13: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field14: _serde::__private::Option<Option<bool>> = _serde::__private::None;
                        let mut __field15: _serde::__private::Option<
                            Option<ImageRendering>,
                        > = _serde::__private::None;
                        let mut __field16: _serde::__private::Option<
                            Option<ImageAppearance>,
                        > = _serde::__private::None;
                        let mut __field17: _serde::__private::Option<Option<bool>> = _serde::__private::None;
                        let mut __field18: _serde::__private::Option<Option<bool>> = _serde::__private::None;
                        let mut __field19: _serde::__private::Option<Option<bool>> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "content",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Option<()>>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "vertical_align",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<VerticalAlign>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("border"),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "border_radius",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "size_units",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<SizeUnits>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("data"),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<IndexMap<String, String>>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("path"),
                                        );
                                    }
                                    __field6 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field7 => {
                                    if _serde::__private::Option::is_some(&__field7) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("width"),
                                        );
                                    }
                                    __field7 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<f32>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field8 => {
                                    if _serde::__private::Option::is_some(&__field8) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("height"),
                                        );
                                    }
                                    __field8 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<f32>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field9 => {
                                    if _serde::__private::Option::is_some(&__field9) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "preferred_width",
                                            ),
                                        );
                                    }
                                    __field9 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<f32>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field10 => {
                                    if _serde::__private::Option::is_some(&__field10) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "preferred_height",
                                            ),
                                        );
                                    }
                                    __field10 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<f32>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field11 => {
                                    if _serde::__private::Option::is_some(&__field11) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("title"),
                                        );
                                    }
                                    __field11 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field12 => {
                                    if _serde::__private::Option::is_some(&__field12) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("alt"),
                                        );
                                    }
                                    __field12 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field13 => {
                                    if _serde::__private::Option::is_some(&__field13) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "description",
                                            ),
                                        );
                                    }
                                    __field13 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field14 => {
                                    if _serde::__private::Option::is_some(&__field14) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "pixelated",
                                            ),
                                        );
                                    }
                                    __field14 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<bool>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field15 => {
                                    if _serde::__private::Option::is_some(&__field15) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "image_rendering",
                                            ),
                                        );
                                    }
                                    __field15 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<ImageRendering>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field16 => {
                                    if _serde::__private::Option::is_some(&__field16) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "appearance",
                                            ),
                                        );
                                    }
                                    __field16 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<ImageAppearance>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field17 => {
                                    if _serde::__private::Option::is_some(&__field17) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "background",
                                            ),
                                        );
                                    }
                                    __field17 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<bool>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field18 => {
                                    if _serde::__private::Option::is_some(&__field18) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "collapsed",
                                            ),
                                        );
                                    }
                                    __field18 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<bool>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field19 => {
                                    if _serde::__private::Option::is_some(&__field19) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "collapsible",
                                            ),
                                        );
                                    }
                                    __field19 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<bool>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("content")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("vertical_align")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("border")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("border_radius")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("size_units")?
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("data")?
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("path")?
                            }
                        };
                        let __field7 = match __field7 {
                            _serde::__private::Some(__field7) => __field7,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("width")?
                            }
                        };
                        let __field8 = match __field8 {
                            _serde::__private::Some(__field8) => __field8,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("height")?
                            }
                        };
                        let __field9 = match __field9 {
                            _serde::__private::Some(__field9) => __field9,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("preferred_width")?
                            }
                        };
                        let __field10 = match __field10 {
                            _serde::__private::Some(__field10) => __field10,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("preferred_height")?
                            }
                        };
                        let __field11 = match __field11 {
                            _serde::__private::Some(__field11) => __field11,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("title")?
                            }
                        };
                        let __field12 = match __field12 {
                            _serde::__private::Some(__field12) => __field12,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("alt")?
                            }
                        };
                        let __field13 = match __field13 {
                            _serde::__private::Some(__field13) => __field13,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("description")?
                            }
                        };
                        let __field14 = match __field14 {
                            _serde::__private::Some(__field14) => __field14,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("pixelated")?
                            }
                        };
                        let __field15 = match __field15 {
                            _serde::__private::Some(__field15) => __field15,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("image_rendering")?
                            }
                        };
                        let __field16 = match __field16 {
                            _serde::__private::Some(__field16) => __field16,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("appearance")?
                            }
                        };
                        let __field17 = match __field17 {
                            _serde::__private::Some(__field17) => __field17,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("background")?
                            }
                        };
                        let __field18 = match __field18 {
                            _serde::__private::Some(__field18) => __field18,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("collapsed")?
                            }
                        };
                        let __field19 = match __field19 {
                            _serde::__private::Some(__field19) => __field19,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("collapsible")?
                            }
                        };
                        _serde::__private::Ok(ImageElement {
                            content: __field0,
                            vertical_align: __field1,
                            border: __field2,
                            border_radius: __field3,
                            size_units: __field4,
                            data: __field5,
                            path: __field6,
                            width: __field7,
                            height: __field8,
                            preferred_width: __field9,
                            preferred_height: __field10,
                            title: __field11,
                            alt: __field12,
                            description: __field13,
                            pixelated: __field14,
                            image_rendering: __field15,
                            appearance: __field16,
                            background: __field17,
                            collapsed: __field18,
                            collapsible: __field19,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "content",
                    "vertical_align",
                    "border",
                    "border_radius",
                    "size_units",
                    "data",
                    "path",
                    "width",
                    "height",
                    "preferred_width",
                    "preferred_height",
                    "title",
                    "alt",
                    "description",
                    "pixelated",
                    "image_rendering",
                    "appearance",
                    "background",
                    "collapsed",
                    "collapsible",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ImageElement",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ImageElement>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
}
mod test_utils {
    use std::{path::PathBuf, sync::{Arc, LazyLock}};
    use tempfile::{tempdir_in, TempDir};
    use crate::database::dictionary_database::DictionaryDatabase;
    pub(crate) struct TestPaths {
        pub tests_dir: PathBuf,
        pub tests_yomichan_db_path: PathBuf,
        pub test_dicts_dir: PathBuf,
    }
    pub(crate) static TEST_PATHS: LazyLock<TestPaths> = LazyLock::new(|| TestPaths {
        tests_dir: PathBuf::from("./tests"),
        tests_yomichan_db_path: PathBuf::from("./tests")
            .join("yomichan_rs")
            .join("db.ycd"),
        test_dicts_dir: PathBuf::from("tests").join("test_dicts"),
    });
    pub(crate) static SHARED_DB_INSTANCE: LazyLock<DictionaryDatabase> = LazyLock::new(||
    {
        let db_path = &*TEST_PATHS.tests_yomichan_db_path;
        if !db_path.exists() {
            {
                ::core::panicking::panic_fmt(
                    format_args!(
                        "SHARED_DB_INSTANCE: The database path for tests does not exist: {0:?}",
                        db_path,
                    ),
                );
            };
        }
        DictionaryDatabase::new(db_path)
    });
    pub(crate) enum BacktraceKind {
        One,
        Full,
    }
    impl std::fmt::Display for BacktraceKind {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let x = match self {
                BacktraceKind::One => "1",
                BacktraceKind::Full => "full",
            };
            f.write_fmt(format_args!("{0}", x))
        }
    }
    pub(crate) fn set_backtrace(kind: BacktraceKind) {
        std::env::set_var("RUST_BACKTRACE", kind.to_string());
    }
    /// Copies the test database to a temporary directory.
    /// Necessary because native_db cannot have two test threads
    /// with different Database connections open the same file at the same time.
    pub(crate) fn copy_test_db() -> (PathBuf, TempDir) {
        let dir = tempdir_in(&*TEST_PATHS.tests_dir).unwrap();
        let tydbp = &*TEST_PATHS.tests_yomichan_db_path;
        let f_path = dir.path().join("data.ycd");
        if !tydbp.exists() {
            {
                ::core::panicking::panic_fmt(
                    format_args!("tests/yomichan_db_path doesn\'t exist! : {0:?}", tydbp),
                );
            };
        }
        std::fs::copy(tydbp, &f_path).unwrap();
        if !f_path.exists() {
            {
                ::core::panicking::panic_fmt(
                    format_args!("path doesn\'t exist! : {0:?}", f_path),
                );
            };
        }
        (f_path, dir)
    }
    pub(crate) fn print_timer<T>(inst: std::time::Instant, print: T)
    where
        T: std::fmt::Debug,
    {
        let duration = inst.elapsed();
        #[allow(unused_assignments)]
        let mut time = String::new();
        {
            let dur_sec = duration.as_secs();
            let dur_mill = duration.as_millis();
            let dur_nan = duration.as_nanos();
            if dur_sec == 0 {
                if dur_mill == 0 {
                    time = ::alloc::__export::must_use({
                        let res = ::alloc::fmt::format(format_args!("{0}ns", dur_mill));
                        res
                    });
                } else {
                    time = ::alloc::__export::must_use({
                        let res = ::alloc::fmt::format(format_args!("{0}ms", dur_nan));
                        res
                    });
                }
            } else if dur_sec > 60 {
                let min = dur_sec / 60;
                let sec = dur_sec % 60;
                time = ::alloc::__export::must_use({
                    let res = ::alloc::fmt::format(format_args!("{0}m{1}s", min, sec));
                    res
                });
            } else {
                time = ::alloc::__export::must_use({
                    let res = ::alloc::fmt::format(format_args!("{0}s", dur_sec));
                    res
                });
            }
        }
        {
            ::std::io::_print(format_args!("{0:?} files\n", print));
        };
        {
            ::std::io::_print(format_args!("in {0}\n", time));
        };
    }
}
mod text_scanner {
    use std::{cmp, sync::Arc};
    use crate::{
        backend::FindTermsDetails, database::dictionary_database::DictionaryDatabase,
        dictionary::{TermDictionaryEntry, TermSourceMatchType},
        settings::ProfileOptions,
        translator::{FindTermsMode, FindTermsResult, Translator},
        Yomichan,
    };
    impl<'a> Yomichan<'a> {
        fn search(&mut self, text: &str) -> Option<TermSearchResults> {
            let opts = &self.backend.options.get_current_profile().options;
            self.backend.text_scanner._search_internal(text, 0, opts)
        }
    }
    /// Represents the full sentence context for a search result.
    ///
    /// * offset: The character offset of the original search text within the full sentence text.
    pub struct Sentence {
        pub text: String,
        pub offset: usize,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Sentence {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "Sentence",
                "text",
                &self.text,
                "offset",
                &&self.offset,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Sentence {
        #[inline]
        fn clone(&self) -> Sentence {
            Sentence {
                text: ::core::clone::Clone::clone(&self.text),
                offset: ::core::clone::Clone::clone(&self.offset),
            }
        }
    }
    /// The final, structured result of a term search.
    pub struct TermSearchResults {
        pub dictionary_entries: Vec<TermDictionaryEntry>,
        pub sentence: Sentence,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TermSearchResults {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "TermSearchResults",
                "dictionary_entries",
                &self.dictionary_entries,
                "sentence",
                &&self.sentence,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TermSearchResults {
        #[inline]
        fn clone(&self) -> TermSearchResults {
            TermSearchResults {
                dictionary_entries: ::core::clone::Clone::clone(
                    &self.dictionary_entries,
                ),
                sentence: ::core::clone::Clone::clone(&self.sentence),
            }
        }
    }
    /// A simplified text scanner to find dictionary terms and sentence context,
    /// inspired by Yomitan's core logic.
    pub struct TextScanner<'a> {
        /// A mutable reference to the core translator engine.
        translator: Translator<'a>,
        /// The maximum number of characters to scan for terms initially.
        /// Corresponds to `_scanLength` in JS.
        scan_len: usize,
        /// How far back and forward to scan for sentence boundaries.
        /// Corresponds to `_sentenceScanExtent` in JS.
        sentence_scan_extent: usize,
        /// Whether a newline character should terminate a sentence.
        /// Corresponds to `_sentenceTerminateAtNewlines` in JS.
        sentence_terminate_at_newlines: bool,
        /// The match type to use for finding terms (e.g., exact or prefix).
        /// Corresponds to `_matchTypePrefix` in JS.
        match_type: TermSourceMatchType,
    }
    impl<'a> TextScanner<'a> {
        /// Creates a new TextScanner with default or provided configuration.
        pub fn new(db: Arc<DictionaryDatabase<'a>>) -> Self {
            TextScanner {
                translator: Translator::new(db),
                scan_len: 20,
                sentence_scan_extent: 50,
                sentence_terminate_at_newlines: true,
                match_type: TermSourceMatchType::Exact,
            }
        }
        /// The main entry point for scanning text.
        /// Takes a full text block and a starting character position.
        ///
        /// # Arguments
        /// * `full_text` - The entire string to be scanned (e.g., a paragraph).
        /// * `start_position` - The character index in `full_text` where the scan should begin.
        /// * `options` - Search options, see [ProfileOptions].
        ///
        /// # Returns
        /// An option [TermSearchResults] containing the sorted dictionary entries and sentence context.
        pub fn _search_internal(
            &mut self,
            full_text: &str,
            start_position: usize,
            options: &ProfileOptions,
        ) -> Option<TermSearchResults> {
            let search_text_ref = self
                .get_text_source_content(full_text, start_position);
            if search_text_ref.is_empty() {
                return None;
            }
            let search_text = search_text_ref.to_string();
            let find_result = self.find_term_dictionary_entries(&search_text, options)?;
            let sentence = self
                .extract_sentence(
                    full_text,
                    start_position,
                    find_result.original_text_length as usize,
                );
            Some(TermSearchResults {
                dictionary_entries: find_result.dictionary_entries,
                sentence,
            })
        }
        /// Gets the initial chunk of text to be searched.
        fn get_text_source_content<'b>(
            &'a self,
            full_text: &'b str,
            start_position: usize,
        ) -> &'b str {
            let start_byte = match full_text.char_indices().nth(start_position) {
                Some((byte_index, _)) => byte_index,
                None => return "",
            };
            let end_byte = match full_text
                .char_indices()
                .skip(start_position)
                .nth(self.scan_len)
            {
                Some((byte_index, _)) => byte_index,
                None => full_text.len(),
            };
            &full_text[start_byte..end_byte]
        }
        /// Calls the core translator to find dictionary entries.
        fn find_term_dictionary_entries(
            &mut self,
            search_text: &str,
            options: &ProfileOptions,
        ) -> Option<FindTermsResult> {
            let mut details = FindTermsDetails::default();
            if self.match_type == TermSourceMatchType::Prefix {
                details.match_type = Some(TermSourceMatchType::Prefix);
            }
            const MODE: FindTermsMode = FindTermsMode::Group;
            let find_terms_options = Translator::_get_translator_find_terms_options(
                MODE,
                &details,
                options,
            );
            let find_result = self
                .translator
                .find_terms(MODE, search_text, &find_terms_options);
            if find_result.dictionary_entries.is_empty() {
                None
            } else {
                Some(find_result)
            }
        }
        /// Extracts the full sentence surrounding the found term.
        /// Mirrors `extractSentence` in yomitan.
        ///
        /// # Arguments
        /// * start_position: The character index where the scan started.
        /// * parsed_length: The number of characters that were parsed.
        fn extract_sentence(
            &self,
            full_text: &str,
            start_position: usize,
            parsed_length: usize,
        ) -> Sentence {
            let context_start_char = start_position
                .saturating_sub(self.sentence_scan_extent);
            let parsed_end_char = start_position + parsed_length;
            let context_end_char = cmp::min(
                full_text.chars().count(),
                parsed_end_char + self.sentence_scan_extent,
            );
            let mut sentence_start_char = start_position;
            for (i, c) in full_text
                .char_indices()
                .rev()
                .skip(full_text.chars().count() - start_position)
            {
                if i < context_start_char {
                    break;
                }
                if ".!?\n".contains(c) && self.sentence_terminate_at_newlines {
                    sentence_start_char = full_text[..i].chars().count() + 1;
                    break;
                }
            }
            sentence_start_char = cmp::max(context_start_char, sentence_start_char);
            let mut sentence_end_char = parsed_end_char;
            for (i, c) in full_text.char_indices().skip(parsed_end_char) {
                if i >= context_end_char {
                    break;
                }
                if ".!?\n".contains(c) && self.sentence_terminate_at_newlines {
                    sentence_end_char = full_text[..i].chars().count() + 1;
                    break;
                }
            }
            sentence_end_char = cmp::min(context_end_char, sentence_end_char);
            let sentence_start_byte = full_text
                .char_indices()
                .nth(sentence_start_char)
                .map_or(0, |(b, _)| b);
            let sentence_end_byte = full_text
                .char_indices()
                .nth(sentence_end_char)
                .map_or(full_text.len(), |(b, _)| b);
            let sentence_slice = &full_text[sentence_start_byte..sentence_end_byte];
            let trimmed_sentence = sentence_slice.trim();
            let leading_whitespace_len = sentence_slice.len()
                - sentence_slice.trim_start().len();
            let leading_whitespace_chars = sentence_slice[..leading_whitespace_len]
                .chars()
                .count();
            let offset = start_position
                .saturating_sub(sentence_start_char)
                .saturating_sub(leading_whitespace_chars);
            Sentence {
                text: trimmed_sentence.to_string(),
                offset,
            }
        }
    }
}
mod translation {
    use fancy_regex::Regex;
    use indexmap::{IndexMap, IndexSet};
    use language_transformer::language_d::FindTermsTextReplacements;
    use serde::{Deserialize, Serialize};
    use crate::{
        database::dictionary_database::DictionarySet, dictionary::TermSourceMatchType,
        settings::SearchResolution,
    };
    /// An options object for use with `Translator.find_kanji`.
    pub struct FindKanjiOptions {
        /// The mapping of dictionaries to search for kanji in.
        /// The key is the dictionary name.
        pub enabled_dictionary_map: KanjiEnabledDictionaryMap,
        /// Whether or not non-Japanese characters should be searched.
        pub remove_non_japanese_characters: bool,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for FindKanjiOptions {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "FindKanjiOptions",
                "enabled_dictionary_map",
                &self.enabled_dictionary_map,
                "remove_non_japanese_characters",
                &&self.remove_non_japanese_characters,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for FindKanjiOptions {
        #[inline]
        fn clone(&self) -> FindKanjiOptions {
            FindKanjiOptions {
                enabled_dictionary_map: ::core::clone::Clone::clone(
                    &self.enabled_dictionary_map,
                ),
                remove_non_japanese_characters: ::core::clone::Clone::clone(
                    &self.remove_non_japanese_characters,
                ),
            }
        }
    }
    /// Details about a dictionary.
    pub struct FindKanjiDictionary {
        /// The index of the dictionary
        pub index: usize,
        /// The alias of the dictionary
        pub alias: String,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for FindKanjiDictionary {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "FindKanjiDictionary",
                "index",
                &self.index,
                "alias",
                &&self.alias,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for FindKanjiDictionary {
        #[inline]
        fn clone(&self) -> FindKanjiDictionary {
            FindKanjiDictionary {
                index: ::core::clone::Clone::clone(&self.index),
                alias: ::core::clone::Clone::clone(&self.alias),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for FindKanjiDictionary {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for FindKanjiDictionary {
        #[inline]
        fn eq(&self, other: &FindKanjiDictionary) -> bool {
            self.index == other.index && self.alias == other.alias
        }
    }
    /// An options object for use with `Translator.find_terms`.
    pub struct FindTermsOptions {
        /// The matching type for looking up terms.
        pub match_type: FindTermsMatchType,
        /// Whether or not deinflection should be performed.
        pub deinflect: bool,
        /// The reading which will be sorted to the top of the results.
        pub primary_reading: String,
        /// The name of the primary dictionary to search.
        pub main_dictionary: String,
        /// The name of the frequency dictionary used for sorting
        pub sort_frequency_dictionary: Option<String>,
        /// The order used when using a sorting dictionary.
        pub sort_frequency_dictionary_order: FindTermsSortOrder,
        /// Whether or not non-Japanese characters should be searched.
        pub remove_non_japanese_characters: bool,
        /// An iterable sequence of text replacements to be applied during the term lookup process.
        pub text_replacements: FindTermsTextReplacements,
        /// The mapping of dictionaries to search for terms in.
        /// The key is the dictionary name.
        pub enabled_dictionary_map: TermEnabledDictionaryMap,
        /// A set of dictionary names which should have definitions removed.
        pub exclude_dictionary_definitions: Option<IndexSet<String>>,
        /// Whether every substring should be searched for, or only whole words.
        pub search_resolution: SearchResolution,
        /// ISO-639 code of the language.
        pub language: String,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for FindTermsOptions {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "match_type",
                "deinflect",
                "primary_reading",
                "main_dictionary",
                "sort_frequency_dictionary",
                "sort_frequency_dictionary_order",
                "remove_non_japanese_characters",
                "text_replacements",
                "enabled_dictionary_map",
                "exclude_dictionary_definitions",
                "search_resolution",
                "language",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.match_type,
                &self.deinflect,
                &self.primary_reading,
                &self.main_dictionary,
                &self.sort_frequency_dictionary,
                &self.sort_frequency_dictionary_order,
                &self.remove_non_japanese_characters,
                &self.text_replacements,
                &self.enabled_dictionary_map,
                &self.exclude_dictionary_definitions,
                &self.search_resolution,
                &&self.language,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "FindTermsOptions",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for FindTermsOptions {
        #[inline]
        fn clone(&self) -> FindTermsOptions {
            FindTermsOptions {
                match_type: ::core::clone::Clone::clone(&self.match_type),
                deinflect: ::core::clone::Clone::clone(&self.deinflect),
                primary_reading: ::core::clone::Clone::clone(&self.primary_reading),
                main_dictionary: ::core::clone::Clone::clone(&self.main_dictionary),
                sort_frequency_dictionary: ::core::clone::Clone::clone(
                    &self.sort_frequency_dictionary,
                ),
                sort_frequency_dictionary_order: ::core::clone::Clone::clone(
                    &self.sort_frequency_dictionary_order,
                ),
                remove_non_japanese_characters: ::core::clone::Clone::clone(
                    &self.remove_non_japanese_characters,
                ),
                text_replacements: ::core::clone::Clone::clone(&self.text_replacements),
                enabled_dictionary_map: ::core::clone::Clone::clone(
                    &self.enabled_dictionary_map,
                ),
                exclude_dictionary_definitions: ::core::clone::Clone::clone(
                    &self.exclude_dictionary_definitions,
                ),
                search_resolution: ::core::clone::Clone::clone(&self.search_resolution),
                language: ::core::clone::Clone::clone(&self.language),
            }
        }
    }
    impl FindTermsOptions {
        pub fn default_for_language(language: &str) -> Self {
            Self {
                match_type: TermSourceMatchType::Exact,
                deinflect: true,
                primary_reading: "".into(),
                main_dictionary: "".into(),
                sort_frequency_dictionary: None,
                sort_frequency_dictionary_order: FindTermsSortOrder::Ascending,
                remove_non_japanese_characters: false,
                text_replacements: ::alloc::vec::Vec::new(),
                enabled_dictionary_map: IndexMap::default(),
                exclude_dictionary_definitions: None,
                search_resolution: SearchResolution::Word,
                language: language.to_string(),
            }
        }
    }
    /// The matching type for looking up terms.
    pub type FindTermsMatchType = TermSourceMatchType;
    /// A sorting order to use when finding terms.
    pub enum FindTermsSortOrder {
        Ascending,
        #[default]
        Descending,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for FindTermsSortOrder {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    FindTermsSortOrder::Ascending => "Ascending",
                    FindTermsSortOrder::Descending => "Descending",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for FindTermsSortOrder {
        #[inline]
        fn clone(&self) -> FindTermsSortOrder {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for FindTermsSortOrder {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for FindTermsSortOrder {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for FindTermsSortOrder {
        #[inline]
        fn eq(&self, other: &FindTermsSortOrder) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for FindTermsSortOrder {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for FindTermsSortOrder {
        #[inline]
        fn partial_cmp(
            &self,
            other: &FindTermsSortOrder,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            ::core::cmp::PartialOrd::partial_cmp(&__self_discr, &__arg1_discr)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for FindTermsSortOrder {
        #[inline]
        fn cmp(&self, other: &FindTermsSortOrder) -> ::core::cmp::Ordering {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            ::core::cmp::Ord::cmp(&__self_discr, &__arg1_discr)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for FindTermsSortOrder {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_discr, state)
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for FindTermsSortOrder {
        #[inline]
        fn default() -> FindTermsSortOrder {
            Self::Descending
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for FindTermsSortOrder {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    FindTermsSortOrder::Ascending => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "FindTermsSortOrder",
                            0u32,
                            "Ascending",
                        )
                    }
                    FindTermsSortOrder::Descending => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "FindTermsSortOrder",
                            1u32,
                            "Descending",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for FindTermsSortOrder {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 2",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Ascending" => _serde::__private::Ok(__Field::__field0),
                            "Descending" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Ascending" => _serde::__private::Ok(__Field::__field0),
                            b"Descending" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<FindTermsSortOrder>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = FindTermsSortOrder;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum FindTermsSortOrder",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(FindTermsSortOrder::Ascending)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(FindTermsSortOrder::Descending)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["Ascending", "Descending"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "FindTermsSortOrder",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<FindTermsSortOrder>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    impl FindTermsSortOrder {
        pub fn from_str(s: &str) -> Result<Self, String> {
            match s {
                "ascending" => Ok(FindTermsSortOrder::Ascending),
                "descending" => Ok(FindTermsSortOrder::Descending),
                _ => {
                    Err(
                        ::alloc::__export::must_use({
                            let res = ::alloc::fmt::format(
                                format_args!("Invalid FindTermsSortOrder: {0}", s),
                            );
                            res
                        }),
                    )
                }
            }
        }
    }
    pub type FindTermDictionaryMap = IndexMap<String, FindTermDictionary>;
    /// Details about a dictionary.
    pub struct FindTermDictionary {
        /// The index of the dictionary
        pub index: usize,
        /// The alias of the dictionary
        pub alias: String,
        /// Whether or not secondary term searches are allowed for this dictionary.
        pub allow_secondary_searches: bool,
        /// Whether this dictionary's part of speech rules should be used to filter results.
        pub parts_of_speech_filter: bool,
        /// Whether to use the deinflections from this dictionary.
        pub use_deinflections: bool,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for FindTermDictionary {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "FindTermDictionary",
                "index",
                &self.index,
                "alias",
                &self.alias,
                "allow_secondary_searches",
                &self.allow_secondary_searches,
                "parts_of_speech_filter",
                &self.parts_of_speech_filter,
                "use_deinflections",
                &&self.use_deinflections,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for FindTermDictionary {
        #[inline]
        fn clone(&self) -> FindTermDictionary {
            FindTermDictionary {
                index: ::core::clone::Clone::clone(&self.index),
                alias: ::core::clone::Clone::clone(&self.alias),
                allow_secondary_searches: ::core::clone::Clone::clone(
                    &self.allow_secondary_searches,
                ),
                parts_of_speech_filter: ::core::clone::Clone::clone(
                    &self.parts_of_speech_filter,
                ),
                use_deinflections: ::core::clone::Clone::clone(&self.use_deinflections),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for FindTermDictionary {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for FindTermDictionary {
        #[inline]
        fn eq(&self, other: &FindTermDictionary) -> bool {
            self.index == other.index && self.alias == other.alias
                && self.allow_secondary_searches == other.allow_secondary_searches
                && self.parts_of_speech_filter == other.parts_of_speech_filter
                && self.use_deinflections == other.use_deinflections
        }
    }
    pub type TermEnabledDictionaryMap = IndexMap<String, FindTermDictionary>;
    pub type KanjiEnabledDictionaryMap = IndexMap<String, FindKanjiDictionary>;
}
mod translation_internal {
    use std::any::Any;
    use indexmap::{IndexMap, IndexSet};
    use language_transformer::language_d::TextProcessorSetting;
    use language_transformer::transformer::{
        InflectionRuleChainCandidate, InternalInflectionRuleChainCandidate,
    };
    use serde::{Deserialize, Serialize};
    use crate::database::dictionary_database::TermEntry;
    use crate::dictionary::{
        self, TermDefinition, TermDictionaryEntry, TermFrequency, TermHeadword,
        TermPronunciation, TermSourceMatchSource,
    };
    pub type TextProcessorRuleChainCandidate = Vec<String>;
    pub type VariantAndTextProcessorRuleChainCandidatesMap = IndexMap<
        String,
        Vec<TextProcessorRuleChainCandidate>,
    >;
    /// A dictionary entry for a term or group of terms.
    /// The only difference here is that it's inflection_rule_chain_candidates are strings
    pub struct InternalTermDictionaryEntry {
        /// This should always be [TermSourceMatchSource::Term]
        pub entry_type: TermSourceMatchSource,
        /// Whether or not any of the sources is a primary source. Primary sources are derived from the
        /// original search text, while non-primary sources originate from related terms.
        pub is_primary: bool,
        /// Ways that a looked-up word might be an transformed into this term.
        pub text_processor_rule_chain_candidates: Vec<TextProcessorRuleChainCandidate>,
        /// Ways that a looked-up word might be an inflected form of this term.
        pub inflection_rule_chain_candidates: Vec<InternalInflectionRuleChainCandidate>,
        /// A score for the dictionary entry.
        pub score: i128,
        /// The sorting value based on the determined term frequency.
        pub frequency_order: i128,
        /// The alias of the dictionary.
        pub dictionary_alias: String,
        /// The index of the dictionary in the original list of dictionaries used for the lookup.
        pub dictionary_index: usize,
        /// The number of primary sources that had an exact text match for the term.
        pub source_term_exact_match_count: usize,
        /// Whether the term reading matched the primary reading.
        pub match_primary_reading: bool,
        /// The maximum length of the original text for all primary sources.
        pub max_original_text_length: usize,
        /// Headwords for the entry.
        pub headwords: Vec<TermHeadword>,
        /// Definitions for the entry.
        pub definitions: Vec<TermDefinition>,
        /// Pronunciations for the entry.
        pub pronunciations: Vec<TermPronunciation>,
        /// Frequencies for the entry.
        pub frequencies: Vec<TermFrequency>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for InternalTermDictionaryEntry {
        #[inline]
        fn clone(&self) -> InternalTermDictionaryEntry {
            InternalTermDictionaryEntry {
                entry_type: ::core::clone::Clone::clone(&self.entry_type),
                is_primary: ::core::clone::Clone::clone(&self.is_primary),
                text_processor_rule_chain_candidates: ::core::clone::Clone::clone(
                    &self.text_processor_rule_chain_candidates,
                ),
                inflection_rule_chain_candidates: ::core::clone::Clone::clone(
                    &self.inflection_rule_chain_candidates,
                ),
                score: ::core::clone::Clone::clone(&self.score),
                frequency_order: ::core::clone::Clone::clone(&self.frequency_order),
                dictionary_alias: ::core::clone::Clone::clone(&self.dictionary_alias),
                dictionary_index: ::core::clone::Clone::clone(&self.dictionary_index),
                source_term_exact_match_count: ::core::clone::Clone::clone(
                    &self.source_term_exact_match_count,
                ),
                match_primary_reading: ::core::clone::Clone::clone(
                    &self.match_primary_reading,
                ),
                max_original_text_length: ::core::clone::Clone::clone(
                    &self.max_original_text_length,
                ),
                headwords: ::core::clone::Clone::clone(&self.headwords),
                definitions: ::core::clone::Clone::clone(&self.definitions),
                pronunciations: ::core::clone::Clone::clone(&self.pronunciations),
                frequencies: ::core::clone::Clone::clone(&self.frequencies),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for InternalTermDictionaryEntry {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "entry_type",
                "is_primary",
                "text_processor_rule_chain_candidates",
                "inflection_rule_chain_candidates",
                "score",
                "frequency_order",
                "dictionary_alias",
                "dictionary_index",
                "source_term_exact_match_count",
                "match_primary_reading",
                "max_original_text_length",
                "headwords",
                "definitions",
                "pronunciations",
                "frequencies",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.entry_type,
                &self.is_primary,
                &self.text_processor_rule_chain_candidates,
                &self.inflection_rule_chain_candidates,
                &self.score,
                &self.frequency_order,
                &self.dictionary_alias,
                &self.dictionary_index,
                &self.source_term_exact_match_count,
                &self.match_primary_reading,
                &self.max_original_text_length,
                &self.headwords,
                &self.definitions,
                &self.pronunciations,
                &&self.frequencies,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "InternalTermDictionaryEntry",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for InternalTermDictionaryEntry {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for InternalTermDictionaryEntry {
        #[inline]
        fn eq(&self, other: &InternalTermDictionaryEntry) -> bool {
            self.entry_type == other.entry_type && self.is_primary == other.is_primary
                && self.text_processor_rule_chain_candidates
                    == other.text_processor_rule_chain_candidates
                && self.inflection_rule_chain_candidates
                    == other.inflection_rule_chain_candidates
                && self.score == other.score
                && self.frequency_order == other.frequency_order
                && self.dictionary_alias == other.dictionary_alias
                && self.dictionary_index == other.dictionary_index
                && self.source_term_exact_match_count
                    == other.source_term_exact_match_count
                && self.match_primary_reading == other.match_primary_reading
                && self.max_original_text_length == other.max_original_text_length
                && self.headwords == other.headwords
                && self.definitions == other.definitions
                && self.pronunciations == other.pronunciations
                && self.frequencies == other.frequencies
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for InternalTermDictionaryEntry {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "InternalTermDictionaryEntry",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1
                        + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "entry_type",
                    &self.entry_type,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "is_primary",
                    &self.is_primary,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "text_processor_rule_chain_candidates",
                    &self.text_processor_rule_chain_candidates,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "inflection_rule_chain_candidates",
                    &self.inflection_rule_chain_candidates,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "score",
                    &self.score,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "frequency_order",
                    &self.frequency_order,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "dictionary_alias",
                    &self.dictionary_alias,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "dictionary_index",
                    &self.dictionary_index,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "source_term_exact_match_count",
                    &self.source_term_exact_match_count,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "match_primary_reading",
                    &self.match_primary_reading,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "max_original_text_length",
                    &self.max_original_text_length,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "headwords",
                    &self.headwords,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "definitions",
                    &self.definitions,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "pronunciations",
                    &self.pronunciations,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "frequencies",
                    &self.frequencies,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for InternalTermDictionaryEntry {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __field8,
                    __field9,
                    __field10,
                    __field11,
                    __field12,
                    __field13,
                    __field14,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            8u64 => _serde::__private::Ok(__Field::__field8),
                            9u64 => _serde::__private::Ok(__Field::__field9),
                            10u64 => _serde::__private::Ok(__Field::__field10),
                            11u64 => _serde::__private::Ok(__Field::__field11),
                            12u64 => _serde::__private::Ok(__Field::__field12),
                            13u64 => _serde::__private::Ok(__Field::__field13),
                            14u64 => _serde::__private::Ok(__Field::__field14),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "entry_type" => _serde::__private::Ok(__Field::__field0),
                            "is_primary" => _serde::__private::Ok(__Field::__field1),
                            "text_processor_rule_chain_candidates" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            "inflection_rule_chain_candidates" => {
                                _serde::__private::Ok(__Field::__field3)
                            }
                            "score" => _serde::__private::Ok(__Field::__field4),
                            "frequency_order" => _serde::__private::Ok(__Field::__field5),
                            "dictionary_alias" => {
                                _serde::__private::Ok(__Field::__field6)
                            }
                            "dictionary_index" => {
                                _serde::__private::Ok(__Field::__field7)
                            }
                            "source_term_exact_match_count" => {
                                _serde::__private::Ok(__Field::__field8)
                            }
                            "match_primary_reading" => {
                                _serde::__private::Ok(__Field::__field9)
                            }
                            "max_original_text_length" => {
                                _serde::__private::Ok(__Field::__field10)
                            }
                            "headwords" => _serde::__private::Ok(__Field::__field11),
                            "definitions" => _serde::__private::Ok(__Field::__field12),
                            "pronunciations" => _serde::__private::Ok(__Field::__field13),
                            "frequencies" => _serde::__private::Ok(__Field::__field14),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"entry_type" => _serde::__private::Ok(__Field::__field0),
                            b"is_primary" => _serde::__private::Ok(__Field::__field1),
                            b"text_processor_rule_chain_candidates" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            b"inflection_rule_chain_candidates" => {
                                _serde::__private::Ok(__Field::__field3)
                            }
                            b"score" => _serde::__private::Ok(__Field::__field4),
                            b"frequency_order" => {
                                _serde::__private::Ok(__Field::__field5)
                            }
                            b"dictionary_alias" => {
                                _serde::__private::Ok(__Field::__field6)
                            }
                            b"dictionary_index" => {
                                _serde::__private::Ok(__Field::__field7)
                            }
                            b"source_term_exact_match_count" => {
                                _serde::__private::Ok(__Field::__field8)
                            }
                            b"match_primary_reading" => {
                                _serde::__private::Ok(__Field::__field9)
                            }
                            b"max_original_text_length" => {
                                _serde::__private::Ok(__Field::__field10)
                            }
                            b"headwords" => _serde::__private::Ok(__Field::__field11),
                            b"definitions" => _serde::__private::Ok(__Field::__field12),
                            b"pronunciations" => {
                                _serde::__private::Ok(__Field::__field13)
                            }
                            b"frequencies" => _serde::__private::Ok(__Field::__field14),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<InternalTermDictionaryEntry>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = InternalTermDictionaryEntry;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct InternalTermDictionaryEntry",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            TermSourceMatchSource,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct InternalTermDictionaryEntry with 15 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct InternalTermDictionaryEntry with 15 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            Vec<TextProcessorRuleChainCandidate>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct InternalTermDictionaryEntry with 15 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            Vec<InternalInflectionRuleChainCandidate>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct InternalTermDictionaryEntry with 15 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            i128,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct InternalTermDictionaryEntry with 15 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            i128,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct InternalTermDictionaryEntry with 15 elements",
                                    ),
                                );
                            }
                        };
                        let __field6 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        6usize,
                                        &"struct InternalTermDictionaryEntry with 15 elements",
                                    ),
                                );
                            }
                        };
                        let __field7 = match _serde::de::SeqAccess::next_element::<
                            usize,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        7usize,
                                        &"struct InternalTermDictionaryEntry with 15 elements",
                                    ),
                                );
                            }
                        };
                        let __field8 = match _serde::de::SeqAccess::next_element::<
                            usize,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        8usize,
                                        &"struct InternalTermDictionaryEntry with 15 elements",
                                    ),
                                );
                            }
                        };
                        let __field9 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        9usize,
                                        &"struct InternalTermDictionaryEntry with 15 elements",
                                    ),
                                );
                            }
                        };
                        let __field10 = match _serde::de::SeqAccess::next_element::<
                            usize,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        10usize,
                                        &"struct InternalTermDictionaryEntry with 15 elements",
                                    ),
                                );
                            }
                        };
                        let __field11 = match _serde::de::SeqAccess::next_element::<
                            Vec<TermHeadword>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        11usize,
                                        &"struct InternalTermDictionaryEntry with 15 elements",
                                    ),
                                );
                            }
                        };
                        let __field12 = match _serde::de::SeqAccess::next_element::<
                            Vec<TermDefinition>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        12usize,
                                        &"struct InternalTermDictionaryEntry with 15 elements",
                                    ),
                                );
                            }
                        };
                        let __field13 = match _serde::de::SeqAccess::next_element::<
                            Vec<TermPronunciation>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        13usize,
                                        &"struct InternalTermDictionaryEntry with 15 elements",
                                    ),
                                );
                            }
                        };
                        let __field14 = match _serde::de::SeqAccess::next_element::<
                            Vec<TermFrequency>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        14usize,
                                        &"struct InternalTermDictionaryEntry with 15 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(InternalTermDictionaryEntry {
                            entry_type: __field0,
                            is_primary: __field1,
                            text_processor_rule_chain_candidates: __field2,
                            inflection_rule_chain_candidates: __field3,
                            score: __field4,
                            frequency_order: __field5,
                            dictionary_alias: __field6,
                            dictionary_index: __field7,
                            source_term_exact_match_count: __field8,
                            match_primary_reading: __field9,
                            max_original_text_length: __field10,
                            headwords: __field11,
                            definitions: __field12,
                            pronunciations: __field13,
                            frequencies: __field14,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            TermSourceMatchSource,
                        > = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<
                            Vec<TextProcessorRuleChainCandidate>,
                        > = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<
                            Vec<InternalInflectionRuleChainCandidate>,
                        > = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<i128> = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<i128> = _serde::__private::None;
                        let mut __field6: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field7: _serde::__private::Option<usize> = _serde::__private::None;
                        let mut __field8: _serde::__private::Option<usize> = _serde::__private::None;
                        let mut __field9: _serde::__private::Option<bool> = _serde::__private::None;
                        let mut __field10: _serde::__private::Option<usize> = _serde::__private::None;
                        let mut __field11: _serde::__private::Option<
                            Vec<TermHeadword>,
                        > = _serde::__private::None;
                        let mut __field12: _serde::__private::Option<
                            Vec<TermDefinition>,
                        > = _serde::__private::None;
                        let mut __field13: _serde::__private::Option<
                            Vec<TermPronunciation>,
                        > = _serde::__private::None;
                        let mut __field14: _serde::__private::Option<
                            Vec<TermFrequency>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "entry_type",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            TermSourceMatchSource,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "is_primary",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "text_processor_rule_chain_candidates",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<TextProcessorRuleChainCandidate>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "inflection_rule_chain_candidates",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<InternalInflectionRuleChainCandidate>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("score"),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i128>(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "frequency_order",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i128>(&mut __map)?,
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "dictionary_alias",
                                            ),
                                        );
                                    }
                                    __field6 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field7 => {
                                    if _serde::__private::Option::is_some(&__field7) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "dictionary_index",
                                            ),
                                        );
                                    }
                                    __field7 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<usize>(&mut __map)?,
                                    );
                                }
                                __Field::__field8 => {
                                    if _serde::__private::Option::is_some(&__field8) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "source_term_exact_match_count",
                                            ),
                                        );
                                    }
                                    __field8 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<usize>(&mut __map)?,
                                    );
                                }
                                __Field::__field9 => {
                                    if _serde::__private::Option::is_some(&__field9) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "match_primary_reading",
                                            ),
                                        );
                                    }
                                    __field9 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                __Field::__field10 => {
                                    if _serde::__private::Option::is_some(&__field10) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "max_original_text_length",
                                            ),
                                        );
                                    }
                                    __field10 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<usize>(&mut __map)?,
                                    );
                                }
                                __Field::__field11 => {
                                    if _serde::__private::Option::is_some(&__field11) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "headwords",
                                            ),
                                        );
                                    }
                                    __field11 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<TermHeadword>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field12 => {
                                    if _serde::__private::Option::is_some(&__field12) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "definitions",
                                            ),
                                        );
                                    }
                                    __field12 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<TermDefinition>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field13 => {
                                    if _serde::__private::Option::is_some(&__field13) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "pronunciations",
                                            ),
                                        );
                                    }
                                    __field13 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<TermPronunciation>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field14 => {
                                    if _serde::__private::Option::is_some(&__field14) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "frequencies",
                                            ),
                                        );
                                    }
                                    __field14 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<TermFrequency>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("entry_type")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("is_primary")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "text_processor_rule_chain_candidates",
                                )?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "inflection_rule_chain_candidates",
                                )?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("score")?
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("frequency_order")?
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("dictionary_alias")?
                            }
                        };
                        let __field7 = match __field7 {
                            _serde::__private::Some(__field7) => __field7,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("dictionary_index")?
                            }
                        };
                        let __field8 = match __field8 {
                            _serde::__private::Some(__field8) => __field8,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "source_term_exact_match_count",
                                )?
                            }
                        };
                        let __field9 = match __field9 {
                            _serde::__private::Some(__field9) => __field9,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "match_primary_reading",
                                )?
                            }
                        };
                        let __field10 = match __field10 {
                            _serde::__private::Some(__field10) => __field10,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field(
                                    "max_original_text_length",
                                )?
                            }
                        };
                        let __field11 = match __field11 {
                            _serde::__private::Some(__field11) => __field11,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("headwords")?
                            }
                        };
                        let __field12 = match __field12 {
                            _serde::__private::Some(__field12) => __field12,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("definitions")?
                            }
                        };
                        let __field13 = match __field13 {
                            _serde::__private::Some(__field13) => __field13,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("pronunciations")?
                            }
                        };
                        let __field14 = match __field14 {
                            _serde::__private::Some(__field14) => __field14,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("frequencies")?
                            }
                        };
                        _serde::__private::Ok(InternalTermDictionaryEntry {
                            entry_type: __field0,
                            is_primary: __field1,
                            text_processor_rule_chain_candidates: __field2,
                            inflection_rule_chain_candidates: __field3,
                            score: __field4,
                            frequency_order: __field5,
                            dictionary_alias: __field6,
                            dictionary_index: __field7,
                            source_term_exact_match_count: __field8,
                            match_primary_reading: __field9,
                            max_original_text_length: __field10,
                            headwords: __field11,
                            definitions: __field12,
                            pronunciations: __field13,
                            frequencies: __field14,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "entry_type",
                    "is_primary",
                    "text_processor_rule_chain_candidates",
                    "inflection_rule_chain_candidates",
                    "score",
                    "frequency_order",
                    "dictionary_alias",
                    "dictionary_index",
                    "source_term_exact_match_count",
                    "match_primary_reading",
                    "max_original_text_length",
                    "headwords",
                    "definitions",
                    "pronunciations",
                    "frequencies",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "InternalTermDictionaryEntry",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            InternalTermDictionaryEntry,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    pub struct DatabaseDeinflection {
        pub original_text: String,
        pub transformed_text: String,
        pub deinflected_text: String,
        pub conditions: usize,
        pub text_processor_rule_chain_candidates: Vec<TextProcessorRuleChainCandidate>,
        pub inflection_rule_chain_candidates: Vec<InternalInflectionRuleChainCandidate>,
        pub database_entries: Vec<TermEntry>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for DatabaseDeinflection {
        #[inline]
        fn clone(&self) -> DatabaseDeinflection {
            DatabaseDeinflection {
                original_text: ::core::clone::Clone::clone(&self.original_text),
                transformed_text: ::core::clone::Clone::clone(&self.transformed_text),
                deinflected_text: ::core::clone::Clone::clone(&self.deinflected_text),
                conditions: ::core::clone::Clone::clone(&self.conditions),
                text_processor_rule_chain_candidates: ::core::clone::Clone::clone(
                    &self.text_processor_rule_chain_candidates,
                ),
                inflection_rule_chain_candidates: ::core::clone::Clone::clone(
                    &self.inflection_rule_chain_candidates,
                ),
                database_entries: ::core::clone::Clone::clone(&self.database_entries),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for DatabaseDeinflection {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "original_text",
                "transformed_text",
                "deinflected_text",
                "conditions",
                "text_processor_rule_chain_candidates",
                "inflection_rule_chain_candidates",
                "database_entries",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.original_text,
                &self.transformed_text,
                &self.deinflected_text,
                &self.conditions,
                &self.text_processor_rule_chain_candidates,
                &self.inflection_rule_chain_candidates,
                &&self.database_entries,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "DatabaseDeinflection",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for DatabaseDeinflection {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for DatabaseDeinflection {
        #[inline]
        fn eq(&self, other: &DatabaseDeinflection) -> bool {
            self.original_text == other.original_text
                && self.transformed_text == other.transformed_text
                && self.deinflected_text == other.deinflected_text
                && self.conditions == other.conditions
                && self.text_processor_rule_chain_candidates
                    == other.text_processor_rule_chain_candidates
                && self.inflection_rule_chain_candidates
                    == other.inflection_rule_chain_candidates
                && self.database_entries == other.database_entries
        }
    }
    pub struct DictionaryEntryGroup {
        pub ids: IndexSet<String>,
        pub dictionary_entries: Vec<InternalTermDictionaryEntry>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for DictionaryEntryGroup {
        #[inline]
        fn clone(&self) -> DictionaryEntryGroup {
            DictionaryEntryGroup {
                ids: ::core::clone::Clone::clone(&self.ids),
                dictionary_entries: ::core::clone::Clone::clone(&self.dictionary_entries),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for DictionaryEntryGroup {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "DictionaryEntryGroup",
                "ids",
                &self.ids,
                "dictionary_entries",
                &&self.dictionary_entries,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for DictionaryEntryGroup {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for DictionaryEntryGroup {
        #[inline]
        fn eq(&self, other: &DictionaryEntryGroup) -> bool {
            self.ids == other.ids && self.dictionary_entries == other.dictionary_entries
        }
    }
    pub struct FindInternalTermsResult {
        pub dictionary_entries: Vec<InternalTermDictionaryEntry>,
        pub original_text_length: i128,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for FindInternalTermsResult {
        #[inline]
        fn clone(&self) -> FindInternalTermsResult {
            FindInternalTermsResult {
                dictionary_entries: ::core::clone::Clone::clone(
                    &self.dictionary_entries,
                ),
                original_text_length: ::core::clone::Clone::clone(
                    &self.original_text_length,
                ),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for FindInternalTermsResult {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "FindInternalTermsResult",
                "dictionary_entries",
                &self.dictionary_entries,
                "original_text_length",
                &&self.original_text_length,
            )
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for FindInternalTermsResult {
        #[inline]
        fn default() -> FindInternalTermsResult {
            FindInternalTermsResult {
                dictionary_entries: ::core::default::Default::default(),
                original_text_length: ::core::default::Default::default(),
            }
        }
    }
    pub type TextCache = IndexMap<
        String,
        IndexMap<String, IndexMap<TextProcessorSetting, String>>,
    >;
}
mod translator {
    use crate::{
        backend::FindTermsDetails, collect_variant_data_ref,
        database::{
            self,
            dictionary_database::{
                DatabaseTag, DatabaseTermMeta, DictionaryDatabase, DictionarySet,
                GenericQueryRequest, PhoneticTranscription, PitchAccent, Pronunciation,
                QueryRequestMatchType, QueryType, TermEntry, TermExactQueryRequest,
                TermPronunciationMatchType,
            },
        },
        dictionary::{
            self, DictionaryEntryType, DictionaryTag,
            EntryInflectionRuleChainCandidatesKey, TermDefinition, TermDictionaryEntry,
            TermFrequency, TermHeadword, TermPronunciation, TermSource,
            TermSourceMatchSource, TermSourceMatchType, VecNumOrNum,
        },
        dictionary_data::{
            FrequencyInfo, GenericFreqData, MetaDataMatchType, Pitch, TermGlossary,
            TermGlossaryContent, TermGlossaryDeinflection, TermMetaFreqDataMatchType,
            TermMetaModeType,
        },
        freq, iter_type_to_iter_variant, iter_variant_to_iter_type,
        regex_util::apply_text_replacement,
        settings::{
            DictionaryOptions, GeneralOptions, ProfileOptions, ScanningOptions,
            SearchResolution, SortFrequencyDictionaryOrder, TranslationOptions,
            TranslationTextReplacementGroup, TranslationTextReplacementOptions,
        },
        to_variant,
        translation::{
            FindKanjiDictionary, FindTermDictionary, FindTermDictionaryMap,
            FindTermsMatchType, FindTermsOptions, FindTermsSortOrder,
        },
        translation_internal::{
            DatabaseDeinflection, DictionaryEntryGroup, FindInternalTermsResult,
            InternalTermDictionaryEntry, TextCache, TextProcessorRuleChainCandidate,
            VariantAndTextProcessorRuleChainCandidatesMap,
        },
    };
    use derive_more::From;
    use fancy_regex::Regex;
    use icu::{
        collator::{options::CollatorOptions, Collator, CollatorBorrowed},
        datetime::provider::neo::marker_attrs::PATTERN_MEDIUM, locale::locale,
    };
    use indexmap::{IndexMap, IndexSet};
    use language_transformer::transformer::{
        InflectionRuleChainCandidate, InflectionSource,
        InternalInflectionRuleChainCandidate,
    };
    use language_transformer::{
        descriptors::{PreAndPostProcessors, PreAndPostProcessorsWithId},
        ja::japanese::is_code_point_japanese,
        language_d::{
            AnyTextProcessor, FindTermsTextReplacement, FindTermsTextReplacements,
            LanguageAndProcessors, LanguageAndReadingNormalizer, ReadingNormalizer,
            TextProcessor, TextProcessorFn, TextProcessorSetting, TextProcessorWithId,
        },
        languages::{
            get_all_language_reading_normalizers, get_all_language_text_processors,
        },
        multi_language_transformer::MultiLanguageTransformer,
        transformer::{InflectionRule, LanguageTransformer, TransformedText},
        zh::chinese::is_code_point_chinese,
    };
    use native_db::*;
    use native_model::{native_model, Model};
    use serde::{Deserialize, Serialize};
    use std::{
        cell::RefCell, cmp::Ordering, collections::VecDeque, fmt::Display, hash::Hash,
        iter, mem, ops::Index, path::Path, rc::Rc, str::FromStr, sync::{Arc, LazyLock},
    };
    /// class which finds term and kanji dictionary entries for text.
    pub struct Translator<'a> {
        pub db: Arc<DictionaryDatabase<'a>>,
        pub mlt: MultiLanguageTransformer,
        pub tag_cache: IndexMap<String, TagCache>,
        /// Invariant Locale
        /// Default: "en-US"
        pub string_comparer: CollatorBorrowed<'a>,
        pub number_regex: &'static Regex,
        pub text_processors: TextProcessorMap,
        pub reading_normalizers: ReadingNormalizerMap,
    }
    static TRANSLATOR_NUMBER_REGEX: LazyLock<Regex> = LazyLock::new(|| {
        Regex::new(r"[+-]?(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?").unwrap()
    });
    impl<'a> Translator<'a> {
        pub fn new(db: Arc<DictionaryDatabase<'a>>) -> Self {
            let mut translator = Self::init(db);
            translator.prepare();
            translator
        }
        fn init(db: Arc<DictionaryDatabase<'a>>) -> Self {
            Self {
                db,
                mlt: MultiLanguageTransformer::default(),
                tag_cache: IndexMap::new(),
                string_comparer: Collator::try_new(
                        const {
                            match ::icu_locale_core::Locale::try_from_utf8_with_single_variant_single_keyword_unicode_extension(
                                "en-US".as_bytes(),
                            ) {
                                Ok((language, script, region, variant, keyword)) => {
                                    ::icu_locale_core::Locale {
                                        id: ::icu_locale_core::LanguageIdentifier {
                                            language,
                                            script,
                                            region,
                                            variants: match variant {
                                                Some(v) => {
                                                    ::icu_locale_core::subtags::Variants::from_variant(v)
                                                }
                                                None => ::icu_locale_core::subtags::Variants::new(),
                                            },
                                        },
                                        extensions: match keyword {
                                            Some(k) => {
                                                ::icu_locale_core::extensions::Extensions::from_unicode(::icu_locale_core::extensions::unicode::Unicode {
                                                    keywords: ::icu_locale_core::extensions::unicode::Keywords::new_single(
                                                        k.0,
                                                        ::icu_locale_core::extensions::unicode::Value::from_subtag(
                                                            k.1,
                                                        ),
                                                    ),
                                                    attributes: ::icu_locale_core::extensions::unicode::Attributes::new(),
                                                })
                                            }
                                            None => ::icu_locale_core::extensions::Extensions::new(),
                                        },
                                    }
                                }
                                #[allow(clippy::panic)]
                                _ => {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Invalid language code: en-US . Note the locale! macro only supports up to one variant tag; and one unicode keyword, other extension are not supported. Use runtime parsing instead.",
                                        ),
                                    );
                                }
                            }
                        }
                            .into(),
                        CollatorOptions::default(),
                    )
                    .unwrap(),
                number_regex: &*TRANSLATOR_NUMBER_REGEX,
                text_processors: IndexMap::new(),
                reading_normalizers: IndexMap::new(),
            }
        }
        /// Initializes the instance for use.
        /// The public API should not be used until this function has been called.
        /// fn new() will call it automatically,
        /// if something needs to be done before call .init() -> work -> .prepare();
        fn prepare(&mut self) {
            let language_processors = get_all_language_text_processors();
            for processor in language_processors {
                let LanguageAndProcessors { iso, pre, post } = processor;
                let pre_and_post_processors = PreAndPostProcessorsWithId {
                    pre,
                    post,
                };
                self.text_processors.insert(iso, pre_and_post_processors);
            }
            let reading_normalizers = get_all_language_reading_normalizers();
            for normalizer in reading_normalizers {
                let LanguageAndReadingNormalizer { iso, reading_normalizer } = normalizer;
                self.reading_normalizers.insert(iso, reading_normalizer);
            }
        }
        /// Clears the database tag cache.
        /// This should be called if the database is changed.
        fn clear_dbtag_caches(&mut self) {
            self.tag_cache.clear();
        }
        /// Finds term definitions for the given text.
        ///
        /// This function operates asynchronously.
        ///
        /// # Parameters
        ///
        /// `mode`: The [FindTermsMode] determines the format of the resulting array.
        /// Must be one of: `Group`, `Merge`, `Split`, or `Simple`.
        ///
        ///  `text`: The `&str` text to find terms for.
        ///
        ///  `options`: A reference to `FindTermsOptions`, a struct describing settings
        ///   for the lookup.
        ///
        /// # Returns
        ///
        /// A `Result` which, upon success, yields a struct containing:
        ///  `dictionary_entries`: A `Vec<TermDictionaryEntry>` with the found terms.
        ///  `original_text_length`: The `usize` length of the original source text.
        ///
        /// # Errors
        ///
        /// Returns an error if the term lookup process fails for any reason.
        pub fn find_terms(
            &mut self,
            mode: FindTermsMode,
            text: &str,
            opts: &FindTermsOptions,
        ) -> FindTermsResult {
            let mut text = text.to_string();
            let FindTermsOptions {
                enabled_dictionary_map,
                exclude_dictionary_definitions,
                sort_frequency_dictionary,
                sort_frequency_dictionary_order,
                language,
                primary_reading,
                ..
            } = opts;
            let mut tag_aggregator = TranslatorTagAggregator::default();
            let FindInternalTermsResult {
                mut dictionary_entries,
                original_text_length,
            } = self
                .find_terms_internal(
                    &mut text,
                    opts,
                    &mut tag_aggregator,
                    primary_reading,
                );
            match mode {
                FindTermsMode::Group => {
                    dictionary_entries = self
                        ._group_dictionary_entries_by_headword(
                            language,
                            &dictionary_entries,
                            &mut tag_aggregator,
                            primary_reading,
                        );
                }
                FindTermsMode::Merge => {
                    dictionary_entries = self
                        ._get_related_dictionary_entries(
                            &dictionary_entries,
                            opts,
                            &mut tag_aggregator,
                        );
                }
                _ => {}
            }
            if let Some(exclude_dictionary_definitions) = exclude_dictionary_definitions {
                Translator::_remove_excluded_definitions(
                    &mut dictionary_entries,
                    exclude_dictionary_definitions,
                );
            }
            match mode != FindTermsMode::Simple {
                true => {
                    self._add_term_meta(
                        &mut dictionary_entries,
                        enabled_dictionary_map,
                        &mut tag_aggregator,
                    );
                    self._expand_tag_groups_and_group(
                        &mut tag_aggregator.get_tag_expansion_targets(),
                    );
                }
                false => {
                    if let Some(sort_frequency_dictionary) = sort_frequency_dictionary {
                        let mut sort_dictionary_map: TermEnabledDictionaryMap = IndexMap::new();
                        let value = enabled_dictionary_map
                            .get(sort_frequency_dictionary);
                        if let Some(value) = value {
                            sort_dictionary_map
                                .insert(sort_frequency_dictionary.clone(), value.clone());
                        }
                        self._add_term_meta(
                            &mut dictionary_entries,
                            &sort_dictionary_map,
                            &mut tag_aggregator,
                        );
                    }
                }
            }
            if let Some(sort_frequency_dictionary) = sort_frequency_dictionary {
                Translator::_update_sort_frequencies(
                    &mut dictionary_entries,
                    sort_frequency_dictionary,
                    *sort_frequency_dictionary_order == FindTermsSortOrder::Ascending,
                );
            }
            if dictionary_entries.len() > 1 {
                self._sort_term_dictionary_entries(&mut dictionary_entries);
            }
            dictionary_entries
                .iter_mut()
                .for_each(|mut entry| {
                    let definitions = &mut entry.definitions;
                    Translator::_flag_redundant_definition_tags(definitions);
                    if definitions.len() > 1 {
                        Translator::_sort_term_dictionary_entry_definitions_mut(
                            definitions,
                        );
                    }
                    if entry.frequencies.len() > 1 {
                        let mut sorted_frequencies_as_term_type: Vec<TermType> = entry
                            .frequencies
                            .iter()
                            .map(|f| f.clone().into())
                            .collect();
                        Translator::_sort_term_dictionary_entry_simple_data_mut(
                            &mut sorted_frequencies_as_term_type,
                        );
                        entry.frequencies = sorted_frequencies_as_term_type
                            .into_iter()
                            .map(|tt| tt.try_into().unwrap())
                            .collect();
                    }
                    if entry.pronunciations.len() > 1 {
                        let mut sorted_pronunciations_as_term_type: Vec<TermType> = entry
                            .pronunciations
                            .iter()
                            .map(|p| p.clone().into())
                            .collect();
                        Translator::_sort_term_dictionary_entry_simple_data_mut(
                            &mut sorted_pronunciations_as_term_type,
                        );
                        entry.pronunciations = sorted_pronunciations_as_term_type
                            .into_iter()
                            .map(|tt| tt.try_into().unwrap())
                            .collect();
                    }
                });
            let with_user_facing_inflections = self
                ._add_user_facing_inflections(language, dictionary_entries);
            FindTermsResult {
                dictionary_entries: with_user_facing_inflections,
                original_text_length,
            }
        }
        /// Creates an options object for use with `Translator.findTerms`.
        pub fn _get_translator_find_terms_options(
            mode: FindTermsMode,
            details: &FindTermsDetails,
            opts: &ProfileOptions,
        ) -> FindTermsOptions {
            let FindTermsDetails {
                mut match_type,
                mut deinflect,
                mut primary_reading,
            } = details.clone();
            if match_type.is_none() {
                match_type = Some(FindTermsMatchType::Exact);
            }
            if deinflect.is_none() {
                deinflect = Some(true);
            }
            if primary_reading.is_none() {
                primary_reading = Some("".to_string());
            }
            let mut enabled_dictionary_map = Self::_get_translator_enabled_dictionary_map(
                opts,
            );
            let ProfileOptions {
                general: GeneralOptions {
                    main_dictionary,
                    sort_frequency_dictionary,
                    sort_frequency_dictionary_order,
                    language,
                    ..
                },
                scanning: ScanningOptions { alphanumeric, .. },
                translation: TranslationOptions {
                    text_replacements: text_replacements_opts,
                    search_resolution,
                    ..
                },
                ..
            } = opts;
            let text_replacements = Self::_get_translator_text_replacements(
                text_replacements_opts,
            );
            let mut exclude_dictionary_definitions: Option<IndexSet<String>> = None;
            if mode == FindTermsMode::Merge
                && !enabled_dictionary_map.contains_key(main_dictionary)
            {
                let new = FindTermDictionary {
                    index: enabled_dictionary_map.len(),
                    alias: main_dictionary.to_string(),
                    allow_secondary_searches: false,
                    parts_of_speech_filter: true,
                    use_deinflections: true,
                };
                enabled_dictionary_map.insert(main_dictionary.clone(), new);
                exclude_dictionary_definitions = Some(IndexSet::new());
                exclude_dictionary_definitions
                    .as_mut()
                    .unwrap()
                    .insert(main_dictionary.clone());
            }
            FindTermsOptions {
                match_type: match_type.unwrap(),
                deinflect: deinflect.unwrap(),
                primary_reading: primary_reading.unwrap(),
                main_dictionary: main_dictionary.to_string(),
                sort_frequency_dictionary: sort_frequency_dictionary.clone(),
                sort_frequency_dictionary_order: *sort_frequency_dictionary_order,
                remove_non_japanese_characters: !*alphanumeric,
                text_replacements: text_replacements.clone().into(),
                enabled_dictionary_map,
                exclude_dictionary_definitions: exclude_dictionary_definitions.clone(),
                search_resolution: *search_resolution,
                language: language.to_string(),
            }
        }
        fn _get_translator_enabled_dictionary_map(
            opts: &ProfileOptions,
        ) -> TermEnabledDictionaryMap {
            let mut enabled_dictionary_map: TermEnabledDictionaryMap = IndexMap::new();
            for (key, dictionary) in &opts.dictionaries {
                if !dictionary.enabled {
                    continue;
                }
                let DictionaryOptions {
                    name,
                    alias,
                    allow_secondary_searches,
                    definitions_collapsible,
                    parts_of_speech_filter,
                    use_deinflections,
                    styles,
                    ..
                } = dictionary;
                let new = FindTermDictionary {
                    index: enabled_dictionary_map.len(),
                    alias: alias.clone(),
                    allow_secondary_searches: *allow_secondary_searches,
                    parts_of_speech_filter: *parts_of_speech_filter,
                    use_deinflections: *use_deinflections,
                };
                enabled_dictionary_map.insert(name.clone(), new);
            }
            enabled_dictionary_map
        }
        fn _get_translator_text_replacements(
            text_replacements_options: &TranslationTextReplacementOptions,
        ) -> VecDeque<Option<Vec<FindTermsTextReplacement>>> {
            let mut text_replacements = VecDeque::new();
            for group in &text_replacements_options.groups {
                let mut text_replacement_entries: Vec<FindTermsTextReplacement> = ::alloc::vec::Vec::new();
                for TranslationTextReplacementGroup {
                    pattern,
                    ignore_case,
                    replacement,
                    ..
                } in group {
                    let re_pattern = if *ignore_case {
                        ::alloc::__export::must_use({
                            let res = ::alloc::fmt::format(
                                format_args!("(?i){0}", pattern),
                            );
                            res
                        })
                    } else {
                        pattern.to_string()
                    };
                    let Ok(pattern_regex) = Regex::new(&re_pattern) else {
                        continue;
                    };
                    let new = FindTermsTextReplacement {
                        pattern: pattern_regex,
                        replacement: replacement.to_string(),
                        is_global: true,
                    };
                    text_replacement_entries.push(new);
                }
                if !text_replacement_entries.is_empty() {
                    text_replacements.push_back(Some(text_replacement_entries));
                }
            }
            if !text_replacements.is_empty() || text_replacements_options.search_original
            {
                text_replacements.push_front(None);
            }
            text_replacements
        }
        fn _add_user_facing_inflections(
            &self,
            language: &str,
            dictionary_entries: Vec<InternalTermDictionaryEntry>,
        ) -> Vec<TermDictionaryEntry> {
            let mut result: Vec<TermDictionaryEntry> = Vec::with_capacity(
                dictionary_entries.len(),
            );
            for dictionary_entry in dictionary_entries {
                let expanded_chains: Vec<InflectionRuleChainCandidate> = dictionary_entry
                    .inflection_rule_chain_candidates
                    .iter()
                    .map(|original_candidate| {
                        let inflection_rules = &original_candidate.inflection_rules;
                        let new_rules = self
                            .mlt
                            .get_user_facing_inflection_rules(
                                language,
                                inflection_rules,
                            );
                        InflectionRuleChainCandidate {
                            source: original_candidate.source,
                            inflection_rules: new_rules,
                        }
                    })
                    .collect();
                let InternalTermDictionaryEntry {
                    entry_type,
                    is_primary,
                    text_processor_rule_chain_candidates,
                    inflection_rule_chain_candidates,
                    score,
                    frequency_order,
                    dictionary_alias,
                    dictionary_index,
                    source_term_exact_match_count,
                    match_primary_reading,
                    max_original_text_length,
                    headwords,
                    definitions,
                    pronunciations,
                    frequencies,
                } = dictionary_entry;
                let mut new_entry = TermDictionaryEntry {
                    entry_type,
                    is_primary,
                    text_processor_rule_chain_candidates,
                    inflection_rule_chain_candidates: expanded_chains,
                    score,
                    frequency_order,
                    dictionary_alias,
                    dictionary_index,
                    source_term_exact_match_count,
                    match_primary_reading,
                    max_original_text_length,
                    headwords,
                    definitions,
                    pronunciations,
                    frequencies,
                };
                result.push(new_entry);
            }
            result
        }
        /// Sorts a slice of items implementing `IsTermType` in place.
        ///
        /// This function is intended for lists containing only
        /// [TermFrequency] or [TermPronunciation]
        /// variants of `TermType`
        /// (or other types that correctly implement `IsTermType` for these fields).
        ///
        /// Sorting criteria (all ascending):
        /// 1. `ipa_or_freq_headword_index`
        /// 2. `dictionary_index`
        /// 3. `index`
        pub fn _sort_term_dictionary_entry_simple_data_mut(
            data_list: &mut [impl IsTermType],
        ) {
            data_list
                .sort_by(|v1, v2| {
                    v1._get_ipa_or_freq_headword_index()
                        .cmp(&v2._get_ipa_or_freq_headword_index())
                        .then_with(|| v1.dictionary_index().cmp(&v2.dictionary_index()))
                        .then_with(|| v1.index().cmp(&v2.index()))
                });
        }
        /// Sorts a slice of `TermDefinition` structs in place.
        ///
        /// The sorting criteria are applied in the following order:
        /// 1. `frequency_order` (ascending).
        /// 2. `dictionary_index` (ascending).
        /// 3. `score` (descending).
        /// 4. `headword_indices`:
        ///    a. Length of `headword_indices` (descending).
        ///    b. Element-wise values of `headword_indices` (ascending), if lengths are equal.
        /// 5. Original `index` (ascending) as a final tie-breaker.
        fn _sort_term_dictionary_entry_definitions_mut(
            definitions: &mut [TermDefinition],
        ) {
            definitions
                .sort_by(|v1, v2| {
                    v1.frequency_order
                        .cmp(&v2.frequency_order)
                        .then_with(|| v1.dictionary_index.cmp(&v2.dictionary_index))
                        .then_with(|| v2.score.cmp(&v1.score))
                        .then_with(|| {
                            v2.headword_indices
                                .len()
                                .cmp(&v1.headword_indices.len())
                                .then_with(|| v1.headword_indices.cmp(&v2.headword_indices))
                        })
                        .then_with(|| v1.index.cmp(&v2.index))
                });
        }
        fn _flag_redundant_definition_tags(definitions: &mut Vec<TermDefinition>) {
            if definitions.is_empty() {
                return;
            }
            let mut last_dictionary = None;
            let mut last_part_of_speech = "".to_string();
            let mut remove_categories_set: IndexSet<String> = IndexSet::new();
            for TermDefinition { dictionary, tags, .. } in definitions {
                let tag_names_with_category = Translator::_get_tag_names_with_category(
                    tags,
                    "partOfSpeech",
                );
                let part_of_speech = Translator::_create_map_key(
                    &tag_names_with_category,
                );
                if last_dictionary.as_ref().is_some_and(|ld| *ld != dictionary) {
                    last_dictionary = Some(dictionary);
                    last_part_of_speech = "".into();
                }
                if last_part_of_speech == part_of_speech {
                    remove_categories_set.insert("partOfSpeech".into());
                } else {
                    last_part_of_speech = part_of_speech;
                }
                if !remove_categories_set.is_empty() {
                    tags.iter_mut()
                        .for_each(|tag| {
                            if remove_categories_set.contains(&tag.category) {
                                tag.redundant = true;
                            }
                        });
                }
            }
        }
        fn _get_tag_names_with_category(
            tags: &[DictionaryTag],
            category: &str,
        ) -> Vec<String> {
            let mut res = tags
                .iter()
                .filter_map(|tag| {
                    if tag.category != category {
                        return None;
                    }
                    Some(tag.name.clone())
                })
                .collect::<Vec<String>>();
            res.sort();
            res
        }
        fn _sort_term_dictionary_entries(
            &self,
            dictionary_entries: &mut [InternalTermDictionaryEntry],
        ) {
            let string_comparer = &self.string_comparer;
            dictionary_entries
                .sort_by(|v1, v2| {
                    let cmp = v2.match_primary_reading.cmp(&v1.match_primary_reading);
                    if cmp != Ordering::Equal {
                        return cmp;
                    }
                    let cmp = v2
                        .max_original_text_length
                        .cmp(&v1.max_original_text_length);
                    if cmp != Ordering::Equal {
                        return cmp;
                    }
                    let len1 = self
                        ._get_shortest_text_processing_chain_length(
                            &v1.text_processor_rule_chain_candidates,
                        );
                    let len2 = self
                        ._get_shortest_text_processing_chain_length(
                            &v2.text_processor_rule_chain_candidates,
                        );
                    let cmp = len1.cmp(&len2);
                    if cmp != Ordering::Equal {
                        return cmp;
                    }
                    let len1 = self
                        ._get_shortest_inflection_chain_length(
                            &v1.inflection_rule_chain_candidates,
                        );
                    let len2 = self
                        ._get_shortest_inflection_chain_length(
                            &v2.inflection_rule_chain_candidates,
                        );
                    let cmp = len1.cmp(&len2);
                    if cmp != Ordering::Equal {
                        return cmp;
                    }
                    let cmp = v2
                        .source_term_exact_match_count
                        .cmp(&v1.source_term_exact_match_count);
                    if cmp != Ordering::Equal {
                        return cmp;
                    }
                    let cmp = v1.frequency_order.cmp(&v2.frequency_order);
                    if cmp != Ordering::Equal {
                        return cmp;
                    }
                    let cmp = v1.dictionary_index.cmp(&v2.dictionary_index);
                    if cmp != Ordering::Equal {
                        return cmp;
                    }
                    let cmp = v2.score.cmp(&v1.score);
                    if cmp != Ordering::Equal {
                        return cmp;
                    }
                    let headwords1 = &v1.headwords;
                    let headwords2 = &v2.headwords;
                    let min_len = headwords1.len().min(headwords2.len());
                    for j in 0..min_len {
                        let term1 = &headwords1[j].term;
                        let term2 = &headwords2[j].term;
                        let cmp_len = term2.len().cmp(&term1.len());
                        if cmp_len != Ordering::Equal {
                            return cmp_len;
                        }
                        let cmp_str = string_comparer.compare(term1, term2);
                        if cmp_str != Ordering::Equal {
                            return cmp_str;
                        }
                    }
                    v2.definitions.len().cmp(&v1.definitions.len())
                });
        }
        fn _get_shortest_text_processing_chain_length(
            &self,
            candidates: &[TextProcessorRuleChainCandidate],
        ) -> usize {
            candidates.iter().map(|chain| chain.len()).min().unwrap_or(0)
        }
        fn _get_shortest_inflection_chain_length(
            &self,
            candidates: &[InternalInflectionRuleChainCandidate],
        ) -> usize {
            candidates
                .iter()
                .map(|candidate| candidate.inflection_rules.len())
                .min()
                .unwrap_or(0)
        }
        fn _update_sort_frequencies(
            dictionary_entries: &mut [InternalTermDictionaryEntry],
            dictionary: &str,
            ascending: bool,
        ) {
            let mut frequency_map: IndexMap<usize, i128> = IndexMap::new();
            for entry in dictionary_entries.iter_mut() {
                let mut frequency_min = i128::MAX;
                let mut frequency_max = i128::MIN;
                for freq in &entry.frequencies {
                    if freq.dictionary != dictionary {
                        continue;
                    }
                    frequency_map.insert(freq.headword_index, freq.frequency);
                    frequency_min = frequency_min.min(freq.frequency);
                    frequency_max = frequency_max.max(freq.frequency);
                }
                entry.frequency_order = match frequency_min <= frequency_max {
                    true => {
                        match ascending {
                            true => frequency_min,
                            false => -frequency_max,
                        }
                    }
                    false => {
                        match ascending {
                            true => i128::MAX,
                            false => 0,
                        }
                    }
                };
                for def in entry.definitions.iter_mut() {
                    frequency_min = i128::MAX;
                    frequency_max = i128::MIN;
                    for headword_index in &def.headword_indices {
                        if let Some(frequency) = frequency_map.get(headword_index) {
                            frequency_min = frequency_min.min(*frequency);
                            frequency_max = frequency_max.max(*frequency);
                        }
                    }
                    def.frequency_order = match frequency_min <= frequency_max {
                        true => {
                            match ascending {
                                true => frequency_min,
                                false => -frequency_max,
                            }
                        }
                        false => {
                            match ascending {
                                true => i128::MAX,
                                false => 0,
                            }
                        }
                    };
                }
                frequency_map.clear();
            }
        }
        fn _expand_tag_groups_and_group(
            &mut self,
            tag_expansion_targets: &mut [TagExpansionTarget],
        ) {
            self._expand_tag_groups_mut(tag_expansion_targets);
            self._group_tags_mut(tag_expansion_targets);
        }
        fn _group_tags_mut(&self, tag_targets: &mut [TagExpansionTarget]) {
            let string_comparer: &CollatorBorrowed<'a> = &self.string_comparer;
            for tag_expansion_target in tag_targets.iter_mut() {
                if tag_expansion_target.tags.len() <= 1 {
                    continue;
                }
                Translator::_merge_similar_tags_mut(&mut tag_expansion_target.tags);
                tag_expansion_target
                    .tags
                    .sort_by(|v1, v2| match v1.order.cmp(&v2.order) {
                        Ordering::Equal => string_comparer.compare(&v1.name, &v2.name),
                        non_eq => non_eq,
                    });
            }
        }
        /// Merges similar tags within the given vector.
        /// Tags are considered similar if they have the same `name` and `category`.
        /// When merged, the first tag encountered (tag1) is updated:
        /// - `order` becomes the minimum of the two.
        /// - `score` becomes the maximum of the two.
        /// - `dictionaries` are combined.
        /// - `content` is combined uniquely using `_add_unique_simple`.
        ///   The second tag (tag2) is removed from the vector.
        pub fn _merge_similar_tags_mut(tags: &mut Vec<DictionaryTag>) {
            if tags.is_empty() {
                return;
            }
            let mut i = 0;
            while i < tags.len() {
                let mut j = i + 1;
                while j < tags.len() {
                    if tags[j].name == tags[i].name
                        && tags[j].category == tags[i].category
                    {
                        let tag2_order = tags[j].order;
                        let tag2_score = tags[j].score;
                        tags[i].order = std::cmp::min(tags[i].order, tag2_order);
                        tags[i].score = tags[i].score.max(tag2_score);
                        let removed_tag = tags.remove(j);
                        tags[i].dictionaries.extend(removed_tag.dictionaries);
                        Translator::_add_unique_simple(
                            &mut tags[i].content,
                            &removed_tag.content,
                        );
                    } else {
                        j += 1;
                    }
                }
                i += 1;
            }
        }
        fn _expand_tag_groups_mut(&mut self, tag_targets: &mut [TagExpansionTarget]) {
            let mut target_map: IndexMap<String, IndexMap<String, TagTargetItem>> = IndexMap::new();
            for target in tag_targets.iter() {
                let TagExpansionTarget { tags: _, tag_groups } = target;
                for group in tag_groups {
                    let TagGroup { dictionary, tag_names } = group;
                    let dictionary_items = target_map
                        .entry(dictionary.clone())
                        .or_default();
                    for tag_name in tag_names {
                        dictionary_items
                            .entry(tag_name.clone())
                            .or_insert_with(|| {
                                let query = Translator::_get_base_name(tag_name);
                                TagTargetItem {
                                    query,
                                    dictionary: dictionary.clone(),
                                    tag_name: tag_name.clone(),
                                    database_tag: None,
                                    targets: ::alloc::vec::Vec::new(),
                                    cache: None,
                                }
                            });
                    }
                }
            }
            let mut non_cached_items_refs: Vec<&mut TagTargetItem> = Vec::new();
            let tag_cache_ref = &mut self.tag_cache;
            for (dictionary_name, dictionary_items) in target_map.iter_mut() {
                let cache_for_dict = tag_cache_ref
                    .entry(dictionary_name.clone())
                    .or_default();
                for item in dictionary_items.values_mut() {
                    let database_tag_from_cache = cache_for_dict
                        .get(item.query.as_str());
                    match database_tag_from_cache {
                        Some(database_tag) => {
                            item.database_tag = database_tag.to_owned();
                        }
                        None => {
                            non_cached_items_refs.push(item);
                        }
                    }
                }
            }
            if !non_cached_items_refs.is_empty() {
                let non_cached_queries: Vec<GenericQueryRequest> = non_cached_items_refs
                    .iter()
                    .map(|item_ref| (&**item_ref).into())
                    .collect();
                let database_tags = self
                    .db
                    .find_tag_meta_bulk(&non_cached_queries)
                    .unwrap_or_else(|e| {
                        {
                            ::std::io::_eprint(
                                format_args!(
                                    "`find_tag_meta_bulk` threw an error in Translator::_expand_tag_groups\nreason: {0}\n",
                                    e,
                                ),
                            );
                        };
                        ::alloc::vec::Vec::new()
                    });
                for (item_ref, database_tag_option) in non_cached_items_refs
                    .into_iter()
                    .zip(database_tags.into_iter())
                {
                    item_ref.database_tag = database_tag_option.clone();
                    if let Some(cache) = tag_cache_ref.get_mut(&item_ref.dictionary) {
                        /// if the cache exists, you can directly use the Option<DatabaseTag>
                        /// as cache: &mut IndexMap<String, Option<DatabaseTag>> already.
                        cache.insert(item_ref.query.clone(), database_tag_option);
                    }
                }
            }
            for target in tag_targets {
                let TagExpansionTarget { tags, tag_groups } = target;
                for group in tag_groups {
                    let TagGroup { dictionary, tag_names } = group;
                    if let Some(dictionary_items) = target_map.get(dictionary) {
                        for tag_name in tag_names {
                            if let Some(item) = dictionary_items.get(tag_name) {
                                tags.push(
                                    Translator::_create_dictionary_tag(
                                        item.database_tag.clone(),
                                        tag_name.clone(),
                                        dictionary.clone(),
                                    ),
                                );
                            }
                        }
                    }
                }
            }
        }
        /// this is called _create_tag() in js
        fn _create_dictionary_tag(
            database_tag: Option<DatabaseTag>,
            name: String,
            dictionary: String,
        ) -> DictionaryTag {
            let Some(database_tag) = database_tag else {
                return DictionaryTag::new_default(name, dictionary);
            };
            let DatabaseTag { category, order, notes, score, .. } = database_tag;
            let category = match !category.is_empty() {
                true => category,
                false => String::from("default"),
            };
            let content = match !notes.is_empty() {
                true => <[_]>::into_vec(::alloc::boxed::box_new([notes])),
                false => ::alloc::vec::Vec::new(),
            };
            DictionaryTag {
                name,
                category,
                order: order as usize,
                score: score as usize,
                content,
                dictionaries: <[_]>::into_vec(::alloc::boxed::box_new([dictionary])),
                redundant: false,
            }
        }
        fn _get_base_name(name: &str) -> String {
            let Some(pos) = name.find(':') else {
                return name.to_string();
            };
            name[..pos].to_string()
        }
        fn _add_term_meta(
            &self,
            dictionary_entries: &mut [InternalTermDictionaryEntry],
            enabled_dictionary_map: &TermEnabledDictionaryMap,
            tag_aggregator: &mut TranslatorTagAggregator,
        ) {
            let mut headword_map: IndexMap<
                String,
                IndexMap<String, Vec<TermMetaHeadword>>,
            > = IndexMap::new();
            let mut headword_map_keys: IndexSet<String> = IndexSet::new();
            let mut headword_reading_maps: Vec<
                IndexMap<String, Vec<TermMetaHeadword>>,
            > = Vec::new();
            for (entry_idx, dictionary_entry) in dictionary_entries.iter().enumerate() {
                let current_pronunciations = &dictionary_entry.pronunciations;
                let current_frequencies = &dictionary_entry.frequencies;
                for (i, headword) in dictionary_entry.headwords.iter().enumerate() {
                    let term = &headword.term;
                    let reading = &headword.reading;
                    let reading_map_for_term = headword_map
                        .entry(term.clone())
                        .or_insert_with(|| {
                            headword_map_keys.insert(term.clone());
                            IndexMap::new()
                        });
                    let targets_for_reading = reading_map_for_term
                        .entry(reading.clone())
                        .or_default();
                    targets_for_reading
                        .push(TermMetaHeadword {
                            original_index: entry_idx,
                            headword_index: i,
                            pronunciations: current_pronunciations.clone(),
                            frequencies: current_frequencies.clone(),
                        });
                }
            }
            for key in &headword_map_keys {
                if let Some(inner_map) = headword_map.get(key) {
                    headword_reading_maps.push(inner_map.clone());
                } else {
                    headword_reading_maps.push(IndexMap::new());
                }
            }
            if headword_map_keys.is_empty() {
                return;
            }
            let metas_result = self
                .db
                .find_term_meta_bulk(&headword_map_keys, enabled_dictionary_map);
            let metas = match metas_result {
                Ok(m) => m,
                Err(e) => {
                    {
                        ::std::io::_eprint(
                            format_args!("Failed to find term meta bulk: {0}\n", e),
                        );
                    };
                    return;
                }
            };
            for meta_entry in metas {
                let DatabaseTermMeta { index, mode, data, dictionary, .. } = meta_entry;
                let dictionary_index_val = Translator::_get_dictionary_order(
                    &dictionary,
                    &EnabledDictionaryMapType::Term(enabled_dictionary_map),
                );
                let dictionary_alias_val = Translator::_get_dictionary_alias(
                    dictionary.clone(),
                    &EnabledDictionaryMapType::Term(enabled_dictionary_map),
                );
                /// --- OLD CODE ---
                if index >= headword_reading_maps.len() {
                    {
                        ::std::io::_eprint(
                            format_args!(
                                "Meta index {0} out of bounds for headword_reading_maps (len {1})\n",
                                index,
                                headword_reading_maps.len(),
                            ),
                        );
                    };
                    continue;
                }
                let map2 = &headword_reading_maps[index];
                /// --- END OLD CODE ---
                for (reading_key_str, targets_vec) in map2.iter() {
                    match &data {
                        MetaDataMatchType::Frequency(ref freq_match_type) => {
                            if mode != TermMetaModeType::Freq {
                                continue;
                            }
                            let mut has_reading_filter = false;
                            let frequency_data_value = match freq_match_type {
                                TermMetaFreqDataMatchType::WithReading(
                                    data_with_reading,
                                ) => {
                                    if &data_with_reading.reading != reading_key_str {
                                        continue;
                                    }
                                    has_reading_filter = true;
                                    data_with_reading.frequency.clone()
                                }
                                TermMetaFreqDataMatchType::Generic(generic_data) => {
                                    generic_data.clone()
                                }
                            };
                            let freq_info = Translator::_get_frequency_info(
                                frequency_data_value.clone(),
                            );
                            let frequency_value_to_store = freq_info.frequency;
                            let display_value_str = freq_info.display_value;
                            let display_value_parsed_bool = freq_info
                                .display_value_parsed;
                            for target_meta_headword in targets_vec.iter() {
                                let dict_entry_to_update = &mut dictionary_entries[target_meta_headword
                                    .original_index];
                                let new_term_freq = Translator::_create_term_frequency_(
                                    dict_entry_to_update.frequencies.len(),
                                    target_meta_headword.headword_index,
                                    dictionary.clone(),
                                    dictionary_index_val,
                                    dictionary_alias_val.clone(),
                                    has_reading_filter,
                                    frequency_value_to_store,
                                    display_value_str.clone(),
                                    display_value_parsed_bool,
                                );
                                dict_entry_to_update.frequencies.push(new_term_freq);
                            }
                        }
                        MetaDataMatchType::Pitch(ref pitch_meta_data) => {
                            if mode != TermMetaModeType::Pitch {
                                continue;
                            }
                            if &pitch_meta_data.reading != reading_key_str {
                                continue;
                            }
                            let mut pitches_to_add: Vec<Pronunciation> = Vec::new();
                            for pitch_item_data in &pitch_meta_data.pitches {
                                let mut resolved_tags: Vec<DictionaryTag> = Vec::new();
                                if let Some(tags_from_data) = &pitch_item_data.tags {
                                    tag_aggregator
                                        .add_tags(&resolved_tags, &dictionary, tags_from_data);
                                }
                                let nasal_positions_vec = Translator::_vec_num_or_num_to_vec_u8(
                                    pitch_item_data.nasal.as_ref(),
                                );
                                let devoice_positions_vec = Translator::_vec_num_or_num_to_vec_u8(
                                    pitch_item_data.devoice.as_ref(),
                                );
                                pitches_to_add
                                    .push(
                                        Pronunciation::PitchAccent(PitchAccent {
                                            term: TermPronunciationMatchType::PitchAccent,
                                            position: pitch_item_data.position,
                                            nasal_positions: nasal_positions_vec,
                                            devoice_positions: devoice_positions_vec,
                                            tags: resolved_tags,
                                        }),
                                    );
                            }
                            if pitches_to_add.is_empty() {
                                continue;
                            }
                            for target_meta_headword in targets_vec.iter() {
                                let dict_entry_to_update = &mut dictionary_entries[target_meta_headword
                                    .original_index];
                                let new_term_pron = Translator::_create_term_pronunciation(
                                    dict_entry_to_update.pronunciations.len(),
                                    target_meta_headword.headword_index,
                                    dictionary.clone(),
                                    dictionary_index_val,
                                    dictionary_alias_val.clone(),
                                    pitches_to_add.clone(),
                                );
                                dict_entry_to_update.pronunciations.push(new_term_pron);
                            }
                        }
                        MetaDataMatchType::Phonetic(ref phonetic_meta_data) => {
                            if mode != TermMetaModeType::Ipa {
                                continue;
                            }
                            if &phonetic_meta_data.reading != reading_key_str {
                                continue;
                            }
                            let mut phonetic_transcriptions_to_add: Vec<Pronunciation> = Vec::new();
                            for transcription_item in &phonetic_meta_data.transcriptions
                            {
                                let mut resolved_ipa_tags: Vec<DictionaryTag> = Vec::new();
                                let tag_names_for_aggregator: Vec<String> = transcription_item
                                    .tags
                                    .iter()
                                    .map(|tag| tag.name.clone())
                                    .collect();
                                if !tag_names_for_aggregator.is_empty() {
                                    tag_aggregator
                                        .add_tags(
                                            &resolved_ipa_tags,
                                            &dictionary,
                                            &tag_names_for_aggregator,
                                        );
                                }
                                phonetic_transcriptions_to_add
                                    .push(
                                        Pronunciation::PhoneticTranscription(PhoneticTranscription {
                                            match_type: TermPronunciationMatchType::PhoneticTranscription,
                                            ipa: transcription_item.ipa.clone(),
                                            tags: resolved_ipa_tags,
                                        }),
                                    );
                            }
                            if phonetic_transcriptions_to_add.is_empty() {
                                continue;
                            }
                            for target_meta_headword in targets_vec.iter() {
                                let dict_entry_to_update = &mut dictionary_entries[target_meta_headword
                                    .original_index];
                                let new_term_pron = Translator::_create_term_pronunciation(
                                    dict_entry_to_update.pronunciations.len(),
                                    target_meta_headword.headword_index,
                                    dictionary.clone(),
                                    dictionary_index_val,
                                    dictionary_alias_val.clone(),
                                    phonetic_transcriptions_to_add.clone(),
                                );
                                dict_entry_to_update.pronunciations.push(new_term_pron);
                            }
                        }
                    }
                }
            }
        }
        fn _vec_num_or_num_to_vec_u8(opt_vnon: Option<&VecNumOrNum>) -> Vec<u8> {
            match opt_vnon {
                Some(VecNumOrNum::Vec(vec)) => vec.clone(),
                Some(VecNumOrNum::Num(num)) => {
                    <[_]>::into_vec(::alloc::boxed::box_new([*num]))
                }
                None => Vec::new(),
            }
        }
        fn _create_term_frequency_(
            index: usize,
            headword_index: usize,
            dictionary: String,
            dictionary_index: usize,
            dictionary_alias: String,
            has_reading: bool,
            frequency: i128,
            display_value: Option<String>,
            display_value_parsed: bool,
        ) -> TermFrequency {
            TermFrequency {
                index,
                headword_index,
                dictionary,
                dictionary_index,
                dictionary_alias,
                has_reading,
                frequency,
                display_value,
                display_value_parsed,
            }
        }
        fn _create_term_pronunciation(
            index: usize,
            headword_index: usize,
            dictionary: String,
            dictionary_index: usize,
            dictionary_alias: String,
            pronunciations: Vec<Pronunciation>,
        ) -> TermPronunciation {
            TermPronunciation {
                index,
                headword_index,
                dictionary,
                dictionary_index,
                dictionary_alias,
                pronunciations,
            }
        }
        fn _get_frequency_info(frequency_data: GenericFreqData) -> FrequencyInfo {
            match frequency_data {
                GenericFreqData::Object(obj) => {
                    FrequencyInfo {
                        frequency: obj.value,
                        display_value: obj.display_value,
                        display_value_parsed: false,
                    }
                }
                GenericFreqData::Integer(num) => {
                    FrequencyInfo {
                        frequency: num,
                        display_value: None,
                        display_value_parsed: false,
                    }
                }
                GenericFreqData::String(s_val) => {
                    let numeric_value = Translator::_convert_string_to_number(&s_val);
                    FrequencyInfo {
                        frequency: numeric_value,
                        display_value: Some(s_val),
                        display_value_parsed: true,
                    }
                }
            }
        }
        fn _convert_string_to_number(s: &str) -> i128 {
            s.parse::<i128>().unwrap_or(-1)
        }
        fn find_terms_internal(
            &self,
            text: &mut String,
            opts: &FindTermsOptions,
            tag_aggregator: &mut TranslatorTagAggregator,
            primary_reading: &str,
        ) -> FindInternalTermsResult {
            let FindTermsOptions {
                remove_non_japanese_characters,
                enabled_dictionary_map,
                ..
            } = opts;
            if *remove_non_japanese_characters
                && ["ja", "zh", "yue"].contains(&opts.language.as_str())
            {
                *text = Translator::get_japanese_chinese_only_text(text);
            }
            if text.is_empty() {
                return FindInternalTermsResult::default();
            }
            let deinflections = self._get_deinflections(text, opts);
            Translator::_get_dictionary_entries(
                &deinflections,
                enabled_dictionary_map,
                tag_aggregator,
                primary_reading,
            )
        }
        fn _remove_excluded_definitions(
            dictionary_entries: &mut Vec<InternalTermDictionaryEntry>,
            exclude_dictionary_definitions: &IndexSet<String>,
        ) {
            dictionary_entries
                .retain_mut(|entry| {
                    let original_def_len = entry.definitions.len();
                    entry
                        .definitions
                        .retain(|def| {
                            !exclude_dictionary_definitions.contains(&def.dictionary)
                        });
                    let definitions_were_removed = entry.definitions.len()
                        != original_def_len;
                    entry
                        .pronunciations
                        .retain(|p| {
                            !exclude_dictionary_definitions.contains(&p.dictionary)
                        });
                    entry
                        .frequencies
                        .retain(|f| {
                            !exclude_dictionary_definitions.contains(&f.dictionary)
                        });
                    Translator::_remove_tag_groups_with_dictionary_mut(
                        &mut entry.definitions,
                        exclude_dictionary_definitions,
                    );
                    Translator::_remove_tag_groups_with_dictionary_mut(
                        &mut entry.headwords,
                        exclude_dictionary_definitions,
                    );
                    if entry.definitions.is_empty() {
                        return false;
                    }
                    if definitions_were_removed {
                        Translator::_remove_unused_headwords(entry);
                    }
                    true
                });
        }
        fn _remove_unused_headwords(dictionary_entry: &mut InternalTermDictionaryEntry) {
            let mut remove_headword_indices: IndexSet<usize> = IndexSet::new();
            for i in 0..dictionary_entry.headwords.len() {
                remove_headword_indices.insert(i);
            }
            for definition in &dictionary_entry.definitions {
                for &headword_index in &definition.headword_indices {
                    remove_headword_indices.shift_remove_full(&headword_index);
                }
            }
            if remove_headword_indices.is_empty() {
                return;
            }
            let mut index_remap: IndexMap<usize, usize> = IndexMap::new();
            let mut new_headwords: Vec<TermHeadword> = Vec::new();
            let mut current_new_index = 0;
            for old_index in 0..dictionary_entry.headwords.len() {
                if !remove_headword_indices.contains(&old_index) {
                    new_headwords.push(dictionary_entry.headwords[old_index].clone());
                    index_remap.insert(old_index, current_new_index);
                    current_new_index += 1;
                }
            }
            dictionary_entry.headwords = new_headwords;
            let mut definitions: Vec<TermType> = dictionary_entry
                .definitions
                .clone()
                .into_iter()
                .map(|item_to_wrap| TermType::Definition(item_to_wrap))
                .collect();
            let mut frequencies: Vec<TermType> = dictionary_entry
                .frequencies
                .clone()
                .into_iter()
                .map(|item_to_wrap| TermType::Frequency(item_to_wrap))
                .collect();
            let mut pronunciations: Vec<TermType> = dictionary_entry
                .pronunciations
                .clone()
                .into_iter()
                .map(|item_to_wrap| TermType::Pronunciation(item_to_wrap))
                .collect();
            let mut updates = [definitions, frequencies, pronunciations];
            for mut update in &mut updates {
                Translator::_update_term_headword_indices_mut(update, &index_remap);
            }
            dictionary_entry.definitions = updates[0]
                .iter()
                .filter_map(|item| {
                    if let TermType::Definition(data) = item {
                        Some(data.clone())
                    } else {
                        None
                    }
                })
                .collect();
            dictionary_entry.frequencies = updates[1]
                .iter()
                .filter_map(|item| {
                    if let TermType::Frequency(data) = item {
                        Some(data.clone())
                    } else {
                        None
                    }
                })
                .collect();
            dictionary_entry.pronunciations = updates[2]
                .iter()
                .filter_map(|item| {
                    if let TermType::Pronunciation(data) = item {
                        Some(data.clone())
                    } else {
                        None
                    }
                })
                .collect();
        }
        /// Updates headword indices for a collection of
        /// `TermType` items based on an index remap.
        ///
        /// This function combines the logic of updating
        /// `headword_indices` within `TermDefinition`
        /// and updating `headword_index` for `TermPronunciation` and `TermFrequency`,
        /// removing items of the latter two types if their index cannot be remapped.
        ///
        /// # Arguments
        ///
        /// * `terms`: A mutable vector of `TermType` items to process. Items may be modified or removed in place.
        /// * `index_remap`: A map where the key is the old headword index and the value is the new headword index.
        fn _update_term_headword_indices_mut(
            terms: &mut Vec<TermType>,
            index_remap: &IndexMap<usize, usize>,
        ) {
            terms
                .retain_mut(|term_type| {
                    match term_type {
                        TermType::Definition(def) => {
                            let mut updated_indices = Vec::with_capacity(
                                def.headword_indices.len(),
                            );
                            for &old_idx in &def.headword_indices {
                                if let Some(&new_idx) = index_remap.get(&old_idx) {
                                    updated_indices.push(new_idx);
                                }
                            }
                            def.headword_indices = updated_indices;
                            true
                        }
                        TermType::Pronunciation(prono) => {
                            if let Some(&new_idx) = index_remap
                                .get(&prono.headword_index)
                            {
                                prono.headword_index = new_idx;
                                true
                            } else {
                                false
                            }
                        }
                        TermType::Frequency(freq) => {
                            if let Some(&new_idx) = index_remap.get(&freq.headword_index)
                            {
                                freq.headword_index = new_idx;
                                true
                            } else {
                                false
                            }
                        }
                    }
                });
        }
        fn _remove_tag_groups_with_dictionary_mut(
            array: &mut [impl HasTags],
            exclude_dictionary_definitions: &IndexSet<String>,
        ) {
            for item in array {
                Translator::_remove_tag_items_with_dictionary(
                    item._get_definition_tags_mut(),
                    exclude_dictionary_definitions,
                );
            }
        }
        /// In JS: `_removeArrayItemsWithDictionary2`
        fn _remove_tag_items_with_dictionary(
            tags: &mut Vec<DictionaryTag>,
            exclude_dictionary_definitions: &IndexSet<String>,
        ) -> bool {
            let original_len = tags.len();
            tags.retain(|tag| {
                !Translator::_has_any(
                    exclude_dictionary_definitions,
                    tag.dictionaries.iter(),
                )
            });
            original_len != tags.len()
        }
        fn _has_any<
            'b,
            T: PartialEq + Eq + Hash + 'b,
            U: std::iter::Iterator<Item = &'b T>,
        >(set: &IndexSet<T>, mut values: U) -> bool {
            values.any(|v| set.contains(v))
        }
        fn _remove_array_items_with_dictionary(
            terms: &[TermType],
            exclude_dictionary_definitions: &IndexSet<String>,
        ) -> Vec<TermType> {
            let mut changed = false;
            terms
                .iter()
                .filter_map(|term| {
                    if !exclude_dictionary_definitions
                        .contains(term.dictionary_and_alias().0)
                    {
                        return Some(term.clone());
                    }
                    None
                })
                .collect()
        }
        fn _get_related_dictionary_entries(
            &self,
            dictionary_entries_input: &[InternalTermDictionaryEntry],
            options: &FindTermsOptions,
            tag_aggregator: &mut TranslatorTagAggregator,
        ) -> Vec<InternalTermDictionaryEntry> {
            let FindTermsOptions {
                main_dictionary,
                enabled_dictionary_map,
                language,
                primary_reading,
                ..
            } = options;
            /// in js this is `type SequenceQuery` but I simplified this to use enums
            /// instead of objects, to be generic.
            let mut sequence_list: Vec<GenericQueryRequest> = Vec::new();
            let mut grouped_dictionary_entries: Vec<DictionaryEntryGroup> = Vec::new();
            let mut grouped_dictionary_entries_map: IndexMap<i128, usize> = IndexMap::new();
            let mut ungrouped_dictionary_entries_map: IndexMap<
                String,
                InternalTermDictionaryEntry,
            > = IndexMap::new();
            for dictionary_entry in dictionary_entries_input {
                if let Some(first_definition) = dictionary_entry.definitions.first() {
                    let id = &first_definition.id;
                    let definition_dictionary = &first_definition.dictionary;
                    if let Some(&sequence) = first_definition.sequences.first() {
                        if *definition_dictionary == *main_dictionary && sequence >= 0 {
                            let group_index_opt = grouped_dictionary_entries_map
                                .get(&sequence)
                                .copied();
                            let current_group_index = match group_index_opt {
                                Some(index) => index,
                                None => {
                                    let new_group = DictionaryEntryGroup {
                                        ids: IndexSet::new(),
                                        dictionary_entries: Vec::new(),
                                    };
                                    grouped_dictionary_entries.push(new_group);
                                    let new_index = grouped_dictionary_entries.len() - 1;
                                    sequence_list
                                        .push(GenericQueryRequest {
                                            query_type: QueryType::Sequence(sequence),
                                            dictionary: definition_dictionary.clone(),
                                        });
                                    grouped_dictionary_entries_map.insert(sequence, new_index);
                                    new_index
                                }
                            };
                            let group = &mut grouped_dictionary_entries[current_group_index];
                            group.dictionary_entries.push(dictionary_entry.clone());
                            group.ids.insert(id.clone());
                        } else {
                            ungrouped_dictionary_entries_map
                                .insert(id.clone(), dictionary_entry.clone());
                        }
                    } else {
                        ungrouped_dictionary_entries_map
                            .insert(id.clone(), dictionary_entry.clone());
                    }
                } else {}
            }
            if !sequence_list.is_empty() {
                let secondary_search_dictionary_map = Translator::_get_secondary_search_dictionary_map(
                    enabled_dictionary_map,
                );
                self._add_related_dictionary_entries(
                    &mut grouped_dictionary_entries,
                    &mut ungrouped_dictionary_entries_map,
                    sequence_list,
                    enabled_dictionary_map,
                    tag_aggregator,
                    primary_reading,
                );
                for group in &mut grouped_dictionary_entries {
                    Translator::_sort_term_dictionary_entries_by_id(
                        &mut group.dictionary_entries,
                    );
                }
                if !ungrouped_dictionary_entries_map.is_empty()
                    || !secondary_search_dictionary_map.is_empty()
                {
                    self._add_secondary_related_dictionary_entries(
                        language,
                        &mut grouped_dictionary_entries,
                        &mut ungrouped_dictionary_entries_map,
                        enabled_dictionary_map,
                        &secondary_search_dictionary_map,
                        tag_aggregator,
                        primary_reading,
                    )
                }
            }
            let mut new_dictionary_entries: Vec<InternalTermDictionaryEntry> = Vec::new();
            for group in &grouped_dictionary_entries {
                new_dictionary_entries
                    .push(
                        self
                            ._create_grouped_dictionary_entry(
                                language,
                                &group.dictionary_entries,
                                true,
                                tag_aggregator,
                                primary_reading,
                            ),
                    );
            }
            let ungrouped_values_collected: Vec<InternalTermDictionaryEntry> = ungrouped_dictionary_entries_map
                .values()
                .cloned()
                .collect();
            new_dictionary_entries
                .extend(
                    self
                        ._group_dictionary_entries_by_headword(
                            language,
                            &ungrouped_values_collected,
                            tag_aggregator,
                            primary_reading,
                        ),
                );
            new_dictionary_entries
        }
        fn _add_secondary_related_dictionary_entries(
            &self,
            language: &str,
            grouped_dictionary_entries: &mut [DictionaryEntryGroup],
            ungrouped_dictionary_entries_map: &mut IndexMap<
                String,
                InternalTermDictionaryEntry,
            >,
            enabled_dictionary_map: &TermEnabledDictionaryMap,
            secondary_search_dictionary_map: &TermEnabledDictionaryMap,
            tag_aggregator: &mut TranslatorTagAggregator,
            primary_reading: &str,
        ) {
            let mut term_list: Vec<TermExactQueryRequest> = Vec::new();
            let mut target_map_for_original_groups: IndexMap<String, Vec<usize>> = IndexMap::new();
            let mut term_list_to_original_group_indices: Vec<Vec<usize>> = Vec::new();
            let reading_normalizer = self.reading_normalizers.get(language);
            for (group_idx, group) in grouped_dictionary_entries.iter().enumerate() {
                for dictionary_entry in &group.dictionary_entries {
                    let headword = dictionary_entry
                        .headwords
                        .first()
                        .unwrap_or_else(|| {
                            {
                                ::core::panicking::panic_fmt(
                                    format_args!(
                                        "DictionaryEntry is missing headwords in _add_secondary_related_dictionary_entries for group processing, group_idx: {0}",
                                        group_idx,
                                    ),
                                );
                            }
                        });
                    let term = &headword.term;
                    let reading = &headword.reading;
                    let normalized_reading = Translator::_get_or_default_normalized_reading(
                        reading_normalizer,
                        reading,
                    );
                    let key = Translator::_create_map_key(
                        &(term.as_str(), normalized_reading.as_str()),
                    );
                    let groups_for_this_key = target_map_for_original_groups
                        .entry(key.clone())
                        .or_default();
                    if !groups_for_this_key.contains(&group_idx) {
                        groups_for_this_key.push(group_idx);
                    }
                    if !term_list
                        .iter()
                        .any(|tr| tr.term == *term && tr.reading == *reading)
                    {
                        term_list
                            .push(TermExactQueryRequest {
                                term: term.clone(),
                                reading: reading.clone(),
                            });
                    }
                }
            }
            term_list.clear();
            let mut term_list_associated_original_group_indices: Vec<Vec<usize>> = Vec::new();
            for (key, original_group_indices) in target_map_for_original_groups.iter() {}
            term_list.clear();
            let mut target_list_data: Vec<Vec<usize>> = Vec::new();
            let mut key_to_term_list_idx_map: IndexMap<String, usize> = IndexMap::new();
            for (group_idx, group) in grouped_dictionary_entries.iter().enumerate() {
                for dictionary_entry in &group.dictionary_entries {
                    let headword = dictionary_entry
                        .headwords
                        .first()
                        .unwrap_or_else(|| {
                            {
                                ::core::panicking::panic_fmt(
                                    format_args!(
                                        "DictionaryEntry is missing headwords (loop 2) for group_idx: {0}",
                                        group_idx,
                                    ),
                                );
                            }
                        });
                    let term = &headword.term;
                    let reading = &headword.reading;
                    let normalized_reading = Translator::_get_or_default_normalized_reading(
                        reading_normalizer,
                        reading,
                    );
                    let key = Translator::_create_map_key(
                        &(term.as_str(), normalized_reading.as_str()),
                    );
                    if let Some(&existing_term_idx) = key_to_term_list_idx_map.get(&key)
                    {
                        if !target_list_data[existing_term_idx].contains(&group_idx) {
                            target_list_data[existing_term_idx].push(group_idx);
                        }
                    } else {
                        let new_term_idx = term_list.len();
                        term_list
                            .push(TermExactQueryRequest {
                                term: term.clone(),
                                reading: reading.clone(),
                            });
                        key_to_term_list_idx_map.insert(key.clone(), new_term_idx);
                        target_list_data
                            .push(<[_]>::into_vec(::alloc::boxed::box_new([group_idx])));
                    }
                }
            }
            let mut ids_to_remove_from_ungrouped: IndexSet<String> = IndexSet::new();
            for (id, dictionary_entry) in ungrouped_dictionary_entries_map.iter() {
                let headword = dictionary_entry
                    .headwords
                    .first()
                    .unwrap_or_else(|| {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Ungrouped DictionaryEntry ID \'{0}\' is missing headwords in _add_secondary_related_dictionary_entries",
                                    id,
                                ),
                            );
                        }
                    });
                let term = &headword.term;
                let reading = &headword.reading;
                let normalized_reading = Translator::_get_or_default_normalized_reading(
                    reading_normalizer,
                    reading,
                );
                let key = Translator::_create_map_key(
                    &(term.as_str(), normalized_reading.as_str()),
                );
                if let Some(&term_idx_in_list) = key_to_term_list_idx_map.get(&key) {
                    let original_group_indices_for_this_term = &target_list_data[term_idx_in_list];
                    let mut entry_processed_and_moved = false;
                    for &original_group_idx in original_group_indices_for_this_term {
                        let group_to_update = &mut grouped_dictionary_entries[original_group_idx];
                        if group_to_update.ids.contains(id) {
                            continue;
                        }
                        group_to_update
                            .dictionary_entries
                            .push(dictionary_entry.clone());
                        group_to_update.ids.insert(id.clone());
                        entry_processed_and_moved = true;
                    }
                    if entry_processed_and_moved {
                        ids_to_remove_from_ungrouped.insert(id.clone());
                    }
                }
            }
            for id in ids_to_remove_from_ungrouped {
                ungrouped_dictionary_entries_map.shift_remove_full(&id);
            }
            if term_list.is_empty() || secondary_search_dictionary_map.is_empty() {
                return;
            }
            let mut database_entries = self
                .db
                .find_terms_exact_bulk(&term_list, secondary_search_dictionary_map)
                .unwrap_or_else(|e| {
                    {
                        ::std::io::_eprint(
                            format_args!("Error finding terms exact bulk: {0:?}\n", e),
                        );
                    };
                    Vec::new()
                });
            database_entries.sort_by_key(|e| e.index);
            for database_entry in database_entries {
                let original_req_index = database_entry.index;
                if original_req_index >= term_list.len() {
                    {
                        ::std::io::_eprint(
                            format_args!(
                                "Database returned out-of-bounds index {0} for TermEntry id {1}\n",
                                original_req_index,
                                database_entry.id,
                            ),
                        );
                    };
                    continue;
                }
                let source_text = &term_list[original_req_index].term;
                let original_group_indices_for_this_db_entry = &target_list_data[original_req_index];
                for &group_idx_to_update in original_group_indices_for_this_db_entry {
                    if group_idx_to_update >= grouped_dictionary_entries.len() {
                        {
                            ::std::io::_eprint(
                                format_args!(
                                    "Group index {0} out of bounds for grouped_dictionary_entries (len {1})\n",
                                    group_idx_to_update,
                                    grouped_dictionary_entries.len(),
                                ),
                            );
                        };
                        continue;
                    }
                    let group_to_update = &mut grouped_dictionary_entries[group_idx_to_update];
                    if group_to_update.ids.contains(&database_entry.id) {
                        continue;
                    }
                    let new_dictionary_entry = Translator::_create_internal_term_dictionary_entry_from_database_entry(
                        database_entry.clone(),
                        source_text,
                        source_text,
                        source_text,
                        Vec::new(),
                        Vec::new(),
                        false,
                        enabled_dictionary_map,
                        tag_aggregator,
                        primary_reading,
                    );
                    group_to_update.dictionary_entries.push(new_dictionary_entry);
                    group_to_update.ids.insert(database_entry.id.clone());
                    ungrouped_dictionary_entries_map
                        .shift_remove_full(&database_entry.id);
                }
            }
        }
        fn _sort_term_dictionary_entries_by_id(
            dictionary_entries: &mut [InternalTermDictionaryEntry],
        ) {
            if dictionary_entries.len() <= 1 {
                return;
            }
            dictionary_entries
                .sort_by(|a, b| a.definitions[0].id.cmp(&b.definitions[0].id));
        }
        fn _add_related_dictionary_entries(
            &self,
            grouped_dictionary_entries: &mut [DictionaryEntryGroup],
            ungrouped_dictionary_entries_map: &mut IndexMap<
                String,
                InternalTermDictionaryEntry,
            >,
            sequence_list: Vec<GenericQueryRequest>,
            enabled_dictionary_map: &TermEnabledDictionaryMap,
            tag_aggregator: &mut TranslatorTagAggregator,
            primary_reading: &str,
        ) {
            let mut database_entries = self
                .db
                .find_terms_by_sequence_bulk(sequence_list)
                .unwrap_or_default();
            for db_entry in database_entries {
                let TermEntry { id, term, index, .. } = &db_entry;
                let DictionaryEntryGroup { ids, dictionary_entries } = &mut grouped_dictionary_entries[*index];
                if ids.has(id) {
                    continue;
                }
                let dictionary_entry = Translator::_create_internal_term_dictionary_entry_from_database_entry(
                    db_entry.clone(),
                    term,
                    term,
                    term,
                    ::alloc::vec::Vec::new(),
                    ::alloc::vec::Vec::new(),
                    false,
                    enabled_dictionary_map,
                    tag_aggregator,
                    primary_reading,
                );
                dictionary_entries.push(dictionary_entry);
                ids.insert(id.clone());
                ungrouped_dictionary_entries_map.shift_remove_full(id);
            }
        }
        fn _get_secondary_search_dictionary_map(
            enabled_dictionary_map: &TermEnabledDictionaryMap,
        ) -> TermEnabledDictionaryMap {
            enabled_dictionary_map
                .iter()
                .filter_map(|(dictionary, details)| {
                    if !details.allow_secondary_searches {
                        return None;
                    }
                    Some((dictionary.to_owned(), details.to_owned()))
                })
                .collect()
        }
        fn _group_dictionary_entries_by_headword(
            &self,
            language: &str,
            dictionary_entries: &[InternalTermDictionaryEntry],
            tag_aggregator: &mut TranslatorTagAggregator,
            primary_reading: &str,
        ) -> Vec<InternalTermDictionaryEntry> {
            let mut groups: IndexMap<String, Vec<InternalTermDictionaryEntry>> = IndexMap::new();
            let reading_normalizer = self.reading_normalizers.get(language);
            for dictionary_entry in dictionary_entries {
                let InternalTermDictionaryEntry {
                    inflection_rule_chain_candidates,
                    headwords,
                    ..
                } = dictionary_entry;
                let TermHeadword { term, reading, .. } = headwords
                    .first()
                    .unwrap_or_else(|| {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "in fn `_group_dictionary_entries_by_word`:\n                            headwords[0] is None (this is infallible in JS)",
                                ),
                            );
                        }
                    });
                let normalized_reading = Translator::_get_or_default_normalized_reading(
                    reading_normalizer,
                    reading,
                );
                let key = Translator::_create_map_key(
                    &(term, normalized_reading, inflection_rule_chain_candidates),
                );
                groups.entry(key).or_default().push(dictionary_entry.clone());
            }
            let new_dictionary_entries = groups
                .values()
                .map(|group_dictionary_entries| {
                    self._create_grouped_dictionary_entry(
                        language,
                        group_dictionary_entries,
                        false,
                        tag_aggregator,
                        primary_reading,
                    )
                })
                .collect();
            new_dictionary_entries
        }
        fn _get_or_default_normalized_reading(
            reading_normalizer: Option<&fn(&str) -> String>,
            reading: &str,
        ) -> String {
            if let Some(reading_normalizer) = reading_normalizer {
                reading_normalizer(reading)
            } else {
                reading.to_string()
            }
        }
        fn _create_grouped_dictionary_entry(
            &self,
            language: &str,
            dictionary_entries: &[InternalTermDictionaryEntry],
            mut check_duplicate_definitions: bool,
            tag_aggregator: &mut TranslatorTagAggregator,
            primary_reading: &str,
        ) -> InternalTermDictionaryEntry {
            let mut definition_entries = ::alloc::vec::Vec::new();
            let mut headwords: IndexMap<String, TermHeadword> = IndexMap::new();
            dictionary_entries
                .iter()
                .for_each(|dictionary_entry| {
                    let headword_index_map = self
                        ._add_term_headwords(
                            language,
                            &mut headwords,
                            &dictionary_entry.headwords,
                            tag_aggregator,
                        );
                    let term_dictionary_entry_with_map = InternalTermDictionaryEntryWithIndexes {
                        index: definition_entries.len(),
                        dictionary_entry: dictionary_entry.clone(),
                        headword_indexes: headword_index_map,
                    };
                    definition_entries.push(term_dictionary_entry_with_map);
                });
            if definition_entries.len() <= 1 {
                check_duplicate_definitions = false;
            }
            let mut score = i128::MIN;
            let mut dictionary_index = usize::MAX;
            let mut dictionary_alias = "".to_string();
            let mut max_original_text_length = 0;
            let mut is_primary = false;
            let mut definitions: Vec<TermDefinition> = ::alloc::vec::Vec::new();
            let mut definitions_map: Option<IndexMap<String, TermDefinition>> = match check_duplicate_definitions {
                true => Some(IndexMap::new()),
                false => None,
            };
            let mut inflections: Option<Vec<InternalInflectionRuleChainCandidate>> = None;
            let mut text_processes: Option<Vec<TextProcessorRuleChainCandidate>> = None;
            for definition_entry in &definition_entries {
                let InternalTermDictionaryEntryWithIndexes {
                    dictionary_entry,
                    headword_indexes,
                    ..
                } = definition_entry;
                score = score.max(dictionary_entry.score);
                dictionary_index = dictionary_index
                    .min(dictionary_entry.dictionary_index);
                dictionary_alias = dictionary_entry.dictionary_alias.clone();
                if dictionary_entry.is_primary {
                    is_primary = true;
                    max_original_text_length = max_original_text_length
                        .max(dictionary_entry.max_original_text_length);
                    let dictionary_entry_inflections = &dictionary_entry
                        .inflection_rule_chain_candidates;
                    let dictionary_entry_text_processes = &dictionary_entry
                        .text_processor_rule_chain_candidates;
                    if inflections
                        .as_deref()
                        .is_none_or(|i| dictionary_entry_inflections.len() < i.len())
                    {
                        inflections = Some(dictionary_entry_inflections.clone());
                    }
                    if text_processes
                        .as_deref()
                        .is_none_or(|tp| {
                            dictionary_entry_text_processes.len() < tp.len()
                        })
                    {
                        text_processes = Some(dictionary_entry_text_processes.clone());
                    }
                }
                if let Some(definitions_map) = definitions_map.as_mut() {
                    Translator::_add_term_definitions(
                        &mut definitions,
                        definitions_map,
                        &dictionary_entry.definitions,
                        headword_indexes,
                        tag_aggregator,
                    );
                } else {
                    Translator::_add_term_definitions_fast(
                        &mut definitions,
                        &dictionary_entry.definitions,
                        headword_indexes,
                    );
                }
            }
            let headwords_array: Vec<TermHeadword> = headwords
                .values()
                .cloned()
                .collect();
            let mut source_term_exact_match_count = 0;
            let mut match_primary_reading = false;
            for headword in &headwords_array {
                let TermHeadword { sources, reading, .. } = headword;
                if !primary_reading.is_empty() && reading == primary_reading {
                    match_primary_reading = true;
                }
                for source in sources {
                    if source.is_primary
                        && source.match_source == TermSourceMatchSource::Term
                    {
                        source_term_exact_match_count += 1;
                        break;
                    }
                }
            }
            Translator::_create_internal_term_dictionary_entry(
                is_primary,
                text_processes.unwrap_or_default(),
                inflections.unwrap_or_default(),
                score,
                dictionary_index,
                dictionary_alias,
                source_term_exact_match_count,
                match_primary_reading,
                max_original_text_length,
                headwords_array,
                definitions,
            )
        }
        fn _add_term_definitions_fast(
            definitions: &mut Vec<TermDefinition>,
            new_definitions: &[TermDefinition],
            headword_index_map: &[usize],
        ) {
            for new_def in new_definitions {
                let headword_indices_new: Vec<usize> = new_def
                    .headword_indices
                    .iter()
                    .map(|&idx| headword_index_map[idx])
                    .collect();
                let index = definitions.len();
                definitions
                    .push(
                        Translator::_create_term_definition(
                            index,
                            headword_indices_new,
                            new_def.dictionary.clone(),
                            new_def.dictionary_index,
                            new_def.dictionary_alias.clone(),
                            new_def.id.clone(),
                            new_def.score,
                            new_def.sequences.clone(),
                            new_def.is_primary,
                            new_def.tags.clone(),
                            new_def.entries.clone(),
                        ),
                    );
            }
        }
        fn _add_term_definitions(
            definitions: &mut Vec<TermDefinition>,
            definitions_map: &mut IndexMap<String, TermDefinition>,
            new_definitions: &[TermDefinition],
            headword_index_map: &[usize],
            tag_aggregator: &mut TranslatorTagAggregator,
        ) {
            new_definitions
                .iter()
                .for_each(|new_definition| {
                    let TermDefinition {
                        index,
                        headword_indices,
                        dictionary,
                        dictionary_index,
                        dictionary_alias,
                        sequences,
                        id,
                        score,
                        is_primary,
                        tags,
                        entries,
                        frequency_order,
                    } = new_definition;
                    let key = Translator::_create_map_key(&(dictionary, entries));
                    let mut definition = definitions_map.get(&key).cloned();
                    if let Some(ref mut definition) = definition {
                        if *is_primary {
                            definition.is_primary = true;
                        }
                        Translator::_add_unique_simple(
                            &mut definition.sequences,
                            sequences,
                        );
                    } else {
                        let TermDefinition {
                            id,
                            index,
                            headword_indices,
                            dictionary,
                            dictionary_index,
                            dictionary_alias,
                            score,
                            frequency_order,
                            sequences,
                            is_primary,
                            tags,
                            entries,
                        } = new_definition.clone();
                        let new_def = Translator::_create_term_definition(
                            definitions.len(),
                            ::alloc::vec::Vec::new(),
                            dictionary,
                            dictionary_index,
                            dictionary_alias,
                            id,
                            score,
                            sequences,
                            is_primary,
                            ::alloc::vec::Vec::new(),
                            entries,
                        );
                        definitions.push(new_def.clone());
                        definitions_map.insert(key, new_def.clone());
                        definition = Some(new_def);
                    }
                    /// definition is Some after this point, so unwrap() is safe
                    /// merge tags doesn't mutate the passed in values so we can save it here cloned
                    let definition_ref = definition.as_mut().unwrap();
                    let definition_headword_indices: &mut Vec<usize> = &mut definition_ref
                        .headword_indices;
                    for headword_index in headword_indices {
                        Translator::_add_unique_term_headword_index(
                            definition_headword_indices,
                            headword_index_map[*headword_index],
                        );
                    }
                    tag_aggregator.merge_tags(&definition_ref.tags, tags);
                });
        }
        /// this is a binary search
        fn _add_unique_term_headword_index(
            headword_indices: &mut Vec<usize>,
            headword_index: usize,
        ) {
            match headword_indices.binary_search(&headword_index) {
                Ok(_) => {}
                Err(pos) => headword_indices.insert(pos, headword_index),
            }
        }
        fn _add_term_headwords(
            &self,
            language: &str,
            headwords_map: &mut IndexMap<String, TermHeadword>,
            headwords: &[TermHeadword],
            tag_aggregator: &mut TranslatorTagAggregator,
        ) -> Vec<usize> {
            headwords
                .iter()
                .map(|current_input_hw| {
                    let TermHeadword {
                        term,
                        reading,
                        sources,
                        tags,
                        word_classes,
                        ..
                    } = current_input_hw;
                    let reading_normalizer_opt = self.reading_normalizers.get(language);
                    let normalized_reading = Translator::_get_or_default_normalized_reading(
                        reading_normalizer_opt,
                        reading,
                    );
                    let key = Translator::_create_map_key(&(term, normalized_reading));
                    let new_hw_potential_index = headwords_map.len();
                    let map_hw_ref_mut = headwords_map
                        .entry(key)
                        .or_insert_with(|| {
                            Translator::_create_term_headword(
                                new_hw_potential_index,
                                term.to_string(),
                                reading.to_string(),
                                Vec::new(),
                                Vec::new(),
                                Vec::new(),
                            )
                        });
                    Translator::_add_unique_sources(
                        &mut map_hw_ref_mut.sources,
                        sources,
                    );
                    Translator::_add_unique_simple(
                        &mut map_hw_ref_mut.word_classes,
                        word_classes,
                    );
                    tag_aggregator.merge_tags(&map_hw_ref_mut.tags, tags);
                    map_hw_ref_mut.index
                })
                .collect()
        }
        /// this deviates from JS.
        /// js loops through the `list` array everytime within `new_items` for_each(),
        /// here we create a set so it becomes O(1).
        ///
        /// depending on if duplicates existing (on purpose) this might be incorrect.
        fn _add_unique_simple<T>(list: &mut Vec<T>, new_items: &[T])
        where
            T: Eq + Hash + Clone,
        {
            let mut existing_items_set: IndexSet<T> = list.iter().cloned().collect();
            new_items
                .iter()
                .for_each(|item| {
                    if existing_items_set.insert(item.clone()) {
                        list.push(item.clone());
                    }
                });
        }
        fn _add_unique_sources(
            sources: &mut Vec<TermSource>,
            new_sources: &[TermSource],
        ) {
            if new_sources.is_empty() {
                return;
            }
            if sources.is_empty() {
                sources.extend(new_sources.to_vec());
                return;
            }
            new_sources
                .iter()
                .for_each(|new_source| {
                    let TermSource {
                        original_text,
                        transformed_text,
                        deinflected_text,
                        match_type,
                        match_source,
                        is_primary,
                    } = new_source;
                    let has = sources
                        .iter_mut()
                        .any(|src| {
                            if src.original_text == *original_text
                                && src.transformed_text == *transformed_text
                                && src.deinflected_text == *deinflected_text
                                && src.match_type == *match_type
                                && src.match_source == *match_source
                            {
                                if (*is_primary) {
                                    src.is_primary = true;
                                }
                                return true;
                            }
                            false
                        });
                    if !has {
                        sources.push(new_source.clone());
                    }
                });
        }
        fn _create_map_key(v: &(impl Serialize + std::fmt::Debug)) -> String {
            serde_json::to_string(v)
                .unwrap_or_else(|e| {
                    ::core::panicking::panic_fmt(
                        format_args!("could not serialize {0:?} to map key: {1}", v, e),
                    );
                })
        }
        fn _get_dictionary_entries(
            deinflections: &[DatabaseDeinflection],
            enabled_dictionary_map: &FindTermDictionaryMap,
            tag_aggregator: &mut TranslatorTagAggregator,
            primary_reading: &str,
        ) -> FindInternalTermsResult {
            let mut original_text_length = 0;
            let mut dictionary_entries: Vec<InternalTermDictionaryEntry> = ::alloc::vec::Vec::new();
            let mut ids: IndexSet<String> = IndexSet::new();
            for deinflection in deinflections {
                let DatabaseDeinflection {
                    database_entries,
                    original_text,
                    transformed_text,
                    deinflected_text,
                    text_processor_rule_chain_candidates,
                    inflection_rule_chain_candidates,
                    ..
                } = deinflection;
                if database_entries.is_empty() {
                    continue;
                }
                original_text_length = original_text.len().max(original_text_length);
                for database_entry in database_entries {
                    let id = database_entry.id.clone();
                    if !ids.contains(id.as_str()) {
                        let dictionary_entry = Translator::_create_internal_term_dictionary_entry_from_database_entry(
                            database_entry.clone(),
                            original_text,
                            transformed_text,
                            deinflected_text,
                            text_processor_rule_chain_candidates.clone(),
                            inflection_rule_chain_candidates.clone(),
                            true,
                            enabled_dictionary_map,
                            tag_aggregator,
                            primary_reading,
                        );
                        dictionary_entries.push(dictionary_entry);
                        ids.insert(id);
                        continue;
                    }
                    let existing_entry_info = Translator::_find_existing_entry(
                        &dictionary_entries,
                        &id,
                    );
                    let Some(existing_entry_info) = existing_entry_info else {
                        continue;
                    };
                    let ExistingEntry {
                        entry: mut existing_entry,
                        index: existing_index,
                    } = existing_entry_info;
                    let existing_transformed_len = existing_entry
                        .headwords
                        .first()
                        .expect(
                            "existing entries first headword is None (this is infallible in JS)",
                        )
                        .sources
                        .first()
                        .expect(
                            "existing entries first source is None (this is insaffilble in JS)",
                        )
                        .transformed_text
                        .len();
                    if transformed_text.len() < existing_transformed_len {
                        continue;
                    }
                    let term_dictionary_entry = Translator::_create_internal_term_dictionary_entry_from_database_entry(
                        database_entry.clone(),
                        original_text,
                        transformed_text,
                        deinflected_text,
                        text_processor_rule_chain_candidates.clone(),
                        inflection_rule_chain_candidates.clone(),
                        true,
                        enabled_dictionary_map,
                        tag_aggregator,
                        primary_reading,
                    );
                    if transformed_text.len() > existing_transformed_len {
                        dictionary_entries
                            .splice(
                                existing_index..1,
                                iter::once(term_dictionary_entry),
                            );
                    } else {
                        Translator::_merge_inflection_rule_chains(
                            &mut existing_entry,
                            inflection_rule_chain_candidates,
                        );
                        Translator::_merge_text_processor_rule_chains(
                            &mut existing_entry,
                            text_processor_rule_chain_candidates,
                        );
                    }
                }
            }
            FindInternalTermsResult {
                dictionary_entries,
                original_text_length: original_text_length as i128,
            }
        }
        fn _merge_text_processor_rule_chains(
            existing_entry: &mut InternalTermDictionaryEntry,
            text_processor_rule_chain_candidates: &[TextProcessorRuleChainCandidate],
        ) {
            for text_processor_rules in text_processor_rule_chain_candidates {
                if existing_entry
                    .text_processor_rule_chain_candidates
                    .iter()
                    .any(|chain| {
                        Translator::_are_arrays_equal_ignore_order(
                            chain,
                            text_processor_rules,
                        )
                    })
                {} else {
                    existing_entry
                        .text_processor_rule_chain_candidates
                        .push(text_processor_rules.clone());
                }
            }
        }
        /// mutates the existing_entry
        fn _merge_inflection_rule_chains(
            existing_entry: &mut InternalTermDictionaryEntry,
            inflection_rule_chain_candidates: &[InternalInflectionRuleChainCandidate],
        ) {
            for candidate in inflection_rule_chain_candidates {
                let InternalInflectionRuleChainCandidate { source, inflection_rules } = candidate;
                if let Some(duplicate) = existing_entry
                    .inflection_rule_chain_candidates
                    .iter_mut()
                    .find(|chain| {
                        Translator::_are_arrays_equal_ignore_order(
                            &chain.inflection_rules,
                            inflection_rules,
                        )
                    })
                {
                    if duplicate.source != *source {
                        duplicate.source = InflectionSource::Both;
                    }
                } else {
                    let new_rule_chain_candidate = InternalInflectionRuleChainCandidate {
                        source: *source,
                        inflection_rules: inflection_rules.clone(),
                    };
                    existing_entry
                        .inflection_rule_chain_candidates
                        .push(new_rule_chain_candidate);
                }
            }
        }
        fn _are_arrays_equal_ignore_order(
            x: &[impl AsRef<str>],
            y: &[impl AsRef<str>],
        ) -> bool {
            if x.len() != y.len() {
                return false;
            }
            let mut frequency_counter = IndexMap::new();
            for element_ref in x {
                *frequency_counter.entry(element_ref.as_ref()).or_insert(0) += 1;
            }
            for element_ref in y {
                let count = frequency_counter.entry(element_ref.as_ref()).or_insert(0);
                if *count == 0 {
                    return false;
                }
                *count -= 1;
            }
            true
        }
        fn _find_existing_entry(
            dictionary_entries: &[InternalTermDictionaryEntry],
            id: &str,
        ) -> Option<ExistingEntry> {
            dictionary_entries
                .iter()
                .enumerate()
                .find_map(|(index, entry)| {
                    entry
                        .definitions
                        .iter()
                        .find(|def| def.id == id)
                        .map(|_| ExistingEntry {
                            index,
                            entry: entry.clone(),
                        })
                })
        }
        /// [TermGlossary]
        fn _create_internal_term_dictionary_entry_from_database_entry(
            database_entry: TermEntry,
            original_text: &str,
            transformed_text: &str,
            deinflected_text: &str,
            text_processor_rule_chain_candidates: Vec<TextProcessorRuleChainCandidate>,
            inflection_rule_chain_candidates: Vec<InternalInflectionRuleChainCandidate>,
            is_primary: bool,
            enabled_dictionary_map: &FindTermDictionaryMap,
            tag_aggregator: &mut TranslatorTagAggregator,
            primary_reading: &str,
        ) -> InternalTermDictionaryEntry {
            let TermEntry {
                id,
                index: dictionary_index,
                term,
                reading: raw_reading,
                sequence: raw_sequence,
                match_type,
                match_source,
                definition_tags,
                term_tags,
                rules,
                definitions,
                score,
                dictionary,
            } = database_entry;
            let content_definitions: Vec<TermGlossaryContent> = definitions
                .into_iter()
                .filter_map(|def| match def {
                    TermGlossary::Content(c) => Some(*c),
                    TermGlossary::Deinflection(_) => None,
                })
                .collect();
            let reading = match raw_reading.is_empty() {
                true => term.clone(),
                false => raw_reading,
            };
            let match_primary_reading = !primary_reading.is_empty()
                && reading == primary_reading;
            let dictionary_order = Translator::_get_dictionary_order(
                &dictionary,
                &EnabledDictionaryMapType::Term(enabled_dictionary_map),
            );
            let dictionary_alias = Translator::_get_dictionary_alias(
                dictionary.clone(),
                &EnabledDictionaryMapType::Term(enabled_dictionary_map),
            );
            let source_term_exact_match_count = match is_primary
                && deinflected_text == term
            {
                true => 1,
                false => 0,
            };
            let source = Translator::_create_source(
                original_text.to_owned(),
                transformed_text.to_owned(),
                deinflected_text.to_owned(),
                match_type,
                match_source,
                is_primary,
            );
            let max_original_text_length = original_text.len();
            let has_sequence = raw_sequence >= 0;
            let sequence = match has_sequence {
                true => raw_sequence,
                false => -1,
            };
            let headword_tag_groups: Vec<DictionaryTag> = ::alloc::vec::Vec::new();
            let definition_tag_groups: Vec<DictionaryTag> = ::alloc::vec::Vec::new();
            tag_aggregator.add_tags(&headword_tag_groups, &dictionary, &term_tags);
            tag_aggregator
                .add_tags(&definition_tag_groups, &dictionary, &definition_tags);
            let headwords = <[_]>::into_vec(
                ::alloc::boxed::box_new([
                    Translator::_create_term_headword(
                        0,
                        term,
                        reading,
                        <[_]>::into_vec(::alloc::boxed::box_new([source])),
                        headword_tag_groups,
                        rules,
                    ),
                ]),
            );
            let definitions = <[_]>::into_vec(
                ::alloc::boxed::box_new([
                    Translator::_create_term_definition(
                        0,
                        <[_]>::into_vec(::alloc::boxed::box_new([0])),
                        dictionary,
                        dictionary_index,
                        dictionary_alias.clone(),
                        id,
                        score,
                        <[_]>::into_vec(::alloc::boxed::box_new([sequence])),
                        is_primary,
                        definition_tag_groups,
                        content_definitions,
                    ),
                ]),
            );
            Translator::_create_internal_term_dictionary_entry(
                is_primary,
                text_processor_rule_chain_candidates,
                inflection_rule_chain_candidates,
                score,
                dictionary_index,
                dictionary_alias,
                source_term_exact_match_count,
                match_primary_reading,
                max_original_text_length,
                headwords,
                definitions,
            )
        }
        fn _create_term_definition(
            index: usize,
            headword_indices: Vec<usize>,
            dictionary: String,
            dictionary_index: usize,
            dictionary_alias: String,
            id: String,
            score: i128,
            sequences: Vec<i128>,
            is_primary: bool,
            tags: Vec<DictionaryTag>,
            entries: Vec<TermGlossaryContent>,
        ) -> TermDefinition {
            TermDefinition {
                id,
                index,
                headword_indices,
                dictionary,
                dictionary_alias,
                dictionary_index,
                score,
                frequency_order: 0,
                sequences,
                is_primary,
                tags,
                entries,
            }
        }
        fn _create_term_headword(
            index: usize,
            term: String,
            reading: String,
            sources: Vec<TermSource>,
            tags: Vec<DictionaryTag>,
            word_classes: Vec<String>,
        ) -> TermHeadword {
            TermHeadword {
                index,
                term,
                reading,
                sources,
                tags,
                word_classes,
            }
        }
        fn _create_internal_term_dictionary_entry(
            is_primary: bool,
            text_processor_rule_chain_candidates: Vec<TextProcessorRuleChainCandidate>,
            inflection_rule_chain_candidates: Vec<InternalInflectionRuleChainCandidate>,
            score: i128,
            dictionary_index: usize,
            dictionary_alias: String,
            source_term_exact_match_count: usize,
            match_primary_reading: bool,
            max_original_text_length: usize,
            headwords: Vec<TermHeadword>,
            definitions: Vec<TermDefinition>,
        ) -> InternalTermDictionaryEntry {
            InternalTermDictionaryEntry {
                entry_type: TermSourceMatchSource::Term,
                is_primary,
                text_processor_rule_chain_candidates,
                inflection_rule_chain_candidates,
                score,
                frequency_order: 0,
                dictionary_index,
                source_term_exact_match_count,
                max_original_text_length,
                headwords,
                definitions,
                dictionary_alias,
                match_primary_reading,
                pronunciations: ::alloc::vec::Vec::new(),
                frequencies: ::alloc::vec::Vec::new(),
            }
        }
        fn _create_source(
            original_text: String,
            transformed_text: String,
            deinflected_text: String,
            match_type: TermSourceMatchType,
            match_source: TermSourceMatchSource,
            is_primary: bool,
        ) -> TermSource {
            TermSource {
                original_text,
                transformed_text,
                deinflected_text,
                match_type,
                match_source,
                is_primary,
            }
        }
        fn _get_dictionary_alias(
            dictionary: String,
            enabled_dictionary_map: &EnabledDictionaryMapType,
        ) -> String {
            match enabled_dictionary_map {
                EnabledDictionaryMapType::Term(m) => {
                    match m.get(&dictionary) {
                        Some(info) => info.alias.clone(),
                        None => dictionary,
                    }
                }
                EnabledDictionaryMapType::Kanji(m) => {
                    match m.get(&dictionary) {
                        Some(info) => info.alias.clone(),
                        None => dictionary,
                    }
                }
            }
        }
        fn _get_dictionary_order(
            dictionary: &str,
            enabled_dictionary_map: &EnabledDictionaryMapType,
        ) -> usize {
            match enabled_dictionary_map {
                EnabledDictionaryMapType::Term(map) => {
                    map.get(dictionary).map(|info| info.index).unwrap_or(map.len())
                }
                EnabledDictionaryMapType::Kanji(map) => {
                    map.get(dictionary).map(|info| info.index).unwrap_or(map.len())
                }
            }
        }
        fn _get_deinflections(
            &self,
            text: &str,
            opts: &FindTermsOptions,
        ) -> Vec<DatabaseDeinflection> {
            let mut deinflections = if opts.deinflect {
                self._get_algorithm_deinflections(text, opts).unwrap()
            } else {
                <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        Translator::_create_deinflection(
                            text,
                            text,
                            text,
                            0,
                            ::alloc::vec::Vec::new(),
                            ::alloc::vec::Vec::new(),
                        ),
                    ]),
                )
            };
            if deinflections.is_empty() {
                return ::alloc::vec::Vec::new();
            }
            let FindTermsOptions { match_type, language, enabled_dictionary_map, .. } = opts;
            self._add_entries_to_deinflections(
                language,
                &mut deinflections,
                enabled_dictionary_map,
                *match_type,
            );
            let dictionary_deinflections = self
                ._get_dictionary_deinflections(
                    language,
                    &deinflections,
                    enabled_dictionary_map,
                    *match_type,
                );
            deinflections.extend(dictionary_deinflections);
            for deinflection in &mut deinflections {
                for mut entry in deinflection.database_entries.iter_mut() {
                    entry
                        .definitions
                        .retain(|def| {
                            !match def {
                                TermGlossary::Deinflection(_) => true,
                                _ => false,
                            }
                        })
                }
                deinflection
                    .database_entries
                    .retain(|entry| !entry.definitions.is_empty());
            }
            deinflections
                .retain(|deinflection| !deinflection.database_entries.is_empty());
            deinflections
        }
        fn _get_dictionary_deinflections(
            &self,
            language: &str,
            deinflections_input: &[DatabaseDeinflection],
            enabled_dictionary_map: &FindTermDictionaryMap,
            match_type: TermSourceMatchType,
        ) -> Vec<DatabaseDeinflection> {
            let mut dictionary_deinflections: Vec<DatabaseDeinflection> = Vec::new();
            for deinflection_item in deinflections_input {
                let DatabaseDeinflection {
                    original_text,
                    transformed_text,
                    text_processor_rule_chain_candidates,
                    database_entries,
                    ..
                } = deinflection_item;
                let algorithm_chains = &deinflection_item
                    .inflection_rule_chain_candidates;
                for entry in database_entries {
                    let TermEntry { dictionary, definitions, .. } = entry;
                    let entry_dictionary = enabled_dictionary_map.get(dictionary);
                    let use_deinflections = match entry_dictionary {
                        Some(ed) => ed.use_deinflections,
                        None => true,
                    };
                    if !use_deinflections {
                        continue;
                    }
                    for definition_variant in definitions {
                        if let TermGlossary::Deinflection(term_glossary_deinflection) = definition_variant {
                            let TermGlossaryDeinflection {
                                uninflected: form_of,
                                inflection_rule_chain: inflection_rules,
                            } = term_glossary_deinflection;
                            if form_of.is_empty() {
                                continue;
                            }
                            let inflection_rule_chain_candidates: Vec<
                                InternalInflectionRuleChainCandidate,
                            > = algorithm_chains
                                .iter()
                                .map(|alg_chain_candidate| {
                                    let alg_inflections = &alg_chain_candidate.inflection_rules;
                                    let source = if alg_inflections.is_empty() {
                                        InflectionSource::Dictionary
                                    } else {
                                        InflectionSource::Both
                                    };
                                    let inflection_rule_chain_candidates: Vec<String> = alg_inflections
                                        .iter()
                                        .cloned()
                                        .chain(inflection_rules.iter().cloned())
                                        .collect();
                                    InternalInflectionRuleChainCandidate {
                                        source,
                                        inflection_rules: inflection_rule_chain_candidates,
                                    }
                                })
                                .collect();
                            let dictionary_deinflection = Translator::_create_deinflection(
                                original_text,
                                transformed_text,
                                form_of,
                                0,
                                text_processor_rule_chain_candidates.clone(),
                                inflection_rule_chain_candidates,
                            );
                            dictionary_deinflections.push(dictionary_deinflection);
                        }
                    }
                }
            }
            self._add_entries_to_deinflections(
                language,
                &mut dictionary_deinflections,
                enabled_dictionary_map,
                match_type,
            );
            dictionary_deinflections
        }
        fn _get_algorithm_deinflections(
            &self,
            text: &str,
            opts: &FindTermsOptions,
        ) -> Result<Vec<DatabaseDeinflection>, TranslatorError> {
            let language = opts.language.clone();
            let Some(processors_for_lang) = self.text_processors.get(language.as_str())
            else {
                return Err(TranslatorError::UnsupportedLanguage(language));
            };
            let PreAndPostProcessorsWithId { pre, post } = processors_for_lang;
            let mut db_deinflections: Vec<DatabaseDeinflection> = Vec::new();
            let mut source_cache = IndexMap::new();
            let mut raw_source = text.to_string();
            while !raw_source.is_empty() {
                let text_replacements = Translator::_get_text_replacement_variants(opts);
                let pre_processed_text_variants = Translator::_get_text_variants(
                    &raw_source,
                    pre,
                    text_replacements,
                    &mut source_cache,
                );
                for pre_processed_variant in pre_processed_text_variants {
                    let (source, preprocessor_rule_chain_candidates) = pre_processed_variant;
                    let deinflections = self.mlt.transform(&language, &source);
                    for deinflection in deinflections {
                        let TransformedText { trace, conditions, .. } = deinflection;
                        let postprocessed_text_variants = Translator::_get_text_variants(
                            &deinflection.text,
                            post,
                            <[_]>::into_vec(::alloc::boxed::box_new([None])),
                            &mut source_cache,
                        );
                        for post_processed_variant in postprocessed_text_variants {
                            let (
                                transformed_text,
                                postprocessor_rule_chain_candidates,
                            ) = post_processed_variant;
                            let inflection_rule_chain_candidate = InternalInflectionRuleChainCandidate {
                                source: InflectionSource::Algorithm,
                                inflection_rules: trace
                                    .iter()
                                    .map(|frame| frame.transform.clone())
                                    .collect(),
                            };
                            let text_processor_rule_chain_candidates: Vec<Vec<String>> = preprocessor_rule_chain_candidates
                                .iter()
                                .flat_map(|pre_candidate_slice| {
                                    postprocessor_rule_chain_candidates
                                        .iter()
                                        .map(move |post_candidate_slice| {
                                            pre_candidate_slice
                                                .iter()
                                                .cloned()
                                                .chain(post_candidate_slice.iter().cloned())
                                                .collect::<Vec<String>>()
                                        })
                                })
                                .collect();
                            let new_deinflection = Translator::_create_deinflection(
                                &raw_source,
                                &source,
                                &transformed_text,
                                conditions,
                                text_processor_rule_chain_candidates,
                                <[_]>::into_vec(
                                    ::alloc::boxed::box_new([inflection_rule_chain_candidate]),
                                ),
                            );
                            db_deinflections.push(new_deinflection);
                        }
                    }
                }
                raw_source = Translator::_get_next_substring(
                    opts.search_resolution,
                    &raw_source,
                );
            }
            Ok(db_deinflections)
        }
        fn _get_text_variants(
            text: &str,
            text_processors: &[TextProcessorWithId],
            text_replacements: FindTermsTextReplacements,
            text_cache: &mut TextCache,
        ) -> VariantAndTextProcessorRuleChainCandidatesMap {
            let mut variants_map: VariantAndTextProcessorRuleChainCandidatesMap = IndexMap::new();
            variants_map
                .insert(
                    text.to_string(),
                    <[_]>::into_vec(::alloc::boxed::box_new([::alloc::vec::Vec::new()])),
                );
            for (id, replacement) in text_replacements.iter().enumerate() {
                let Some(replacement) = replacement else {
                    continue;
                };
                let k = Translator::_apply_text_replacements(text, replacement);
                let v = <[_]>::into_vec(
                    ::alloc::boxed::box_new([
                        <[_]>::into_vec(
                            ::alloc::boxed::box_new([
                                ::alloc::__export::must_use({
                                    let res = ::alloc::fmt::format(
                                        format_args!("Text Replacement {0}", id),
                                    );
                                    res
                                }),
                            ]),
                        ),
                    ]),
                );
                variants_map.insert(k, v);
            }
            for processor in text_processors {
                let TextProcessorWithId { id, processor } = processor;
                let TextProcessor { options, process, .. } = processor;
                let mut new_variants_map: VariantAndTextProcessorRuleChainCandidatesMap = IndexMap::new();
                for variant in variants_map.iter() {
                    let (variant, current_preprocessor_rule_chain_candidates) = variant;
                    for opt in options.iter() {
                        let processed = Translator::_get_processed_text(
                            text_cache,
                            variant.clone(),
                            id.to_string(),
                            opt.clone(),
                            *process,
                        );
                        let existing_candidates = new_variants_map.get(&processed);
                        let mapped_current_preprocessor_rule_chain_candidates: Vec<
                            Vec<String>,
                        > = current_preprocessor_rule_chain_candidates
                            .clone()
                            .into_iter()
                            .map(|mut candidate: Vec<String>| {
                                candidate.push(id.to_string());
                                candidate
                            })
                            .collect();
                        if processed == *variant {
                            if let Some(existing_candidates) = existing_candidates {
                                new_variants_map
                                    .insert(processed, existing_candidates.clone());
                            } else {
                                new_variants_map
                                    .insert(
                                        processed,
                                        current_preprocessor_rule_chain_candidates.clone(),
                                    );
                            }
                        } else if let Some(existing_candidates) = existing_candidates {
                            let concat = existing_candidates
                                .clone()
                                .into_iter()
                                .chain(
                                    mapped_current_preprocessor_rule_chain_candidates
                                        .into_iter(),
                                )
                                .collect();
                            new_variants_map.insert(processed, concat);
                        } else {
                            new_variants_map
                                .insert(
                                    processed,
                                    mapped_current_preprocessor_rule_chain_candidates,
                                );
                        }
                    }
                }
                variants_map = new_variants_map;
            }
            variants_map
        }
        fn _add_entries_to_deinflections(
            &self,
            language: &str,
            deinflections: &mut [DatabaseDeinflection],
            enabled_dictionary_map: &FindTermDictionaryMap,
            match_type: TermSourceMatchType,
        ) {
            if deinflections.is_empty() {
                return;
            }
            let mut unique_deinflections_map: IndexMap<
                String,
                Vec<&mut DatabaseDeinflection>,
            > = IndexMap::new();
            for deinflection in deinflections.iter_mut() {
                if deinflection.deinflected_text.is_empty() {
                    continue;
                }
                unique_deinflections_map
                    .entry(deinflection.deinflected_text.clone())
                    .or_default()
                    .push(deinflection);
            }
            let mut unique_deinflection_terms: Vec<String> = unique_deinflections_map
                .keys()
                .cloned()
                .collect();
            let mut unique_deinflection_arrays: Vec<Vec<&mut DatabaseDeinflection>> = unique_deinflections_map
                .into_values()
                .collect();
            let database_entries = match self
                .db
                .find_terms_bulk(
                    &unique_deinflection_terms,
                    &enabled_dictionary_map,
                    match_type,
                )
            {
                Ok(entries) => entries,
                Err(e) => ::alloc::vec::Vec::new(),
            };
            self._match_entries_to_deinflections(
                language,
                &database_entries,
                &mut unique_deinflection_arrays,
                enabled_dictionary_map,
            );
        }
        fn _match_entries_to_deinflections(
            &self,
            language: &str,
            database_entries: &[TermEntry],
            unique_deinflection_arrays: &mut [Vec<&mut DatabaseDeinflection>],
            enabled_dictionary_map: &FindTermDictionaryMap,
        ) {
            for entry in database_entries {
                let entry_dictionary = enabled_dictionary_map
                    .get(&entry.dictionary)
                    .unwrap_or_else(|| {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "{0} was not found in enabled_dictionary_map",
                                    &entry.dictionary,
                                ),
                            );
                        }
                    });
                let definition_conditions = self
                    .mlt
                    .get_condition_flags_from_parts_of_speech(language, &entry.rules);
                if let Some(deinflection_group) = unique_deinflection_arrays
                    .get_mut(entry.index)
                {
                    for deinflection in deinflection_group.iter_mut() {
                        if !entry_dictionary.parts_of_speech_filter
                            || LanguageTransformer::conditions_match(
                                deinflection.conditions,
                                definition_conditions,
                            )
                        {
                            deinflection.database_entries.push(entry.clone());
                        }
                    }
                }
            }
        }
        /// this might be incorrect based on the javascript function
        fn _group_deinflections_by_term(
            deinflections: &[DatabaseDeinflection],
        ) -> IndexMap<String, Vec<DatabaseDeinflection>> {
            let mut result: IndexMap<String, Vec<DatabaseDeinflection>> = IndexMap::new();
            for deinflection in deinflections {
                let key = deinflection.deinflected_text.clone();
                result.entry(key).or_default().push(deinflection.clone());
            }
            result
        }
        /// helper function to return `(opts: FindTermOptions).text_replacements`
        fn _get_text_replacement_variants(
            opts: &FindTermsOptions,
        ) -> FindTermsTextReplacements {
            opts.text_replacements.clone()
        }
        fn _create_deinflection(
            original_text: &str,
            transformed_text: &str,
            deinflected_text: &str,
            conditions: usize,
            text_processor_rule_chain_candidates: Vec<TextProcessorRuleChainCandidate>,
            inflection_rule_chain_candidates: Vec<InternalInflectionRuleChainCandidate>,
        ) -> DatabaseDeinflection {
            DatabaseDeinflection {
                original_text: original_text.to_string(),
                transformed_text: transformed_text.to_string(),
                deinflected_text: deinflected_text.to_string(),
                conditions,
                text_processor_rule_chain_candidates,
                inflection_rule_chain_candidates,
                database_entries: ::alloc::vec::Vec::new(),
            }
        }
        fn _apply_text_replacements(
            text: &str,
            replacements: &[FindTermsTextReplacement],
        ) -> String {
            let mut text = text.to_string();
            for replacement in replacements {
                let FindTermsTextReplacement { pattern, replacement, is_global } = replacement;
                text = apply_text_replacement(&text, pattern, replacement, is_global);
            }
            text
        }
        fn _get_processed_text(
            text_cache: &mut TextCache,
            text_key: String,
            id_key: String,
            setting: TextProcessorSetting,
            process: fn(&str, TextProcessorSetting) -> String,
        ) -> String {
            let level1_map = text_cache.entry(text_key.clone()).or_default();
            let level2_map = level1_map.entry(id_key).or_default();
            if let Some(cached_processed_text_ref) = level2_map.get(&setting) {
                cached_processed_text_ref.to_string()
            } else {
                let processed_text_string: String = process(&text_key, setting.clone());
                level2_map.insert(setting, processed_text_string.clone());
                processed_text_string
            }
        }
        fn _get_next_substring(
            search_resolution: SearchResolution,
            current_str: &str,
        ) -> String {
            let end_byte_index: usize;
            if search_resolution == SearchResolution::Word {
                if let Some(mat) = GET_NEXT_SUBSTRING_REGEX.find(current_str).unwrap() {
                    end_byte_index = mat.start();
                } else {
                    end_byte_index = 0;
                }
            } else {
                let char_count = current_str.chars().count();
                if char_count <= 1 {
                    end_byte_index = 0;
                } else {
                    end_byte_index = current_str
                        .char_indices()
                        .nth(char_count - 1)
                        .unwrap()
                        .0;
                }
            }
            String::from(&current_str[0..end_byte_index])
        }
        /// Returns the initial portion of a string containing only Japanese or Chinese characters.
        ///
        /// It scans the input string and returns a slice ending just before the first
        /// character that is not considered Japanese or Chinese. If all characters
        /// are Japanese or Chinese, the entire input string slice is returned.
        ///
        /// # Arguments
        /// * `text` - The input string slice to process.
        ///
        /// # Returns
        /// A string slice containing only the leading Japanese/Chinese characters.
        fn get_japanese_chinese_only_text(text: &str) -> String {
            for (byte_index, c) in text.char_indices() {
                let code_point = c as u32;
                if !is_code_point_japanese(code_point)
                    && !is_code_point_chinese(code_point)
                {
                    return text[..byte_index].to_string();
                }
            }
            text.to_string()
        }
    }
    static GET_NEXT_SUBSTRING_REGEX: LazyLock<Regex> = LazyLock::new(|| {
        Regex::new(r"[^\p{L}][\p{L}\p{N}]*$")
            .expect("Invalid get_next_substring_regex pattern")
    });
    pub struct TagGroup {
        dictionary: String,
        tag_names: Vec<String>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TagGroup {
        #[inline]
        fn clone(&self) -> TagGroup {
            TagGroup {
                dictionary: ::core::clone::Clone::clone(&self.dictionary),
                tag_names: ::core::clone::Clone::clone(&self.tag_names),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TagGroup {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "TagGroup",
                "dictionary",
                &self.dictionary,
                "tag_names",
                &&self.tag_names,
            )
        }
    }
    type TagCache = IndexMap<String, Option<DatabaseTag>>;
    pub struct TagTargetItem {
        pub query: String,
        pub dictionary: String,
        pub tag_name: String,
        pub cache: Option<TagCache>,
        pub database_tag: Option<DatabaseTag>,
        pub targets: Vec<Vec<DictionaryTag>>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TagTargetItem {
        #[inline]
        fn clone(&self) -> TagTargetItem {
            TagTargetItem {
                query: ::core::clone::Clone::clone(&self.query),
                dictionary: ::core::clone::Clone::clone(&self.dictionary),
                tag_name: ::core::clone::Clone::clone(&self.tag_name),
                cache: ::core::clone::Clone::clone(&self.cache),
                database_tag: ::core::clone::Clone::clone(&self.database_tag),
                targets: ::core::clone::Clone::clone(&self.targets),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TagTargetItem {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "query",
                "dictionary",
                "tag_name",
                "cache",
                "database_tag",
                "targets",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.query,
                &self.dictionary,
                &self.tag_name,
                &self.cache,
                &self.database_tag,
                &&self.targets,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "TagTargetItem",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TagTargetItem {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TagTargetItem {
        #[inline]
        fn eq(&self, other: &TagTargetItem) -> bool {
            self.query == other.query && self.dictionary == other.dictionary
                && self.tag_name == other.tag_name && self.cache == other.cache
                && self.database_tag == other.database_tag
                && self.targets == other.targets
        }
    }
    struct TagExpansionTarget {
        tags: Vec<DictionaryTag>,
        tag_groups: Vec<TagGroup>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TagExpansionTarget {
        #[inline]
        fn clone(&self) -> TagExpansionTarget {
            TagExpansionTarget {
                tags: ::core::clone::Clone::clone(&self.tags),
                tag_groups: ::core::clone::Clone::clone(&self.tag_groups),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TagExpansionTarget {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "TagExpansionTarget",
                "tags",
                &self.tags,
                "tag_groups",
                &&self.tag_groups,
            )
        }
    }
    struct TranslatorTagAggregator {
        tag_expansion_target_map: IndexMap<Vec<DictionaryTag>, Vec<TagGroup>>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TranslatorTagAggregator {
        #[inline]
        fn clone(&self) -> TranslatorTagAggregator {
            TranslatorTagAggregator {
                tag_expansion_target_map: ::core::clone::Clone::clone(
                    &self.tag_expansion_target_map,
                ),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TranslatorTagAggregator {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "TranslatorTagAggregator",
                "tag_expansion_target_map",
                &&self.tag_expansion_target_map,
            )
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for TranslatorTagAggregator {
        #[inline]
        fn default() -> TranslatorTagAggregator {
            TranslatorTagAggregator {
                tag_expansion_target_map: ::core::default::Default::default(),
            }
        }
    }
    impl TranslatorTagAggregator {
        pub fn new() -> Self {
            Self::default()
        }
        /// Adds tags to a specific dictionary group associated with a primary list of tags.
        ///
        /// # Arguments
        /// * `tags_key` - The primary list of DictionaryTags (the key).
        /// * `dictionary_name` - The name of the dictionary to associate the new tag names with.
        /// * `tag_names_to_add` - A slice of tag names to add to the specified dictionary group.
        pub fn add_tags(
            &mut self,
            tags_key: &[DictionaryTag],
            dictionary_name: &str,
            tag_names_to_add: &[String],
        ) {
            if tag_names_to_add.is_empty() {
                return;
            }
            let target_collection_of_tag_groups = self
                ._get_or_create_tag_groups(tags_key);
            let specific_tag_group = Self::_get_or_create_tag_group_in_collection(
                target_collection_of_tag_groups,
                dictionary_name,
            );
            Self::_add_unique_tags_to_group(specific_tag_group, tag_names_to_add);
        }
        /// Adds new tag names to a TagGroup, ensuring uniqueness.
        fn _add_unique_tags_to_group(
            tag_group: &mut TagGroup,
            new_tag_names_slice: &[String],
        ) {
            for tag_name_to_add in new_tag_names_slice {
                if !tag_group.tag_names.contains(tag_name_to_add) {
                    tag_group.tag_names.push(tag_name_to_add.clone());
                }
            }
        }
        /// Retrieves all tag expansion targets.
        /// Each target consists of a list of primary tags and their associated grouped tags.
        pub fn get_tag_expansion_targets(&self) -> Vec<TagExpansionTarget> {
            self.tag_expansion_target_map
                .iter()
                .map(|(tags_vec, tag_groups_vec)| TagExpansionTarget {
                    tags: tags_vec.clone(),
                    tag_groups: tag_groups_vec.clone(),
                })
                .collect()
        }
        /// Merges tag groups from a source entry (identified by `tags_key_source`)
        /// into a target entry (identified by `tags_key_target`).
        pub fn merge_tags(
            &mut self,
            tags_key_target: &[DictionaryTag],
            tags_key_source: &[DictionaryTag],
        ) {
            let source_groups_list_option = self
                .tag_expansion_target_map
                .get(tags_key_source)
                .cloned();
            if let Some(source_groups_list) = source_groups_list_option {
                let target_collection_of_tag_groups = self
                    ._get_or_create_tag_groups(tags_key_target);
                for source_tag_group_item in source_groups_list {
                    let specific_target_tag_group = Self::_get_or_create_tag_group_in_collection(
                        target_collection_of_tag_groups,
                        &source_tag_group_item.dictionary,
                    );
                    Self::_add_unique_tags_to_group(
                        specific_target_tag_group,
                        &source_tag_group_item.tag_names,
                    );
                }
            }
        }
        /// Gets or creates a mutable reference to the list of TagGroups for a given key.
        /// The key `tags_key_slice` is cloned to
        /// create an owned `Vec<DictionaryTag>` for map insertion if needed.
        fn _get_or_create_tag_groups(
            &mut self,
            tags_key_slice: &[DictionaryTag],
        ) -> &mut Vec<TagGroup> {
            self.tag_expansion_target_map.entry(tags_key_slice.to_vec()).or_default()
        }
        /// Finds or creates a specific TagGroup within a given collection of
        /// TagGroups, based on dictionary name.
        /// Returns a mutable reference to the TagGroup.
        fn _get_or_create_tag_group_in_collection<'cl>(
            collection_of_tag_groups: &'cl mut Vec<TagGroup>,
            dictionary_name: &str,
        ) -> &'cl mut TagGroup {
            let position = collection_of_tag_groups
                .iter()
                .position(|group| group.dictionary == dictionary_name);
            if let Some(pos) = position {
                return &mut collection_of_tag_groups[pos];
            }
            let new_tag_group = TagGroup {
                dictionary: dictionary_name.to_string(),
                tag_names: Vec::new(),
            };
            collection_of_tag_groups.push(new_tag_group);
            collection_of_tag_groups.last_mut().unwrap()
        }
    }
    struct SequenceQuery {
        query: i128,
        dictionary: String,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for SequenceQuery {
        #[inline]
        fn clone(&self) -> SequenceQuery {
            SequenceQuery {
                query: ::core::clone::Clone::clone(&self.query),
                dictionary: ::core::clone::Clone::clone(&self.dictionary),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for SequenceQuery {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "SequenceQuery",
                "query",
                &self.query,
                "dictionary",
                &&self.dictionary,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for SequenceQuery {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for SequenceQuery {
        #[inline]
        fn eq(&self, other: &SequenceQuery) -> bool {
            self.query == other.query && self.dictionary == other.dictionary
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for SequenceQuery {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<i128>;
            let _: ::core::cmp::AssertParamIsEq<String>;
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for SequenceQuery {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.query, state);
            ::core::hash::Hash::hash(&self.dictionary, state)
        }
    }
    pub enum FindTermsMode {
        #[default]
        Simple,
        Group,
        Merge,
        Split,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for FindTermsMode {
        #[inline]
        fn clone(&self) -> FindTermsMode {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for FindTermsMode {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for FindTermsMode {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for FindTermsMode {
        #[inline]
        fn eq(&self, other: &FindTermsMode) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for FindTermsMode {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for FindTermsMode {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_discr, state)
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for FindTermsMode {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    FindTermsMode::Simple => "Simple",
                    FindTermsMode::Group => "Group",
                    FindTermsMode::Merge => "Merge",
                    FindTermsMode::Split => "Split",
                },
            )
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for FindTermsMode {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    FindTermsMode::Simple => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "FindTermsMode",
                            0u32,
                            "Simple",
                        )
                    }
                    FindTermsMode::Group => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "FindTermsMode",
                            1u32,
                            "Group",
                        )
                    }
                    FindTermsMode::Merge => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "FindTermsMode",
                            2u32,
                            "Merge",
                        )
                    }
                    FindTermsMode::Split => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "FindTermsMode",
                            3u32,
                            "Split",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for FindTermsMode {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 4",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Simple" => _serde::__private::Ok(__Field::__field0),
                            "Group" => _serde::__private::Ok(__Field::__field1),
                            "Merge" => _serde::__private::Ok(__Field::__field2),
                            "Split" => _serde::__private::Ok(__Field::__field3),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Simple" => _serde::__private::Ok(__Field::__field0),
                            b"Group" => _serde::__private::Ok(__Field::__field1),
                            b"Merge" => _serde::__private::Ok(__Field::__field2),
                            b"Split" => _serde::__private::Ok(__Field::__field3),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<FindTermsMode>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = FindTermsMode;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum FindTermsMode",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(FindTermsMode::Simple)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(FindTermsMode::Group)
                            }
                            (__Field::__field2, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(FindTermsMode::Merge)
                            }
                            (__Field::__field3, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(FindTermsMode::Split)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "Simple",
                    "Group",
                    "Merge",
                    "Split",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "FindTermsMode",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<FindTermsMode>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for FindTermsMode {
        #[inline]
        fn default() -> FindTermsMode {
            Self::Simple
        }
    }
    trait HasTags {
        fn _get_definition_tags_mut(&mut self) -> &mut Vec<DictionaryTag>;
    }
    impl HasTags for TermDefinition {
        fn _get_definition_tags_mut(&mut self) -> &mut Vec<DictionaryTag> {
            &mut self.tags
        }
    }
    impl HasTags for TermHeadword {
        fn _get_definition_tags_mut(&mut self) -> &mut Vec<DictionaryTag> {
            &mut self.tags
        }
    }
    pub enum TermTypeError {
        #[error("could not convert from TermType::{}: to {target}", value.name_as_str())]
        TryFrom { value: TermType, target: &'static str },
    }
    #[allow(unused_qualifications)]
    #[automatically_derived]
    impl ::thiserror::__private::Error for TermTypeError {}
    #[allow(unused_qualifications)]
    #[automatically_derived]
    impl ::core::fmt::Display for TermTypeError {
        fn fmt(&self, __formatter: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            use ::thiserror::__private::AsDisplay as _;
            #[allow(unused_variables, deprecated, clippy::used_underscore_binding)]
            match self {
                TermTypeError::TryFrom { value, target } => {
                    match (target.as_display(),) {
                        (__display_target,) => {
                            __formatter
                                .write_fmt(
                                    format_args!(
                                        "could not convert from TermType::{0}: to {1}",
                                        value.name_as_str(),
                                        __display_target,
                                    ),
                                )
                        }
                    }
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TermTypeError {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                TermTypeError::TryFrom { value: __self_0, target: __self_1 } => {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "TryFrom",
                        "value",
                        __self_0,
                        "target",
                        &__self_1,
                    )
                }
            }
        }
    }
    /// used to differentiate between the following:
    /// [TermDefinition]
    /// [TermPronunciation]
    /// [TermFrequency]
    pub enum TermType {
        Definition(TermDefinition),
        Pronunciation(TermPronunciation),
        Frequency(TermFrequency),
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TermType {
        #[inline]
        fn clone(&self) -> TermType {
            match self {
                TermType::Definition(__self_0) => {
                    TermType::Definition(::core::clone::Clone::clone(__self_0))
                }
                TermType::Pronunciation(__self_0) => {
                    TermType::Pronunciation(::core::clone::Clone::clone(__self_0))
                }
                TermType::Frequency(__self_0) => {
                    TermType::Frequency(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TermType {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TermType {
        #[inline]
        fn eq(&self, other: &TermType) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
                && match (self, other) {
                    (TermType::Definition(__self_0), TermType::Definition(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (
                        TermType::Pronunciation(__self_0),
                        TermType::Pronunciation(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (TermType::Frequency(__self_0), TermType::Frequency(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TermType {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                TermType::Definition(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Definition",
                        &__self_0,
                    )
                }
                TermType::Pronunciation(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Pronunciation",
                        &__self_0,
                    )
                }
                TermType::Frequency(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Frequency",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl derive_more::From<(TermDefinition)> for TermType {
        #[inline]
        fn from(value: (TermDefinition)) -> Self {
            TermType::Definition(value)
        }
    }
    #[automatically_derived]
    impl derive_more::From<(TermPronunciation)> for TermType {
        #[inline]
        fn from(value: (TermPronunciation)) -> Self {
            TermType::Pronunciation(value)
        }
    }
    #[automatically_derived]
    impl derive_more::From<(TermFrequency)> for TermType {
        #[inline]
        fn from(value: (TermFrequency)) -> Self {
            TermType::Frequency(value)
        }
    }
    impl TermType {
        /// returns the name of the variant
        fn name_as_str(&self) -> &'static str {
            match &self {
                Self::Definition(_) => "Definition",
                Self::Frequency(_) => "Frequency",
                Self::Pronunciation(_) => "Pronunciation",
            }
        }
    }
    /// helper to not need to match on enum variants to get fields
    trait IsTermType {
        /// only exists on [TermDefinition]
        /// only exists on [TermFrequency] && [TermPronunciation]
        fn _get_ipa_or_freq_headword_index(&self) -> Option<usize>;
        fn dictionary_index(&self) -> usize;
        fn index(&self) -> usize;
        /// gets the term's (`.dictionary, .dictionary_alias`)
        fn dictionary_and_alias(&self) -> (&str, &str);
    }
    impl IsTermType for TermType {
        /// generic for all variants
        fn dictionary_and_alias(&self) -> (&str, &str) {
            match &self {
                Self::Definition(m) => (&m.dictionary, &m.dictionary_alias),
                Self::Frequency(m) => (&m.dictionary, &m.dictionary_alias),
                Self::Pronunciation(m) => (&m.dictionary, &m.dictionary_alias),
            }
        }
        fn dictionary_index(&self) -> usize {
            match self {
                TermType::Definition(d) => d.dictionary_index,
                TermType::Pronunciation(p) => p.dictionary_index,
                TermType::Frequency(f) => f.dictionary_index,
            }
        }
        fn index(&self) -> usize {
            match self {
                TermType::Definition(d) => d.index,
                TermType::Pronunciation(p) => p.index,
                TermType::Frequency(f) => f.index,
            }
        }
        /// only exists on [TermFrequency] && [TermPronunciation]
        fn _get_ipa_or_freq_headword_index(&self) -> Option<usize> {
            match self {
                TermType::Pronunciation(p) => Some(p.headword_index),
                TermType::Frequency(f) => Some(f.headword_index),
                _ => None,
            }
        }
    }
    impl TryFrom<TermType> for TermFrequency {
        type Error = TermTypeError;
        fn try_from(value: TermType) -> Result<Self, Self::Error> {
            match value {
                TermType::Frequency(f) => Ok(f),
                _ => {
                    Err(TermTypeError::TryFrom {
                        value,
                        target: "TermFrequency",
                    })
                }
            }
        }
    }
    impl TryFrom<TermType> for TermDefinition {
        type Error = TermTypeError;
        fn try_from(value: TermType) -> Result<Self, Self::Error> {
            match value {
                TermType::Definition(d) => Ok(d),
                _ => {
                    Err(TermTypeError::TryFrom {
                        value,
                        target: "TermDefinition",
                    })
                }
            }
        }
    }
    impl TryFrom<TermType> for TermPronunciation {
        type Error = TermTypeError;
        fn try_from(value: TermType) -> Result<Self, Self::Error> {
            match value {
                TermType::Pronunciation(p) => Ok(p),
                _ => {
                    Err(TermTypeError::TryFrom {
                        value,
                        target: "TermPronunciation",
                    })
                }
            }
        }
    }
    pub type TermEnabledDictionaryMap = IndexMap<String, FindTermDictionary>;
    pub type KanjiEnabledDictionaryMap = IndexMap<String, FindKanjiDictionary>;
    pub enum EnabledDictionaryMapType<'a> {
        Term(&'a TermEnabledDictionaryMap),
        Kanji(&'a KanjiEnabledDictionaryMap),
    }
    #[automatically_derived]
    impl<'a> ::core::clone::Clone for EnabledDictionaryMapType<'a> {
        #[inline]
        fn clone(&self) -> EnabledDictionaryMapType<'a> {
            match self {
                EnabledDictionaryMapType::Term(__self_0) => {
                    EnabledDictionaryMapType::Term(::core::clone::Clone::clone(__self_0))
                }
                EnabledDictionaryMapType::Kanji(__self_0) => {
                    EnabledDictionaryMapType::Kanji(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::fmt::Debug for EnabledDictionaryMapType<'a> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                EnabledDictionaryMapType::Term(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Term",
                        &__self_0,
                    )
                }
                EnabledDictionaryMapType::Kanji(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Kanji",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl<'a> ::core::marker::StructuralPartialEq for EnabledDictionaryMapType<'a> {}
    #[automatically_derived]
    impl<'a> ::core::cmp::PartialEq for EnabledDictionaryMapType<'a> {
        #[inline]
        fn eq(&self, other: &EnabledDictionaryMapType<'a>) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
                && match (self, other) {
                    (
                        EnabledDictionaryMapType::Term(__self_0),
                        EnabledDictionaryMapType::Term(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        EnabledDictionaryMapType::Kanji(__self_0),
                        EnabledDictionaryMapType::Kanji(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    pub struct ExistingEntry {
        pub index: usize,
        pub entry: InternalTermDictionaryEntry,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ExistingEntry {
        #[inline]
        fn clone(&self) -> ExistingEntry {
            ExistingEntry {
                index: ::core::clone::Clone::clone(&self.index),
                entry: ::core::clone::Clone::clone(&self.entry),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ExistingEntry {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "ExistingEntry",
                "index",
                &self.index,
                "entry",
                &&self.entry,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ExistingEntry {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ExistingEntry {
        #[inline]
        fn eq(&self, other: &ExistingEntry) -> bool {
            self.index == other.index && self.entry == other.entry
        }
    }
    pub struct InternalTermDictionaryEntryWithIndexes {
        pub index: usize,
        pub dictionary_entry: InternalTermDictionaryEntry,
        pub headword_indexes: Vec<usize>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for InternalTermDictionaryEntryWithIndexes {
        #[inline]
        fn clone(&self) -> InternalTermDictionaryEntryWithIndexes {
            InternalTermDictionaryEntryWithIndexes {
                index: ::core::clone::Clone::clone(&self.index),
                dictionary_entry: ::core::clone::Clone::clone(&self.dictionary_entry),
                headword_indexes: ::core::clone::Clone::clone(&self.headword_indexes),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for InternalTermDictionaryEntryWithIndexes {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "InternalTermDictionaryEntryWithIndexes",
                "index",
                &self.index,
                "dictionary_entry",
                &self.dictionary_entry,
                "headword_indexes",
                &&self.headword_indexes,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for InternalTermDictionaryEntryWithIndexes {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for InternalTermDictionaryEntryWithIndexes {
        #[inline]
        fn eq(&self, other: &InternalTermDictionaryEntryWithIndexes) -> bool {
            self.index == other.index && self.dictionary_entry == other.dictionary_entry
                && self.headword_indexes == other.headword_indexes
        }
    }
    struct TermReadingItem {
        pub term: String,
        pub reading: Option<String>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TermReadingItem {
        #[inline]
        fn clone(&self) -> TermReadingItem {
            TermReadingItem {
                term: ::core::clone::Clone::clone(&self.term),
                reading: ::core::clone::Clone::clone(&self.reading),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TermReadingItem {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "TermReadingItem",
                "term",
                &self.term,
                "reading",
                &&self.reading,
            )
        }
    }
    pub struct FindTermsResult {
        pub dictionary_entries: Vec<TermDictionaryEntry>,
        pub original_text_length: i128,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for FindTermsResult {
        #[inline]
        fn clone(&self) -> FindTermsResult {
            FindTermsResult {
                dictionary_entries: ::core::clone::Clone::clone(
                    &self.dictionary_entries,
                ),
                original_text_length: ::core::clone::Clone::clone(
                    &self.original_text_length,
                ),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for FindTermsResult {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "FindTermsResult",
                "dictionary_entries",
                &self.dictionary_entries,
                "original_text_length",
                &&self.original_text_length,
            )
        }
    }
    type TextProcessorMap = IndexMap<&'static str, PreAndPostProcessorsWithId>;
    type ReadingNormalizerMap = IndexMap<&'static str, ReadingNormalizer>;
    pub enum TranslatorError {
        #[error("Unsupported Language: {0}")]
        UnsupportedLanguage(String),
    }
    #[allow(unused_qualifications)]
    #[automatically_derived]
    impl ::thiserror::__private::Error for TranslatorError {}
    #[allow(unused_qualifications)]
    #[automatically_derived]
    impl ::core::fmt::Display for TranslatorError {
        fn fmt(&self, __formatter: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            use ::thiserror::__private::AsDisplay as _;
            #[allow(unused_variables, deprecated, clippy::used_underscore_binding)]
            match self {
                TranslatorError::UnsupportedLanguage(_0) => {
                    match (_0.as_display(),) {
                        (__display0,) => {
                            __formatter
                                .write_fmt(
                                    format_args!("Unsupported Language: {0}", __display0),
                                )
                        }
                    }
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TranslatorError {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                TranslatorError::UnsupportedLanguage(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "UnsupportedLanguage",
                        &__self_0,
                    )
                }
            }
        }
    }
    struct TermMetaHeadword {
        headword_index: usize,
        original_index: usize,
        pronunciations: Vec<TermPronunciation>,
        frequencies: Vec<TermFrequency>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for TermMetaHeadword {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "TermMetaHeadword",
                "headword_index",
                &self.headword_index,
                "original_index",
                &self.original_index,
                "pronunciations",
                &self.pronunciations,
                "frequencies",
                &&self.frequencies,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for TermMetaHeadword {
        #[inline]
        fn clone(&self) -> TermMetaHeadword {
            TermMetaHeadword {
                headword_index: ::core::clone::Clone::clone(&self.headword_index),
                original_index: ::core::clone::Clone::clone(&self.original_index),
                pronunciations: ::core::clone::Clone::clone(&self.pronunciations),
                frequencies: ::core::clone::Clone::clone(&self.frequencies),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for TermMetaHeadword {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for TermMetaHeadword {
        #[inline]
        fn eq(&self, other: &TermMetaHeadword) -> bool {
            self.headword_index == other.headword_index
                && self.original_index == other.original_index
                && self.pronunciations == other.pronunciations
                && self.frequencies == other.frequencies
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for TermMetaHeadword {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<usize>;
            let _: ::core::cmp::AssertParamIsEq<Vec<TermPronunciation>>;
            let _: ::core::cmp::AssertParamIsEq<Vec<TermFrequency>>;
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for TermMetaHeadword {
        #[inline]
        fn partial_cmp(
            &self,
            other: &TermMetaHeadword,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match ::core::cmp::PartialOrd::partial_cmp(
                &self.headword_index,
                &other.headword_index,
            ) {
                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                    match ::core::cmp::PartialOrd::partial_cmp(
                        &self.original_index,
                        &other.original_index,
                    ) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match ::core::cmp::PartialOrd::partial_cmp(
                                &self.pronunciations,
                                &other.pronunciations,
                            ) {
                                ::core::option::Option::Some(
                                    ::core::cmp::Ordering::Equal,
                                ) => {
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &self.frequencies,
                                        &other.frequencies,
                                    )
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for TermMetaHeadword {
        #[inline]
        fn cmp(&self, other: &TermMetaHeadword) -> ::core::cmp::Ordering {
            match ::core::cmp::Ord::cmp(&self.headword_index, &other.headword_index) {
                ::core::cmp::Ordering::Equal => {
                    match ::core::cmp::Ord::cmp(
                        &self.original_index,
                        &other.original_index,
                    ) {
                        ::core::cmp::Ordering::Equal => {
                            match ::core::cmp::Ord::cmp(
                                &self.pronunciations,
                                &other.pronunciations,
                            ) {
                                ::core::cmp::Ordering::Equal => {
                                    ::core::cmp::Ord::cmp(&self.frequencies, &other.frequencies)
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    }
                }
                cmp => cmp,
            }
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for TermMetaHeadword {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.headword_index, state);
            ::core::hash::Hash::hash(&self.original_index, state);
            ::core::hash::Hash::hash(&self.pronunciations, state);
            ::core::hash::Hash::hash(&self.frequencies, state)
        }
    }
    type TermMetaHeadwordMap = IndexMap<String, IndexMap<String, Vec<TermMetaHeadword>>>;
}
mod method_modules {
    mod dictionary_options {
        use std::collections::HashSet;
        use super::create_method_module_mut;
        use crate::{
            settings::{self, DictionaryOptions},
            Yomichan,
        };
        use indexmap::IndexMap;
        use module_macros::{ref_variant, skip_ref};
    }
    mod options {
        use super::create_method_module_mut;
        use crate::{settings, Yomichan};
        impl<'a> Yomichan<'a> {
            pub fn options(&'a mut self) -> ModOptions<'a> {
                ModOptions { ycd: self }
            }
        }
        pub struct ModOptions<'a> {
            pub ycd: &'a mut Yomichan<'a>,
        }
    }
    pub(crate) use create_method_module_mut;
}
use backend::Backend;
use database::dictionary_database::DictionaryDatabase;
use database::dictionary_database::DB_MODELS;
use indexmap::IndexMap;
use settings::Options;
use settings::Profile;
use native_db::*;
use native_model::{native_model, Model};
use text_scanner::TextScanner;
use transaction::RTransaction;
use translation::FindTermsOptions;
use translator::FindTermsMode;
use translator::Translator;
use std::collections::HashSet;
use std::fs::DirEntry;
use std::sync::Arc;
use std::{
    ffi::{OsStr, OsString},
    fs, path::{Path, PathBuf},
};
pub use crate::database::dictionary_importer;
pub use crate::dictionary::{TermDefinition, TermFrequency, TermPronunciation};
/// A Yomichan Dictionary instance.
pub struct Yomichan<'a> {
    db: Arc<DictionaryDatabase<'a>>,
    backend: Backend<'a>,
}
impl Yomichan<'_> {
    /// Initializes _(or if one already exists, opens)_ a Yomichan Dictionary Database.
    ///
    /// # Arguments
    /// * `db_path` - The location where the `yomichan/data.db` will be created/opened.
    ///
    /// # Examples
    /// ```
    /// use yomichan_rs::Yomichan;
    ///
    /// // creates a database at `C:/Users/1/Desktop/yomichan/data.db`
    /// let mut ycd = Yomichan::new("c:/users/one/desktop");
    /// ```
    pub fn new(path: impl AsRef<Path>) -> Result<Self, InitError> {
        let path = path.as_ref().to_path_buf();
        let db_path = fmt_dbpath(path)?;
        let db = Arc::new(DictionaryDatabase::new(db_path));
        let backend = Backend::new(db.clone())?;
        Ok(Self { db, backend })
    }
}
/// # Returns
/// Terms for valid PathBuf ending in `.ycd`:
/// - dir is empty (assumes you wants db here)
/// - contains yomichan_rs folder (appends `.ycd` to the path)
/// - already contains a .ycd file
fn find_ydict_file(p: &Path) -> Option<PathBuf> {
    let mut valid_path: Option<PathBuf> = None;
    let rdir: HashSet<PathBuf> = std::fs::read_dir(p)
        .unwrap()
        .flatten()
        .map(|e| e.path())
        .collect();
    if rdir.is_empty() {
        return Some(p.join("db.ycd"));
    }
    if let Some(p) = rdir.get(Path::new("yomichan_rs")) {
        return Some(p.join("db.ycd"));
    }
    rdir.into_iter().find(|p| p.display().to_string().ends_with(".ycd"))
}
/// # Returns
/// A valid PathBuf ending in `.ycd`
/// ...can be opened or created with [`native_db::Builder::open`]
fn fmt_dbpath(p: PathBuf) -> Result<PathBuf, InitError> {
    let fname = p.display().to_string();
    if p.is_file() && fname.ends_with(".ycd") {
        if p.exists() {
            return Ok(p);
        }
        if p.parent().map(|p| p.exists()).unwrap_or(false) {
            return Err(InitError::MissingParent { p });
        }
        return Ok(p);
    }
    if p.is_dir() {
        if let Some(p) = find_ydict_file(&p) {
            return Ok(p);
        }
        let p = p.join("yomichan_rs");
        std::fs::create_dir_all(&p)?;
        return Ok(p.join("db.ycd"));
    }
    Err(InitError::InvalidPath { p })
}
#[error("could not create yomichan_rs dictionary database:")]
pub enum InitError {
    #[error(
        "\ninvalid path: {p} .. help: 
  1. \"~/.home/db.ycd\" - opens a ycd instance
  2. \"~/.home/test\"   - creates a new (blank) .ycd file"
    )]
    InvalidPath { p: PathBuf },
    #[error("path does not have a parent: {p}")]
    MissingParent { p: PathBuf },
    #[error("db conn err: {0}")]
    DatabaseConnectionFailed(#[from] Box<db_type::Error>),
    #[error("io err: {0}")]
    Io(#[from] std::io::Error),
}
#[allow(unused_qualifications)]
#[automatically_derived]
impl ::thiserror::__private::Error for InitError {
    fn source(
        &self,
    ) -> ::core::option::Option<&(dyn ::thiserror::__private::Error + 'static)> {
        use ::thiserror::__private::AsDynError as _;
        #[allow(deprecated)]
        match self {
            InitError::InvalidPath { .. } => ::core::option::Option::None,
            InitError::MissingParent { .. } => ::core::option::Option::None,
            InitError::DatabaseConnectionFailed { 0: source, .. } => {
                ::core::option::Option::Some(source.as_dyn_error())
            }
            InitError::Io { 0: source, .. } => {
                ::core::option::Option::Some(source.as_dyn_error())
            }
        }
    }
}
#[allow(unused_qualifications)]
#[automatically_derived]
impl ::core::fmt::Display for InitError {
    fn fmt(&self, __formatter: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        use ::thiserror::__private::AsDisplay as _;
        #[allow(unused_variables, deprecated, clippy::used_underscore_binding)]
        match self {
            InitError::InvalidPath { p } => {
                match (p.as_display(),) {
                    (__display_p,) => {
                        __formatter
                            .write_fmt(
                                format_args!(
                                    "\ninvalid path: {0} .. help: \n  1. \"~/.home/db.ycd\" - opens a ycd instance\n  2. \"~/.home/test\"   - creates a new (blank) .ycd file",
                                    __display_p,
                                ),
                            )
                    }
                }
            }
            InitError::MissingParent { p } => {
                match (p.as_display(),) {
                    (__display_p,) => {
                        __formatter
                            .write_fmt(
                                format_args!(
                                    "path does not have a parent: {0}",
                                    __display_p,
                                ),
                            )
                    }
                }
            }
            InitError::DatabaseConnectionFailed(_0) => {
                match (_0.as_display(),) {
                    (__display0,) => {
                        __formatter
                            .write_fmt(format_args!("db conn err: {0}", __display0))
                    }
                }
            }
            InitError::Io(_0) => {
                match (_0.as_display(),) {
                    (__display0,) => {
                        __formatter.write_fmt(format_args!("io err: {0}", __display0))
                    }
                }
            }
        }
    }
}
#[allow(
    deprecated,
    unused_qualifications,
    clippy::elidable_lifetime_names,
    clippy::needless_lifetimes,
)]
#[automatically_derived]
impl ::core::convert::From<Box<db_type::Error>> for InitError {
    fn from(source: Box<db_type::Error>) -> Self {
        InitError::DatabaseConnectionFailed {
            0: source,
        }
    }
}
#[allow(
    deprecated,
    unused_qualifications,
    clippy::elidable_lifetime_names,
    clippy::needless_lifetimes,
)]
#[automatically_derived]
impl ::core::convert::From<std::io::Error> for InitError {
    fn from(source: std::io::Error) -> Self {
        InitError::Io { 0: source }
    }
}
impl From<native_db::db_type::Error> for InitError {
    fn from(e: native_db::db_type::Error) -> Self {
        InitError::DatabaseConnectionFailed(Box::new(e))
    }
}
impl std::fmt::Debug for InitError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_fmt(format_args!("{0}", self))
    }
}
